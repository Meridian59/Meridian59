import re
import logging
import random
import string
import base64
import urllib.parse
import boto3
import time
import os

logger = logging.getLogger()
logger.setLevel(logging.INFO)

meridian_domain_name = "https://www.meridian59.com"

def util_check_online(db_check_latest):
    s3_client = boto3.client("s3")
    bucket_name = util_get_output_value("59AccountsDatabaseBucketName")
    object_key_read = os.environ["database_file"]
    response = s3_client.get_object(Bucket=bucket_name, Key=object_key_read)
    db_check_latest = response['ETag']
    return True, db_check_latest

def util_load_account_db(lookup_email, lookup_username, db_check, db_check_latest):
    start = time.time()
    bad_rows = 0
    if db_check != db_check_latest or len(lookup_username) == 0 or len(lookup_email) == 0:
        s3_client = boto3.client("s3")
        bucket_name = util_get_output_value("59AccountsDatabaseBucketName")
        object_key_read = os.environ["database_file"]
        try:
            logger.info(f"Attempting to open S3 {bucket_name}:{object_key_read}")
            file_obj = s3_client.get_object(Bucket=bucket_name, Key=object_key_read)
            file_content = file_obj["Body"].read().decode("utf-8")
            logger.info("Found db look up file!")
            line_number = 0
            lines = file_content.strip().split("\n")
            for line in lines:
                line_number = line_number + 1

                parts = line.split(",")
                parts = [part.strip('"') if part != "" else "" for part in parts]

                try:

                    username_key = f"{parts[0].lower()}_{parts[2]}"
                    lookup_username[username_key] = f"{parts[1]}_{parts[3]}"

                    email_key = f"{parts[1].lower()}_{parts[2]}"
                    lookup_email[email_key] = 1

                except Exception as e:
                    bad_rows = bad_rows + 1
                    logger.info(f"skipping invalid account row: {e}")
                    logger.info(f"{line} at line: {line_number}")

            logger.info(f"Time to parse and cache account database: {time.time() - start}")
            logger.info(f"{len(lookup_username)} accounts loaded!")
            logger.info(f"bad rows: {bad_rows}")

            # update the db check with the latest ETag seen (typically md5 hash of the file)
            db_check = file_obj['ETag']

        except Exception as e:
            logger.error(f"Failed to load from cache {e}")
    else:
        logger.info(f"** Using account lookup straight from the cache. **")

    return lookup_email, lookup_username, db_check, db_check_latest


def util_get_output_value(key):
    cloudformation = boto3.resource("cloudformation")
    stack = cloudformation.Stack(name="Meridian59")
    api_url = next(output["OutputValue"] for output in stack.outputs if output["OutputKey"] == key)
    return api_url


def util_get_random_string(length):
    # Choose from all lowercase letters and digits
    letters_and_digits = string.ascii_lowercase + string.digits
    result_str = "".join(random.choice(letters_and_digits) for i in range(length))
    return result_str


def util_decode_request_body(encoded_str):
    logger.debug(f"Decoding: {encoded_str}")
    params = urllib.parse.parse_qs(encoded_str)

    # Convert each list of values to a single value
    single_value_params = {k: v[0] for k, v in params.items()}

    return single_value_params


# Make a regular expression for validating an Email
def util_valid_email(email):
    regex = r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b"
    # pass the regular expression
    # and the string into the fullmatch() method
    if re.fullmatch(regex, email):
        return True

    else:
        return False


def util_valid_username_characters(username):
    return not re.search(r"[^A-Za-z0-9.#\\$-]", username)


def util_valid_username(username):
    if (
        len(username) < 6
        or len(username) > 32
        or not util_valid_username_characters(username)
    ):
        return False
    return True


def util_valid_server(server):
    if server != "101" and server != "102":
        return False
    return True


def util_validate_password(password, password2):
    # Check for whitespace
    if re.search(r"\s", password):
        return False

    # Check if passwords match
    if password != password2:
        return False

    # Check password length
    if len(password) < 6 or len(password) > 32:
        return False

    # Check for non-ASCII characters
    if any(ord(char) > 127 for char in password):
        return False

    return True
