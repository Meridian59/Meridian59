// Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
// All rights reserved.
//
// This software is distributed under a license that is described in
// the LICENSE file that accompanies it.
//
// Meridian is a registered trademark.
/*
 * makepal.c:  Automatically generate .c and .h files containing palettes.
 *   This program takes a palette file containing (R, G, B) triplets, one
 *   to a line, and produces a source file containing a structure with 
 *   lighting palettes for use in palette.c.
 */

#include <stdio.h>
#include <math.h>
#include <process.h>
#include "drawdefs.h"

#define FALSE (3 == 7)
#define TRUE (3 == 3)

#define min(x, y) ((x) < (y) ? (x) : (y))

static char output_file[] = "pal.c";
static char progname[] = "MAKEPAL";

typedef struct {
   int red, blue, green;
} Color;

static Color colors[NUM_COLORS];   /* Colors of our standard palette */
static unsigned char _blend25[NUM_COLORS*NUM_COLORS];
static unsigned char _blend50[NUM_COLORS*NUM_COLORS];
static unsigned char _blend75[NUM_COLORS*NUM_COLORS];

/* For a given light level l, light_palettes[l][x] gives closest color to x in default palette */
unsigned char light_palettes[NUM_PALETTES][NUM_COLORS];

/* Palette indexes which are not found, computed or changed, ever.
 * These are the magic four Windows colors, plus any colors reserved for
 * special effects like luminant colors.
 */
static int _nevermap_list[] =
{
	8, 9, 10, 11, 12, 13, 14, 15,
	247, 246, 245, 244,
	-1
};
static int _nevermap[NUM_COLORS];

static void ReadPalette(char *file);
static void WritePalette(char *dir);
static void MakeLightPalettes(void);
static void MakeBlendBiXlat(unsigned char* pBiXlat, int partsFirst, int partsSecond);
static void BlockIndices(void);

/************************************************************************/
void usage(void)
{
   printf("usage: makepal <input palette file> <output directory>\n");
   exit(1);
}
/************************************************************************/
void file_error(char *file)
{
   printf("Error with file %s.  Exiting.\n", file);
   exit(1);
}
/************************************************************************/
int main(int argc, char **argv)
{
   char *pal_file, *output_dir;

   if (argc != 3)
      usage();

   pal_file = argv[1];
   output_dir = argv[2];

   ReadPalette(pal_file);

   fprintf(stderr, "Reserving special colors...\n");
   BlockIndices();

   fprintf(stderr, "Computing lighting palettes...\n");
   MakeLightPalettes();

   fprintf(stderr, "Computing blend bixlat palettes...\n");
   MakeBlendBiXlat(_blend25, 25, 75);
   MakeBlendBiXlat(_blend50, 50, 50);
   MakeBlendBiXlat(_blend75, 75, 25);

   fprintf(stderr, "Writing %s...\n", output_file);
   WritePalette(output_dir);

   fprintf(stderr, "Done.\n");
   return 0;
}
/************************************************************************/
/*
 * BlockIndices:  Optimize a list of reserved indices into a lookup.
 */
void BlockIndices()
{
	int i;
	for (i = 0; i < NUM_COLORS; i++)
		_nevermap[i] = FALSE;

	for (i = 0; _nevermap_list[i] >= 0; i++)
		_nevermap[_nevermap_list[i]] = TRUE;
}
/************************************************************************/
/*
 * ReadPalette:  Read colors from palette file into colors structures.
 */
void ReadPalette(char *file)
{
   FILE *infile;
   int index, red, green, blue;

   infile = fopen(file, "r");
   if (infile == NULL)
      file_error(file);

   index = 0;
   while (index < NUM_COLORS && fscanf(infile, "%d %d %d\n", &red, &green, &blue) == 3)
   {
      colors[index].red = red;
      colors[index].blue = blue;
      colors[index].green = green;
      index++;
   }

   if (index != NUM_COLORS)
      file_error(file);
   
   fclose(infile);
}
/************************************************************************/
/*
 * WritePalette:  Write light_palettes out to a file.
 */
void WritePalette(char *dir)
{
   FILE *palfile;
   char tempbuf[512];
   int i, j;

   sprintf(tempbuf, "%s\\%s", dir, output_file);
   palfile = fopen(tempbuf, "wt");

   if (palfile == NULL)
      file_error(tempbuf);

   fprintf(palfile, "/*\n");
   fprintf(palfile, " * %s: Palette tables.\n", output_file);
   fprintf(palfile, " * This file was automatically generated by %s.\n", progname);
   fprintf(palfile, " */\n");
   fprintf(palfile, "#include \"client.h\"\n\n");

   // Write out basic palette
   fprintf(palfile, "Color base_palette[NUM_COLORS] = {\n");
   for (i=0; i < NUM_COLORS; i++)
   {
      fprintf(palfile, "{%3d, %3d, %3d}, // Color %d\n", 
	      (int) colors[i].red, (int) colors[i].green, (int) colors[i].blue, i);
   }
   fprintf(palfile, "\n};\n\n");

   // Write out lighting palettes
   fprintf(palfile, "BYTE  light_palettes[NUM_PALETTES][NUM_COLORS] = {\n");

   for (i=0; i < LIGHT_LEVELS; i++)
   {
      fprintf(palfile, "{  // Palette for light level %d\n", i);
      for (j=0; j < NUM_COLORS; j++)
      {
	 fprintf(palfile, "%3d, ", (int) light_palettes[i][j]);
	 if (j % 16 == 15)
	    fprintf(palfile, "\n");
      }
      fprintf(palfile, "\n},\n");
   }

   // Write out inverted effect palette
   fprintf(palfile, "{  // Palette for inverted effect\n");
   for (j=0; j < NUM_COLORS; j++)
   {
      fprintf(palfile, "%3d, ", (int) light_palettes[PALETTE_INVERT][j]);
      if (j % 16 == 15)
	 fprintf(palfile, "\n");
   }
   fprintf(palfile, "\n},\n");

   fprintf(palfile, "\n};\n\n");

	fprintf(palfile, "\n// Blend 25%% to 75%% Palette:\n");
	fprintf(palfile, "bixlat _blend25 =\n{");
	for (i = 0; i < NUM_COLORS; i++)
	{
		for (j = 0; j < NUM_COLORS; j++)
		{
			if (0 == (j % 16))
				fprintf(palfile, "\n");
			fprintf(palfile, "0x%02X,", _blend25[(i<<8)|(j)]);
		}
	}
	fprintf(palfile, "\n};\n");

	fprintf(palfile, "\n// Blend 50%% to 50%% Palette:\n");
	fprintf(palfile, "bixlat _blend50 =\n{");
	for (i = 0; i < NUM_COLORS; i++)
	{
		for (j = 0; j < NUM_COLORS; j++)
		{
			if (0 == (j % 16))
				fprintf(palfile, "\n");
			fprintf(palfile, "0x%02X,", _blend50[(i<<8)|(j)]);
		}
	}
	fprintf(palfile, "\n};\n");

	fprintf(palfile, "\n// Blend 75%% to 25%% Palette:\n");
	fprintf(palfile, "bixlat _blend75 =\n{");
	for (i = 0; i < NUM_COLORS; i++)
	{
		for (j = 0; j < NUM_COLORS; j++)
		{
			if (0 == (j % 16))
				fprintf(palfile, "\n");
			fprintf(palfile, "0x%02X,", _blend75[(i<<8)|(j)]);
		}
	}
	fprintf(palfile, "\n};\n");

   fclose(palfile);
}
/************************************************************************/
/*
 * GetClosestPaletteIndex:  Return the palette index of the color in our 
 *   standard palette nearest to the given color.
 * Does not consider mapping to a reserved color.
 */
unsigned char GetClosestPaletteIndex(int red, int blue, int green)
{
   long rdist, bdist, gdist;
   long min_dist, distance;
   unsigned char min_index;
   int i;

   min_dist = 1L << 30;  /* Larger than distances to real colors */

   for (i=0; i < NUM_COLORS; i++)
   {
      if (_nevermap[i])
	 continue;

      rdist = colors[i].red - red;
      gdist = colors[i].blue - blue;
      bdist = colors[i].green - green;
      distance = rdist * rdist + bdist * bdist + gdist * gdist;
      if (distance < min_dist)
      {
	 min_dist = distance;
	 min_index = i;
      }
   }

   return min_index;
}
/************************************************************************/
/*
 * MakeLightPalettes: Precompute palettes for varying light levels.
 *   colors is used as the base palette.
 */
void MakeLightPalettes(void)
{
   int i, j;
   int red, green, blue;
   float factor;         /* Fraction of full brightness in a particular palette */

   for (i=0; i < LIGHT_LEVELS; i++)
   {
      /* Quadratic dependence so that there are more palettes close to full brightness */
#if 1
      factor = 1 - ((float) LIGHT_LEVELS - i) / LIGHT_LEVELS * 
	           ((float) LIGHT_LEVELS - i) / LIGHT_LEVELS;
#else
      factor = ((float) LIGHT_LEVELS - i) / LIGHT_LEVELS * 
	           ((float) LIGHT_LEVELS - i) / LIGHT_LEVELS;
#endif

      for (j=0; j < NUM_COLORS; j++)
      {
	 light_palettes[i][j] = j;

	 if (_nevermap[j])
	    continue;

	 red   = min((int) (colors[j].red   * factor), 255);
	 blue  = min((int) (colors[j].blue  * factor), 255);
	 green = min((int) (colors[j].green * factor), 255);

	 light_palettes[i][j] = GetClosestPaletteIndex(red, blue, green);
      }
   }

   // Make inverted effect palette
   for (j=0; j < NUM_COLORS; j++)
   {
      light_palettes[PALETTE_INVERT][j] = j;

      if (_nevermap[i])
	 continue;

      red   = 255 - colors[j].red;
      blue  = 255 - colors[j].blue;
      green = 255 - colors[j].green;
      
      light_palettes[PALETTE_INVERT][j] = GetClosestPaletteIndex(red, blue, green);
   }
}
/************************************************************************/
void MakeBlendBiXlat(unsigned char* pBiXlat, int partsFirst, int partsSecond)
{
	int i, j;

	if (!pBiXlat || partsFirst <= 0 || partsSecond <= 0)
		return;

	for (i = 0; i < NUM_COLORS; i++)
	{
		Color pe1 = colors[i];

		for (j = 0; j < NUM_COLORS; j++)
		{
			Color pe2 = colors[j];
			Color pe;

			pe.red = (pe1.red*partsFirst + pe2.red*partsSecond) /
					(partsFirst+partsSecond);

			pe.green = (pe1.green*partsFirst + pe2.green*partsSecond) /
					(partsFirst+partsSecond);

			pe.blue = (pe1.blue*partsFirst + pe2.blue*partsSecond) /
					(partsFirst+partsSecond);

			pBiXlat[(i<<8)|(j)] = GetClosestPaletteIndex(pe.red, pe.blue, pe.green);
		}
	}
}

