% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Lich is GenericLich

constants:

   include blakston.khd
   LICH_ILLUSION_TIME = 5 * 60 * 1000  % five minutes
   
resources:

   lich_pretty_name_rsc = "Queen Venya'cyr"
   lich_pretty_icon_rsc = licha.bgf
   lich_pretty_desc_rsc = \
      "A noble woman of stunning beauty, Queen Venya'cyr carries herself with a "
      "refined demeanor hardly still seen in this day and age.  You can't help "
      "but marvel at how she has managed to keep her beautiful face so young and "
      "vibrant through all of these centuries."
   lich_name_rsc = "Queen Venya'cyr"
   lich_icon_rsc = lichb.bgf
   lich_desc_rsc = \
      "Through some dark pact made ages ago, Queen Venya'cyr's ghastly corpse "
      "has been kept alive by dark magicks.  Sheer power emanates forcibly from her "
      "eyes, an intense gaze which strikes fear into your heart.  "
      "The centuries have apparently taken their toll on her physical form, "
      "however, as her skin is a mess of rotting flesh writhing with worms.  "
      
   lich_dispel = "The foul lich queen's ghastly appearance is revealed for all to see!"
   lich_respel = "The lich queen's ghastly appearance is once more cloaked in illusion."

   lich_dead_icon_rsc = lichbx.bgf
   lich_dead_name_rsc = "The ghost of Queen Venya'cyr"

   lich_killed_world_saved_0 = "~B"
   lich_killed_world_saved_1 = " has struck down the Dark Queen Venya'cyr, ridding Meridian of the evil Order "
      "of Necromancers!\n"
      "Thanks to "
   lich_comma = ", "
   lich_and = "and "
   lich_killed_world_saved_2 = "the good citizens of Meridian can walk the land in safety once again, knowing "
      "that "
   lich_killed_world_saved_3 = " have perished along with their undead queen."

   lich_killed_world_saved_nolich = " has struck down the last of the Order of Necromancers, "
      "ridding Meridian of their evil!\n"

   lich_spit = lightnin.bgf

   lich_tribute_trigger = "tribute"
   lich_hunger_trigger = "hunger"

   lich_starting_password = "deathmage"

   lich_hunger_5 = "~rMy hunger is a burning coal within my breast!  Feed me at once!"
   lich_hunger_4 = "~rI hunger very greatly!  The Order has been negligent in its duties to me.  Feed me at once!"
   lich_hunger_3 = "~rI am very hungry.  Feed me, my minion."
   lich_hunger_2 = "~rI am hungry.  I would like to feed soon."
   lich_hunger_1 = "~rI am only slightly hungry at present."
   lich_hunger_0 = "~rI am satisfied.  The Order serves me well."

   lich_not_powerful = "~kQueen Venya'cyr says, \"~rYour feeble mind is incapable of learning such powerful magics.\""
   lich_not_order = "~kQueen Venya'cyr says, \"~rOnly my servants are granted this mighty boon.\""

classvars:

   vrName = lich_pretty_name_rsc
   vrIcon = lich_pretty_icon_rsc
   vrDesc = lich_pretty_desc_rsc
   vrName2 = lich_name_rsc
   vrIcon2 = lich_icon_rsc
   vrDesc2 = lich_desc_rsc
   vrDead_icon = lich_dead_icon_rsc
   vrDead_name = lich_dead_name_rsc
   viDefinite = ARTICLE_NONE
   viIndefinite = ARTICLE_NONE
   viGender = GENDER_FEMALE

   viDefault_behavior = AI_FIGHT_AGGRESSIVE |  AI_FIGHT_WIZARD_KILLER | AI_FIGHT_HYPERAGGRESSIVE | AI_MOVE_FLEE_FRIGHTENERS | AI_FIGHT_THROUGH_WALLS | AI_FIGHT_SWITCHALOT
   viAttributes = MOB_LISTEN | MOB_RECEIVE | MOB_TEACHER

   vrTributeTrigger = lich_tribute_trigger
   vrHungerTrigger = lich_hunger_trigger

properties:

   poNecromancerGuild = $
   psTempRosterString = $
   
   pbIllusioned = TRUE
   ptGoIllusioned = $

   ptDeathSequence = $
   piDeathSequenceTimestep = 200  % milliseconds

messages:

   Constructed(oNecromancerGuild=$)
   {
      % Keep the scenario deactivated for now.
      %send(send(SYS,@GetNecromancerBalance),@ActivateScenario);
                                    
      if oNecromancerGuild <> $
      {
         poNecromancerGuild = oNecromancerGuild;
      }

      propagate;
   }

   SetForSale()
   {
      plFor_sale = $; % [ $, $, [ SID_SHADOW_RIFT ], $ ];

      return;
   }

   CanDoTeach(who=$,sid=0)
   {
      if NOT send(self,@CanAddSpell,#report=TRUE,#who=who,#num=sid)
      {
         return FALSE;
      }

      propagate;
   }

   CanAddSpell(who=$,num=0, report = FALSE)
   "We require that a quest be done before one of the spells can be learned"
   {
      if num = SID_SHADOW_RIFT
         AND NOT send(who,@IsUsingA,#class=&NecromancerAmulet)
      {
         if report
         {
            send(who,@msgsenduser,#message_rsc=lich_not_order);
         }

         return FALSE;
      }

      propagate;
   }

   GetIcon()
   {
      if pbIllusioned
      {
         return vrIcon;
      }

      return vrIcon2;
   }

   GetName()
   {
      if pbIllusioned
      {
         return vrName;
      }

      return vrName2;
   }

   GetApparentName()
   {
      if pbIllusioned
      {
         return vrName;
      }

      return vrName2;
   }
   
   ShowDesc()
   {
      if pbIllusioned
      {
         AddPacket(4,vrDesc);

         return;
      }

      AddPacket(4,vrDesc2);

      return;
   }

   DispelIllusionEnchantments()
   {
      if NOT pbIllusioned
      {
         return;
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=lich_dispel,#type=SAY_MESSAGE);

      pbIllusioned = FALSE;
      send(poOwner,@Somethingchanged,#what=self);
      if ptGoIllusioned <> $
      {
         deleteTimer(ptGoIllusioned);
         ptGoIllusioned = $;
      }

      ptGoIllusioned = CreateTimer(self,@ReplaceIllusions,LICH_ILLUSION_TIME);

      return;
   }

   ReplaceIllusions()
   {
      ptGoIllusioned = $;

      if pbIllusioned
      {
         return;
      }

      Post(poOwner,@SomeoneSaid,#what=self,#string=lich_respel,#type=SAY_MESSAGE);

      pbIllusioned = TRUE;
      send(poOwner,@Somethingchanged,#what=self);

      return;
   }

   Delete()
   {
      if poNecromancerGuild <> $
      {
         send(self,@ClearNecromancerGuild);
      }

      if ptGoIllusioned <> $
      {
         deleteTimer(ptGoIllusioned);
         ptGoIllusioned = $;
      }

      if ptDeathSequence <> $
      {
         deleteTimer(ptDeathSequence);
         ptDeathSequence = $;
         send(self,@DeathSequence2);
      }

      propagate;
   }

   Killed(what=$, resetScenario=FALSE, guildDisbandDeath=FALSE)
   {
      local lichActivated;

      lichActivated = FALSE;
      if (plAttackers <> $)
         AND (poNecromancerGuild <> $)
         AND (send(poNecromancerGuild,@GetMemberList) <> $)
      {
         lichActivated = TRUE;
      }

      % disband the guild
      if not guildDisbandDeath
      {
         send(self,@ClearNecromancerGuild);
      }

      send(send(SYS,@FindRoomByNum,#num=RID_LICH_MAZE),@RandomizeLeverEffects);
      send(send(SYS,@FindRoomByNum,#num=RID_G9),@RandomizeLeverEffects);

      if what <> $ AND IsClass(what,&Battler) AND NOT guildDisbandDeath
      {
         post(self,@BroadcastLichDeathMessage,#what=what,#Attackers=plAttackers,#lichActivated=lichActivated,#resetScenario=resetScenario);
      }

      if resetScenario and (ptDeathSequence = $) and not guildDisbandDeath
      {
         ptDeathSequence = createTimer(self,@DeathSequence2,piDeathSequenceTimestep);
      }

      propagate;
   }

   BroadcastLichDeathMessage(what=$, Attackers=$, resetScenario=TRUE, lichActivated=TRUE)
   {
      local i, sKilledMessage, sRoster;

      if lichActivated
      {
         % send a message to the world
         sRoster = send(self,@GetNecromancerRoster);
         ClearTempString();
         AppendTempString(lich_killed_world_saved_0);
         AppendTempString(send(what,@GetTrueName));
         AppendTempString(lich_killed_world_saved_1);
         for i in Attackers {
            if (length(Attackers) > 1) and (i = nth(Attackers,length(Attackers))) {
               AppendTempString(lich_and);
            }
            AppendTempString(send(i,@GetTrueName));
            if (length(Attackers) > 2)
            {
               AppendTempString(lich_comma);
            }
            else
            {
               AppendTempString(" ");
            }
         }

         AppendTempString(lich_killed_world_saved_2);
         AppendTempString(sRoster);
         AppendTempString(lich_killed_world_saved_3);
         sKilledMessage = createString();
         setString(sKilledMessage,GetTempString());
         send(SYS,@AdminSystemMessage,#string=sKilledMessage);
      }
      else
      {
         % send a message to the world
         ClearTempString();
         AppendTempString(lich_killed_world_saved_0);
         AppendTempString(send(what,@GetTrueName));
         AppendTempString(lich_killed_world_saved_nolich);
         sKilledMessage = createString();
         setString(sKilledMessage,GetTempString());
         send(SYS,@AdminSystemMessage,#string=sKilledMessage);
      }
      return;   
   }

   DeathSequence2()
   {
      ptDeathSequence = $;
      ptDeathSequence = createTimer(self,@DeathSequence3,piDeathSequenceTimestep);
      % tell all amulets and swords the bad/good news.
      send(&NecromancerAmulet,@LichKilled);

      return;
   }

   DeathSequence3()
   {
      ptDeathSequence = $;
      send(&HunterSword,@LichKilled,#oLich=self);

      return;
   }

%%%%%%%%%%%%%%%%
% Special code %
%%%%%%%%%%%%%%%%
%

   EstablishNecromancerGuild(master=$)
   {
      if master = $ { return; }
      if send(master,@GetGuild) <> $ { DEBUG("Tried to establish necroguild with master already guilded."); return; }
      if poNecromancerGuild <> $ { return; }
      poNecromancerGuild = create(&NecromancerGuild,#master=master);
      send(send(SYS,@FindRoomByNum,#num=RID_GUILDH15),
               @ClaimGuildHall,#oGuild=poNecromancerGuild,#rep=master,#password=lich_starting_password);
      send(send(SYS,@FindRoomByNum,#num=RID_LICH_MAZE),@RandomizeLeverEffects);
      send(send(SYS,@FindRoomByNum,#num=RID_G9),@RandomizeLeverEffects);
      return;
   }

   ClearNecromancerGuild()
   {
      if poNecromancerGuild <> $
      {
         send(poNecromancerGuild,@Delete);
         poNecromancerGuild = $;
      }

      return;
   }

   SomeoneSaid(what = $,type = $,string = $)
   {
      local oAmulet, iAmountDrained, iHunger, rHungerSpiel;
      if isClass(what,&User) and (send(what,@GetGuild) <> $) and (send(what,@GetGuild) = poNecromancerGuild) {
         if stringcontain(string,vrTributeTrigger) {
            % tell the amulet to pay up, find out how much we sucked out
            oAmulet = $;
            for oAmulet in send(what,@GetPlayerUsing) {
               if isClass(oAmulet,&NecromancerAmulet) {
                  break;
               }
            }
            if (oAmulet = $) or (not isClass(oAmulet, &NecromancerAmulet)) { propagate; }
            iAmountDrained = send(oAmulet,@LichTributeDrain);
            % tell the guild object how much was paid
            if iAmountDrained = 0 { propagate; }
            send(poNecromancerGuild,@PayRent,#amount=iAmountDrained*10000);
         }
         if stringcontain(string,vrHungerTrigger) {
            iHunger = send(poNecromancerGuild,@GetRentDue);
            rHungerSpiel = lich_hunger_0;
            if iHunger > 4 {
               rHungerSpiel = lich_hunger_5;
            }
            if iHunger = 4 {
               rHungerSpiel = lich_hunger_4;
            }
            if iHunger = 3 {
               rHungerSpiel = lich_hunger_3;
            }
            if iHunger = 2 {
               rHungerSpiel = lich_hunger_2;
            }
            if iHunger = 1 {
               rHungerSpiel = lich_hunger_1;
            }
            Send(what,@SomeoneSaid,#what=self,#type=SAY_RESOURCE,#string=rHungerSpiel);
         }
      }
      propagate;
   }

   GetNecromancerRoster()
   {
      local sRoster;
      clearTempString();
      send(&NecromancerAmulet,@NecromancerRosterRequest,#olich=self);
      if StringContain(GetTempString(),lich_comma)
      {
         appendTempString(lich_and);
      }
      appendTempString(psTempRosterString);
      psTempRosterString = $;
      sRoster = createString();
      setString(sRoster,GetTempString());
      return sRoster;
   }

   NecromancerRosterReply(necroName = $)
   {
      if psTempRosterString <> $ {
         appendTempString(psTempRosterString);
         appendTempString(lich_comma);
      }
      psTempRosterString = necroName;
      return;
   }

   IsAlly(target = $, regroup = FALSE)
   {
      if isClass(target,&User)
      { 
         if send(target,@IsUsingA,#class=&NecromancerAmulet) { return TRUE; }
      }
      if isClass(target,&DM)
      {
         return TRUE;
      }

      propagate;
   }

   SpecialHatredBehavior(what=$)
   {
      local i;
      %% She hates anyone with a hunter sword,
      %%    and goody-goodies too.
      %% But she REALLY hates backstabbers
      if isClass(what,&User) {
         if (send(what,@FindHoldingActive,#class=&HunterSword)<>$) {
            if (poOwner <> $)
            {  return 85;  }
         }
         if send(what,@GetKarma) > 30 {
            return send(what,@GetKarma);
         }
         if send(what,@IsUsingA,#class=&NecromancerAmulet) {
            for i in plAttackers {
               if i = what { return 100; }
            }
         }
      }
      return 0;
   }

   CreateDeadBody(killer=$)
   {
      local oBody, iQNTindex, oQE;
      oBody = create(&DeadLich, #Attackers=plAttackers);
      oQE = send(SYS,@GetQuestEngine);
      send( oQE, @SetQuestScheduleChance, #index = QST_ID_ESTABLISH_NECROGUILD, #new_pct = 100 );
      iQNTindex = first(nth(send( oQE, @GetQuestTemplate, #index = QST_ID_ESTABLISH_NECROGUILD ),QT_QUEST_NODES));
      send( oQE, @SetQuestNodeNPCList, #index = iQNTindex, #new_NPC_list = [oBody] );
            
      return oBody;
   }

   DMCanArmageddon()
   {
      return FALSE;
   }

   NewOwner(what=$)
   {
      % This should never happen, but if it does...
      if (what <> $) and not isClass(what,&GuildHall15)
      {
         DEBUG("Bad Lich!  Go to your room!");
         post(self,@GoBackToGuildhall);
      }
      
      propagate;
   }

   LastUserLeft(what = $)
   {
      send(self,@GoBackToGuildhall);
      propagate;
   }

   GoBackToGuildhall()
   {
      local oGuildh15;
      oGuildh15 = send(SYS,@FindRoomByNum,#num=RID_GUILDH15);
      send(oGuildh15,@NewHold,#what=self,
            #new_row=13,#new_col=49,#fine_row=16,#fine_col=00,#new_angle=ANGLE_WEST);
      if (send(oGuildh15,@CountHoldingHowMany,#class=&Lich) > 1)
      {
         DEBUG("More than one lich in the guild hall!!");
      }
      if (send(oGuildh15,@CountHoldingHowMany,#class=&DeadLich) > 0) and (send(oGuildh15,@CountHoldingHowMany,#class=&Lich) > 0)
      {
         DEBUG("Both a lich and a dead lich in the guild hall!!");
      }
      return;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%