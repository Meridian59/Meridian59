% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Player is Battler
   
% Don't instantiate this class--use things derived from it

constants:

   include blakston.khd
   include protocol.khd

   % Three minutes
   BOND_REPORT_INTERVAL = 1000 * 60 * 3
   
   % One minute
   DEATH_RIFT_INTERVAL = 1000 * 60

   KARMA_TUNE_A_INVERSE = 20
   KARMA_TUNE_B_INVERSE = 5

   %%% COMBAT PACING PARAMETERS
   % These parameters control how often it is possible to have combat
   % assuming readily available opponents.   Xian 4/3/96
   %
   % Parameter: Base Regeneration Time (sec)
   % Meaning:   Time needed for a nearly-killed player of stamina 25 
   %             to rest fully or player of intelligence 25 to recover mana
   % Formula:   BASE_REGEN_TIME / 1000
   % Currently: 150 sec = 2.5 min
   % Note:      The fastest time scale
   %
   % Parameter: Vigor Recovery Time (sec)
   % Meaning:   Time needed to fully rest after complete vigor depletion
   % Formula:   REST_THRESHOLD * REST_TIME / 1000
   % Currently: 200 sec = 3.3 min
   % Note:      Should be slower than health and mana refresh
   % 
   % Parameter: Food Digestion Time (sec)
   % Meaning:   Time needed to completely empty a full stomach
   % Formula:   10000 / FOOD_USE_RATE
   % Currently: 833 sec = 13.9 min
   % Note:      Need empty stomach to get vigor boost from food
   BASE_REGEN_TIME = 150000

   % Rate at which stomach empties.
   FOOD_USE_RATE = 12

   % Smallest worthwhile change to vigor (X 10e-4)
   MIN_VIGOR_CHANGE = 20000

   % Effective vigor debit per attack (X 10e-4)
   ATTACK_EXERTION = 5000

   % Number of ms required to gain one vigor point
   REST_TIME = 2500          

   % Number of ms to lose one boosted health or mana point.
   BOOST_DECAY_TIME = 30000 

   % Currently: 10 improves every 15-22 minutes.
   ADVANCE_TIMER_MIN =   900000
   ADVANCE_TIMER_MAX =   1320000
   ADVANCEMENT_LIMIT =   10

   PKPOINTER_TIME = 10*60*1000

   PLAYER_TRANSLATION_LEGS_MASK = 0xff
   PLAYER_TRANSLATION_LEGS_MUL = 1
   PLAYER_TRANSLATION_BODY_MASK = 0xff00
   PLAYER_TRANSLATION_BODY_MUL = 0x100
   PLAYER_TRANSLATION_Skin_MASK = 0xff0000
   PLAYER_TRANSLATION_Skin_MUL = 0x10000

   PLAYER_TRANSLATION2_HAIR_MASK = 0xff
   PLAYER_TRANSLATION2_HAIR_MUL = 1
   PLAYER_TRANSLATION2_ARMS_MASK = 0xff00
   PLAYER_TRANSLATION2_ARMS_MUL = 0x100

   BASE_NEED = 105

   % If vigor gets this low, see if second wind skill kicks in.
   SECONDWIND_THRESHOLD = 25
   
   % How steep is the curve for learning new levels of spells?
   %  A higher number means a greater slope (less points at low levels)
   POINTS_SLOPE = 7                 

   % Sets a reasonable lower level on the number of percents needed to
   %  advance to the next level of spells/skills.
   MIN_NEEDED_TO_ADVANCE = 75       
                                    
   % How many weapon swings until we get an improve check?
   SWINGS_PER_IMPROVE_CHECK = 75    

   % What's the length after having a player attacked before we let "mules" 
   %  cast on them again.  Currently set to 15 minutes.  Should be bigger 
   %  than logoff ghost time (currently 10 mins)
   ATTACKED_PLAYER_WAIT = 15 * 60

   % Damage is capped at piBase_Max_Health divided by this number.  Reduces
   %  newbie slaughter.
   MAX_HEALTH_DAMAGE_FRACTION = 3

   % Damage is overall capped to this number.  Gives a slight edge to people
   %  with higher hps.
   MAX_DAMAGE_PER_HIT = 30

   % What's the maximum stat we can have after modification?
   MAXIMUM_STAT = 70

   % how long to wait before sending another pvp notify sound (seconds)
   PVP_NOTIFY_DECAY = 5 * 60
   
resources:

   include player.lkod

   player_cant_broadcast = \
      "You can't broadcast a message--you don't have enough mana."
   player_squelched = "You are prevented from communicating for now."
   player_cant_send = \
      "You can't send this message--you don't have enough mana."
   player_silent_room = "Your telepathic abilities will not work here."

   player_use_broken = "You can't use %s%s--it's broken."
   player_cant_use = "You can't use that."
   player_using_already = "You are already using that."
   player_use_full = "You are using too many things like that already."
   player_use_full_hands = "Your hands are too full to use that."
   player_not_using = "You are not using that."
   player_not_holding = "You are not even holding %s%s."
   player_regbag_empty = "The reagent bag is empty."
   
   player_hit_color_red = "~r"
   player_hit_color_blue = "~b"
   player_hit_color_none = ""

   player_token_reward = \
      "Let me give you %s%s as payment for returning the token."
   player_token_reward_heavy = \
      "Feel free to take the %s%s by your feet as payment for returning the "
      "token."
   player_improve_maxhealth = "~I~BYou suddenly feel a little tougher."
   player_improve_health_invigorate = \
      "~I~BYou feel invigorated by your success."
   player_spits = "You spit on the corpse of your unworthy foe."
   player_regain_angel = \
      "Due to your weakness, your protective guardian angel returns."
   player_no_angel = "You suddenly feel more vulnerable."

   player_join_faction = \
      "~IYour name is entered on the roll of membership for %s%s's political "
      "faction."
   player_lost_token_hall = \
      "The token refuses to enter the guild hall and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_arena = \
      "The token refuses to enter the arena and writhes in your hands.  "
      "You cannot hold it."
   player_lost_token_survival = \
      "You suddenly lose your grasp on the token as you are pulled "
      "across dimensions."
   player_lost_token_generic = \
      "The token refuses to enter this room and writhes in your hands.  "
      "You cannot hold it."
   player_intrigue_shut = "~IThe Royal Court no longer needs your services."
   player_lost_intriguing = \
      "~IYou doubt you are still worthy of notice by the Royal Court."
   player_faction_time = \
      "~IYour liege is no longer convinced of your loyalty. You should visit "
      "your liege at court again."
   player_faction_attacked = \
      "~BYou have attacked a member of your own faction!"
   player_non_intriguing_attacked = \
      "~BYou have displeased your liege by attacking a potential future ally!"
   player_unfactioned = \
      "~IYour liege has no use for one such as you, lacking in prowess or "
      "devotion.  Your name has been stricken from the roll of membership.~n"

   player_cancel_rescue = \
      "~IYour aggression halts your attempt to escape from the "
      "current situation."

   player_cancel_rescue_phase = \
      "~IThe protective magics that might have rescued you instead "
      "snap and fade as you phase out of existence."
   player_cancel_rescue_newowner = \
      "~IYour change of location disrupts Shal'ille's attempt to whisk "
      "you to safety."

   player_temp_safe = \
      "~I~BYou feel your guardian angel is near to you."
   player_temp_safe_end = \
      "~I~BYou feel your guardian angel has departed once more."

   player_improved = "~I~BYou have improved in the art of %s."
   player_improved_wav_rsc = imp.wav
   player_aggressor = "Shal'ille frowns upon your unprovoked attack."
   player_aggressor_minion = \
      "Shal'ille frowns upon your unprovoked attack on %s%s's minion."
   player_safety_caught = \
      "Hey!  You almost hit %s%s!  Good thing your safety was on!"
   player_safety_caught_minion = \
      "Hey!  You almost hit %s%s's minion! Good thing your safety was on!"
   player_own_minion = \
      "You cannot attack your own minion!"

   player_safe_server = \
      "You are not allowed to attack other players in this world."
   player_no_enter = \
      "Your guardian angel holds you back and prevents you from entering here."
   player_assgame_soon = \
      "~kRoq tells you, \"~IA new Assassin's Circle shall be initiated "
      "shortly.\""

   player_tougher_wav_rsc = tougher.wav
   player_missed_something_wave_rsc = swordmis.wav
   player_killed_something = "You killed %s%s."
   player_killed_player = \
      "You have killed another player and have been branded a murderer."
   player_wanted_now = "You are now wanted for the murder of %s%s."
   player_haunted_on = "%s%s's violent death summons forth a revenant."
   player_haunted_off = "The revenant is satisfied."
   
   player_training_inform = "You now have ~B%i~B training points!"
   player_reached_maxtraining = \
      "You now have ~B%i~B training points and can not gain any more!  "
      "Cast the Meditate spell and say the name of a spell or skill out loud "
      "to use your points to train it."
   player_gained_training = "You have gained ~B%i~B training points!"
   player_spent_training = "You have spent ~B%i~B training points!"
   player_logon_bonus = \
      "You have received your daily training bonus of ~B%i~B points!  "
      "Come back tomorrow for more!"
   player_experience_gained = "You have gained ~B%i~B experience points!"
   player_experience_lost = "You have lost ~B~r%i~B experience points!"

   player_health_gain_maxed = "Your health cannot increase any further."

   player_cant_hit_newbie = \
      "You are not yet experienced enough to fight other players."
   player_cant_hit_newbie_minion = \
      "This creature is the servant of another player - you are not yet "
      "experienced enough to fight it."
   player_guardian_angel = \
      "A guardian angel whispers to you, \"You may not attack %s%s.\""
   player_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot protect you here.\""
   player_angel_rejoins = "Your guardian angel rejoins you."
   player_lose_node = "You lose your connection to the mana node in %s."

   player_hit_immunity =  "%s%s%s laughs off your pitiful blow."
   player_hit_resisted = "%s%s%s shrugs off your attack."
   player_hit_anti_resisted = "%s%s%s staggers backwards from the blow."
   player_hit_anti_immunity = \
      "%s%s%s convulses and seems to be suffering badly."
   
   player_immune_to_hit = "%sMysteriously, you feel almost no pain!"
   player_resists_hit = "%sMuch of the pain fades away."
   player_anti_resists_hit = \
      "%sThe pain seems to resonate and grow inside you."
   player_anti_immune_to_hit = \
      "%sYour body is wracked with pain of incredible magnitude."
   
   player_was_missed = "%s%s%s misses you."
   player_was_hit = "%s%s%s hits you."
   player_was_slashed = "%s%s%s slashes your side, leaving a nasty cut."
   player_was_bludgeoned = "%s%s%s bludgeons you, causing a large bruise."
   player_was_pierced = "%s%s%s slyly pierces you while you were distracted."
   player_was_thrusted = "%s%s%s skewers you with a deft thrust.  Sluish!"
   player_was_burned = "%s%s%s's fire flares brightly, leaving you charred."
   player_was_shocked = "%s%s%s grins as a jolt of electricity hits you."
   player_was_frozen = "%s%s%s stings you with a jolt of cold."
   player_was_quaked = "%s%s%s's tremors shake you about."
   player_was_holyhit = "%s%s%s hits you with a jolt of purity."
   player_was_unholyhit = \
      "%s%s%s hits you, and you feel your soul has been invaded."
   player_was_stung = "%s%s%s dances away after having stung you badly."
   player_was_bitten = "%s%s%s bites you several times, leaving you bloody."
   player_was_clawed = "%s%s%s rends your flesh with razor sharp claws."
   player_was_punched = "%s%s%s hits you with a solid punch."
   player_was_kicked = "%s%s%s slams a foot into your gut."
   
   player_out_of_room = "%s%s is not here."
   player_not_supported = "Not supported yet"
   
   player_attack_out_of_range = "%s%s is too far away to hit with %s%s."
   player_attack_out_of_punch_range = "You can't reach %s%s with your %s."
   player_attack_out_of_spell_range = "%s%s is out of range."
   player_attack_not_in_view = "You can't see your selected target."

   player_no_target_self = "You cannot attack yourself."
   player_no_target_self_spell = "You cannot cast this spell on yourself."

   player_cant_apply = "You can't use %s%s on other things."
   
   player_wave_hit = hit.wav
   
   player_level_music = perc2.mp3
   
   % These are now old resources..... here in case we want to de-hack...
   player_desc_guild = "%q of %s%q."
   player_no_guild = "No known guild affiliation."
   player_faction_duke = "A staunch servant of Duke Akardius.\n"
   player_faction_princess = "Firmly loyal to Princess Kateriina.\n"
   player_faction_rebel = "A freedom fighter supporting Jonas.\n"
   player_faction_neutral = \
      "Not a court vassal, yet affected by the Meridian Council."
   player_not_intriguing = "Not yet concerned with affairs at the Royal Court."

   player_nl = "\n"
   player_sp = " "
   player_dot = "."

   % Master fixed info resource.
   player_fixed_info = "%r%r%s%r%s%q%r"

   % Hometown strings.
   player_hometown_rsc = "%s%s%s%q%s\n"
   player_citizen_barloque = " has been a Barloquan"
   player_citizen_tos = " has been a citizen of Tos"
   player_citizen_cornoth = " hailed from Cor Noth"
   player_citizen_jasper = " has called Jasper home"
   player_citizen_marion = " has been a Marionite"
   player_citizen_raza = " is of Raza"
   player_citizen_hazar = " is of Hazar"
   player_citizen_kocatan = " has lived in Ko'catan"
   player_citizen_unknown = " has wandered"
   player_of = " of "
   player_for = " for "
   player_years = " years."
   player_year = " year."
   player_under_one_year = " less than a year."

   player_guild_rsc = "%q%s%s%q.\n"
   player_is_holding = "%s is holding %s%s.\n"
   player_is_wearing = "%s is wearing %s%s.\n"
   player_donation_title = "Noble benefactor of Meridian in %q."
   player_donation_separator = ", "
   player_is_justicar = "Elected Royal Justicar of the Meridian."

   player_known_for_mastery = "Known far and wide for mastery of "
   player_and = " and "
   player_magics = " magics"
   player_skills = "weaponcraft skills"

   % Here's the new extended resources....
   player_desc_guild_faction_neutral = \
      "%q of %s%q.  Not associated with any faction, yet concerned with the "
      "intrigue of the Royal Court."
   player_desc_guild_faction_duke = \
      "%q of %s%q.  A devoted servant of Duke Akardius."
   player_desc_guild_faction_princess = \
      "%q of %s%q.  Firmly loyal to Princess Kateriina."
   player_desc_guild_not_intriguing = \
      "%q of %s%q.  Not yet concerned with affairs at the Royal Court."

   player_no_guild_faction_neutral = \
      "No known guild affiliation. Not associated with any faction, yet "
      "concerned with the intrigue of the Royal Court."
   player_no_guild_faction_duke = \
      "No known guild affiliation. A devoted servant of Duke Akardius."
   player_no_guild_faction_princess = \
      "No known guild affiliation. Firmly loyal to Princess Kateriina."
   player_no_guild_not_intriguing = \
      "No known guild affiliation. Not yet concerned with affairs at the "
      "Royal Court."

   player_dagger_shatters = "Your black dagger crumbles into dust."

   player_desc_enchanted_none = "%q"
   player_desc_enchanted = "%s has %s%s.\n\n%s"
   
   player_too_full = "You are too full to eat."
   player_too_full_drink = "You are too full to drink."

   player_to_hunters = "You detect that %s%s could be found somewhere around %s"

   player_dead_male_icona_rsc = playerXa.bgf
   player_dead_male_iconb_rsc = playerXb.bgf
   player_dead_female_icona_rsc = heraXa.bgf
   player_dead_female_iconb_rsc = heraXb.bgf
   
   player_dead_male_name_rsc = "dead male body"
   player_dead_female_name_rsc = "dead female body"
   
   playerm_death_wav = pdeath.wav
   playerf_death_wav = pdeathf.wav

   player_token_death = \
      "As you die, the token pulsates, and you feel an odd sensation..."

   player_dance = \
      "You swallow your pride and get down to the ditty in your head."
   player_cant_dance = \
      "You can't dance, all the stuff in your hands is cramping your style!"
   player_cant_dance_resting = \
      "You're sitting right now.  Let's not take this \'getting down\' stuff "
      "too literally, ok?"
   player_stop_dance = \
      "You lose your rhythm and settle out of your dancing frenzy." 

   player_wave = "You wave your hand."
   player_point = "You point."
   
   player_sword_overlay_icon_rsc = swordov.bgf
   player_mace_overlay_icon_rsc = maceov.bgf
   player_scimitar_overlay_icon_rsc = scimov.bgf
   player_short_sword_overlay_icon_rsc = shswdov.bgf
   player_hammer_overlay_icon_rsc = hamrov.bgf
   player_axe_overlay_icon_rsc = axeov.bgf
   
   player_window_overlay_hand = povhand.bgf
   player_window_overlay_glow = povglow.bgf

   player_male_icon_rsc = bta.bgf
   player_female_icon_rsc = btb.bgf  
   
   player_legs_a_rsc = bfa.bgf
   player_legs_b_rsc = bfb.bgf
   player_legs_c_rsc = bfc.bgf
   player_legs_d_rsc = bfd.bgf
  
   player_rightarm_a_rsc = bra.bgf
   player_rightarm_b_rsc = brb.bgf
   
   player_leftarm_a_rsc = bla.bgf
   player_leftarm_b_rsc = blb.bgf
   
   % hair for Rob
   player_toupee_q_rsc = ptq.bgf

   player_sound_learn_spell = splearn.wav

   player_angel = "Your guardian angel"
   intrigue_ambassador = "Baron Springer of Cor Noth Township"

   player_newbie_honor_string = "This soul is new to the lands of Meridian 59."

   player_newbie_commands = \
      "\n~BBasic Commands for Meridian 59:~B\n"
      "~IUse these mouse and keyboard commands to interact with the world.\n"
      "These are the default commands.  You can change the keyboard commands "
      "by going to the menu item~I ~wGame > Configuration.\n"
      "~rright-click on an object ~b- examines an object, letting you see "
      "more detail.  Right-click on the sign in this area to learn more.\n"
      "~rspace bar ~b- go through doors, like the blue door to the north.\n"
      "~rE key ~b- attack monsters.  You may want to wield a weapon first!\n"
      "~n~IType the following commands (red text) into the text bar below. "
      "You can press the RETURN key to move to the chat window.~I\n"
      "~rsay (message) ~b- send a message to everyone in the same room.\n"
      "~rtell (player name) (message) ~b- Send a message to a single player "
      "in private.\n"
      "~rbroadcast (message) ~b- send a message to everyone that is logged "
      "on.\n"
      "~rwho ~b- shows a list of all the people logged into the game right "
      "now.\n"
      "~rmail ~b- opens up your mail folder.  Read the messages from your "
      "guardian angel!\n"
      "~rhelp ~b- opens our web-based help pages.  It will take a few "
      "seconds to load.\n"

   player_safety_on_mail = \
      "Your safety is currently on, meaning you cannot cast hostile spells or "
      "attack innocent players."
   player_safety_off_mail = \
      "Your safety is currently off.  If you do not wish to attack innocent "
      "players, I heartily recommend that you turn it on."

   player_ready_to_kill = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword against other "
      "players if you so desire.  It is with a heavy heart that I take my "
      "leave of you, but I trust that you will do fine without me."
      "\n\n"
      "You also have many other rights and responsibilities available to "
      "you.  You can now join a guild with other friends.  Guilds are a good "
      "way to gain protection from those that would do you harm.  Joining a "
      "good guild will make the difference between merely surviving or "
      "thriving in the world.  Guilds can also get into wars with other "
      "guilds, so be careful that you don't make too many enemies."
      "\n\n"
      "I must warn you that engaging in lethal combat against other players "
      "may soil your good name.  If you strike an innocent, or cast "
      "a spell which harms him, you may be branded an outlaw, an onus which "
      "only fades upon your death.  If you slay an innocent in cold blood, "
      "you will be blacklisted as a murderer, and this is a weight upon your "
      "soul which does not easily depart.  This puts you at risk:  since "
      "murderers and outlaws are not innocents, one may attack them without "
      "being named a murderer or an outlaw."
      "\n\n"
      "Also note that assisting an outlaw or murder by casting helpful spells "
      "upon them will brand you an outlaw in the eyes of society.  You must "
      "choose your friends and your enemies well!"
      "\n\n"
      "If you do not wish to engage in the unsavory practice of attacking "
      "innocents or assisting the unlawful, it is heartily recommended that "
      "you do not enable attacking innocents in your game preferences.  This "
      "is also called your \"safety\" since it keeps you safe from being "
      "outcast as an unlawful outlaw or murderer.  While your safety is on, "
      "you are not permitted to either attack innocents or cast spells that "
      "are hostile to them.  This can be crucial when one stray sword blow "
      "can make you an outlaw.  However, rest assured that you will always be "
      "permitted to strike outlaws and murderers, since it is crucial that "
      "you always have the option of defending yourself from their "
      "treacherous ways."
      "\n\n"
      "%s"
      "\n\n"
      "Finally, some last bits of advice as I depart.  Do not despair if "
      "you are sent to the underworld by some monster or even another "
      "player.  Death is part of the cycle, and learning to recover from "
      "death is important.  Put some items away in the vault in Barloque for "
      "times when you find yourself killed and unable to get items from your "
      "corpse.  Also, ask politely for assistance and you will often find "
      "someone willing to lend a helping hand.  Make some friends and you "
      "will find that nothing is truly beyond your reach."
      "\n\n"
      "Have fun in Meridian!"
      "\n\n"
      "  -- Your guardian angel"

   player_ready_to_guild = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword with fellow "
      "players and engage in guild politics.  It is with a heavy heart that I "
      "take my leave of you, but I trust that you will do fine without me.\n\n"
      "%s\n\n"
      "  -- Your guardian angel"

   player_tutorial_mail = "Subject: You're doing well for yourself.\n"
      "It's nice to see that you seem to be doing well.  "
      "I thought I might take this time to explain some finer points of "
      "the world of Meridian to you."
      "\n\n"
      "There are a variety of spells and skill schools that you can "
      "advance in.  However, learning from all spell and skill schools "
      "dilutes your focus, and slows down your learning.  The more you "
      "narrow your focus onto one or two particular spell schools, the "
      "quicker you will advance in that spell school, and the sooner you "
      "will be offered new spells in that school.  Stray from the path, "
      "however, and you will find that teachers may not offer you spells that "
      "they had previously offered you.  Thus, you must choose very early on "
      "whether or not you prefer the versatility of being able to pull from a "
      "multitude of low level spells and skills, or the power of excelling in "
      "one or two.  Therefore, be sure that you examine any potential ability "
      "before you acquire it!"
      "\n\n"
      "No advancement is more prized than increasing your endurance by "
      "gaining health points.  Note you that those who go toe to toe with "
      "monsters are more likely to advance in health than those who stay "
      "safely out of harm's way, slinging fireballs.  Also, attacking "
      "insignificant foes earns you no points for valor, and offers no hope "
      "of advancement."
      "\n\n"
      "Your vigor is crucial - it helps determine how fast your health and "
      "mana returns to you - a tired warrior will find these resources "
      "fleeting.  Vigor can be restored either through needed rest or a "
      "hearty meal."
      "\n\n"
      "I congratulate you on your recent success.  I know the bards will sing "
      "of your future exploits."
      "\n\n"
      "  -- Your guardian angel"

   player_first_mail = "Subject: Welcome!\n"
      "Welcome to Meridian 59!  I hope you enjoy the exciting world waiting "
      "for you!"
      "\n\n"
      "You have entered an on-line community, meaning that you may well be "
      "playing with several other players at a time.  Making allies and "
      "dealing with potential enemy players is as much a part of Meridian 59 "
      "as killing monsters.  We hope you feel at home in your new online "
      "community."
      "\n\n"
      "I am your guardian angel, and thus I shall protect you from the spells "
      "and swords of other players for a short time.  Use this time to "
      "acquaint yourself with the world, and to gather your resources.  Know "
      "you that the shops of the land are always safe zones, and the inns are "
      "good places to rest and recover your strength."
      "\n\n"
      "Spells and skills will almost certainly be crucial to your success.  "
      "Note that a young warrior's skills are stronger than a inexperienced "
      "wizard's spells, but at the higher end, the sorcerer is far more "
      "formidable to deal with given his variety of options.  The apprentice "
      "will almost always need the steady sword of the mercenary by his side "
      "to get that far, so find comrades who complement your abilities."
      "\n\n"
      "You can learn a lot by talking to the little people: the shopkeepers, "
      "the bankers, the innkeepers.  Ask them for help.  Sometimes, they "
      "may even wish for you to run an errand for them if you ask."
      "\n\n"
      "For your first quest, you may wish to research which hometown you were "
      "born in.  You can ask any of the towns' people you meet for their "
      "opinions about the different towns.  To permanently select a hometown, "
      "you need to adventure to the Hall of Genealogy in the town of Cor Noth "
      "and look through the books there.  Take your time selecting your "
      "hometown, as it may determine how other people interact with you."
      "\n\n"
      "Death is unkind to you - avoid it!  A death can make you weaker, and "
      "all of your possessions are left where you met your demise, where any "
      "scavenger, human or otherwise, may take it as they please.  Best that "
      "you join an ally on your travels that they may gather your valuables "
      "should you meet such an unfortunate fate."
      "\n\n"
      "Lastly, if you wish to leave this land for a bit, it is recommended to "
      "log off in a safe place, such as an Inn or Adventurer's Hall.  For "
      "brief exits from the game, you can use the spell Phase to disconnect "
      "you from this plane of existence, rendering you unable to be harmed.  "
      "However if you Phase or log off without your guardian angel for longer "
      "than 8 minutes for innocents (3 minutes for murderers), you will take "
      "a penalty (dropping item(s) and losing skill and spell points) and be "
      "sent back to the last safe location you visited."
      "\n\n"
      "We hope that you enjoy your stay in our land."
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail = "Subject: Death\n"
      "It saddens me that you fell in combat and into the underworld.  It is "
      "a dangerous life as an adventurer, as you have undoubtedly learned."
      "\n\n"
      "Since you are so young, I have pleaded to the gods that you should be "
      "spared some of the penalty for death.  Normally, the shock of leaving "
      "the underworld would reduce your maximum health and penalize you a "
      "small part of the spells and skills you have learned so far.  I will "
      "spare you the cost of your health, and only a few of your spells and "
      "skill will be reduced after you leave the underworld."
      "\n\n"
      "You will also notice that your possessions are gone.  They were left "
      "behind at your corpse where you died.  The items will only remain "
      "there a limited amount of time, so you must act quickly."
      "\n\n"
      "If you don't know where you died, then you should broadcast for help.  "
      "Type \"broadcast Can someone help me find my items?\" right now and "
      "watch for someone to respond to you.  Tell that person what you can "
      "remember about where you were fighting.  Often you will find someone "
      "kind to help you, or they might even help you get better equipment "
      "than you had before.  There are many kind souls in this land"
      "\n\n"
      "If you know where you died, the portal archways in the underworld will "
      "take you directly to the inns of the cities of the mainland.  The "
      "large rip in space in the western side of the underworld is often the "
      "quickest way back.  It randomly switches between the different inns.  "
      "Look (right-click by default) the portal to see where it leads.  If it "
      "leads to the place you want to go, enter it quickly!  It will not lead "
      "there for very long."
      "\n\n"
      "Do not be discouraged!  Many powerful warriors have stumbled into the "
      "fires of the underworld.  What makes them powerful is that they "
      "decided to fight on, gaining power and ability to vanquish the "
      "terrible monsters that felled them before!"
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail_notice = \
      "Your guardian angel has sent you a special game mail on how to cope "
      "with death.  Type ~Imail~I and read the last game mail from your "
      "guardian angel."

   player_intrigue_mail = "Subject: Invitation to visit the Royal Court\n"
      "Oh, most worthy adventurer.  Tales of your exploits have been oft told "
      "here at the Court, and recently, the Meridian Council itself declared "
      "you to possess considerable promise. Perhaps someday you will be "
      "given the honor of studying and guarding one of the Five Tokens."
      "\n\n"
      "The Council serves our fair land by using their acquired knowledge to "
      "benefit daily life. For the most part, they are honest and impartial "
      "in their decisions - guided by the Priestess of Shal'ille. However, "
      "Duke Akardius and Princess Kateriina and their factions of followers "
      "try to sway the Council down differing paths:"
      "\n\n"
      "Duke Akardius wishes for more of the Council's energies to be used for "
      "the benefit of commerce and the study of lore, while the Princess "
      "seeks their aid in advancing knowledge of magic. Both believe their "
      "path is the way to reduce the plague of monsters which terrify the "
      "land these days."
      "\n\n"
      "There are also boorish tales of a third faction of rebels.  They "
      "are dissatisfied with the current political climate and seek to "
      "bring their leader to rule our lands.  I do not know much about "
      "these rebels, nor do I care to learn anything.  You are on your own "
      "if you wish to learn about them."
      "\n\n"
      "Should you desire to join any of these factions, seek the Liege. "
      "As a faction member, you can help to influence the Council yourself, "
      "and share in the benefits of belonging to the party in power. You will "
      "need to demonstrate fealty to your Liege on a regular basis to "
      "keep your name on the rolls. Even if you join neither faction, you "
      "will still be influenced by the Council's decisions - as are all."
      "\n\n"
      "Fair partings, and perhaps we will someday meet at the court."
      "\n\n"
      "----Baron of Cor Noth Township, Gerah Springer."

   player_Debug_playercanlearn = \
      "Do the math for %s to learn a %i level spell from the %s school.  "
      "%i points from spells already known (%i from this school).  Intellect "
      "reduces the needed by %i for a total of %i percent needed.  Currently "
      "possesses %i percent to compensate for the need."

   player_Debug_playercanlearn_scarcity = \
      "Due to the scarcity of spells at that level in that school, "
      "the need has been reduced to %i more points."
   
   player_Debug_nokarma = "%s cannot learn %s due to karma restrictions."
   player_Debug_noway = "It is impossible for %s to ever get the %s spell."

   player_sound_sword1 = sword1.wav
   player_sound_sword2 = sword2.wav
   player_sound_sword3 = sword3.wav

   player_sound_metal1 = swrdmtl1.wav
   player_sound_metal2 = swrdmtl2.wav
   player_sound_metal3 = swrdmtl3.wav

   player_sound_hit_monster_flesh1 = fhit1b.wav
   player_sound_hit_monster_flesh2 = fhit2b.wav
   player_sound_hit_monster_flesh3 = fhit3b.wav

   player_sound_hit_monster_leather1 = lhit1b.wav
   player_sound_hit_monster_leather2 = lhit2b.wav
   player_sound_hit_monster_leather3 = lhit3b.wav

   player_sound_hit_monster_metal1 = mhit1b.wav
   player_sound_hit_monster_metal2 = mhit2b.wav
   player_sound_hit_monster_metal3 = mhit3b.wav

   % in increasing order of agony
   player_sound_male_ouch1 = ouchm1.wav
   player_sound_male_ouch2 = ouchm2.wav
   player_sound_male_ouch3 = ouchm3.wav
   player_sound_male_ouch4 = ouchm4.wav

   player_sound_female_ouch1 = ouchf1.wav
   player_sound_female_ouch2 = ouchf2.wav
   player_sound_female_ouch3 = ouchf3.wav
   player_sound_female_ouch4 = ouchf4.wav

   player_eavesdrop_login_str = "~B~g[~n%s has logged in.~B~g]"
   player_eavesdrop_str = "~B~g[~n%s tells %s, \"%q~n\"~B~g]"
   player_eavesdrop_logout_str = "~B~g[~n%s has disconnected.~B~g]"

   player_admin_added_spell = "Spell added."
   player_admin_modified_spell = "Spell modified."
   player_admin_removed_spell = "Spell removed."
   player_admin_added_skill = "Skill added."
   player_admin_modified_skill = "Skill modified."
   player_admin_removed_skill = "Skill removed."

   player_logged_on_wav_rsc = player_login_or_out.wav
   player_logged_off_wav_rsc = player_logout2.wav

   death_rift_stayed_too_long = \
      "Having lingered too long while still alive, you find "
      "yourself ejected back into reality!"
   second_wind_finished = \
      "You feel more relaxed as your second wind dissipates."

   player_monster_attack_string = "monster attack"
   player_no_weapon_string = "no weapon"

   cannot_attack_ally = "You can't attack %s, %s's your ally!"
   cannot_attack_guildmate = "You can't attack %s, %s's your guildmate!"

   group_experience_rsc = \
      "You absorb a small amount of the energy released "
      "from %s's slaying of the %s."

   rod_gained_charge_msg = \
      "You sense that at least one of your magic items gained a "
      "charge from the released energy of your kill."
   rods_fully_recharged_by_safe_place_msg = \
      "This place of safety has recharged your magical rods."

   player_truced = "Shal'ille's magic compels you to respect the truce."

   Jig_cannot_attack = \
      "It wouldn't feel right to attack the %s while you two are "
      "dancing so well together!"

   phased_out_cant_use = \
      "You try to use your item, but your phased hands pass right through it."
   cannot_attack_phased_self_rsc = \
      "You can't attack anyone while phased out."
   cannot_attack_phased_player_rsc = \
      "Your strike would just go right through someone who is phased out."
   phase_fatigue_cleared = \
      "This area of peace lifts your phase fatigue."
   phased_player_description = \
      "This is the ghosted body of %q, whose consciousness has travelled to "
      "another plane of existence."
      
   bad_line_of_sight = \
      "Your hindered line of sight makes a successful hit more difficult."

      
   pvp_notify_wav = gong.wav

classvars:

   viHand_space = 2
   viBody_space = 1

   viQuiver_space = 1
   viNeck_space = 1
   viHead_space = 1
   viLeg_space = 1

   viFinger_space = 2
   viGauntlet_space = 1

   % Our actual max is this plus a bonus for might.
   viBulk_hold_max = 1700
   viWeight_hold_max = 1700

   viMax_vigor = 200

properties:

   vrIcon = player_male_icon_rsc

   poSession
   pbLogged_on = FALSE

   % This is used to determine raises in hit points only.
   poKill_target = $
   piGain_chance = 0

   % This keeps track of training points that players accumulate when 
   % killing mobs.
   piTraining_points = 0
   piInform = TRUE

   % This keeps track of when we've last received our daily training points.
   piReward_timestamp = 0

   % For those crazy people who stay logged on 24/7 and may forget to relog
   % and cash in on their daily training points, we grant the points every 24
   % hours of online time.
   ptReward_timer = $

   % Flags for various character attributes.
   piFlags = 0
   piFlags2 = 0
   piFlags3 = 0

   % Set of flags with player preferences.
   piPreferences = CF_DEFAULT_PREF

   % player starts unguilded--doesn't do much yet
   poGuild = $
   piGuildRejoinTimestamp = 0

   % Evil twin object
   poEvilTwin = $

   % list of spells we know, in the form of a 3-part compound
   plSpells = $

   % list of skills we know, in the form of a 3-part compound
   plSkills = $

   % A list of the total percentage points the player has in the various
   %  spell and skill schools.
   plSchools = $

   % A list of the weighted casts the player has made in various schools.
   % Weighted because higher level spells will contribute more points to
   % the total. Used to give bonuses to improving spells.
   % See spell.kod for details.
   plSchoolCasts = $

   % The number of swings with the current weapon
   piWeaponSwings = 0

   % A compound of if the player can advance and the WC proficiency needed
   % to use the weapon. The proficiency number is the number / 1000, while
   % the bonus to advance is the number mod 1000.
   piWeaponInfo = 0

   % converted guild commands list to a bitvector.
   piGuild_commands = 0

   piLast_restart_time = 0

   % Permanent character base stats.
   piMight = 0
   piIntellect = 0
   piStamina = 0
   piAgility = 0
   piMysticism = 0
   piAim = 0

   % Modifiers to those base stats.
   piMightMod = 0
   piIntellectMod = 0
   piStaminaMod = 0
   piAgilityMod = 0
   piMysticismMod = 0
   piAimMod = 0

   %%% Variable character values.

   % The player sees piMax_Health in their client.
   % piBase_Max_Health is their base without any modifiers
   % IMPORTANT NOTE: For higher accuracy, a battler's current health 
   %(and only current health) is inflated by a factor of 100. Doing so 
   % avoids truncation errors but is not revealed to users in any way.
   piHealth = 2000
   piMax_Health = 20
   piBase_Max_Health = 20

   piMax_Mana = 20
   piMana = 20

   % piKarma is measured in hundredths of karma units
   piKarma = 0

   % Percent stomach is full.
   piStomach = 0

   % Governs health and mana replacement rates
   piVigor = 100
   % Accumulates small vigor debits from attacks, etc.
   piExertion = 0

   % This replaces a timer
   piTimeLastStomachUpdate = 0

   % stuff in use
   plUsing = $

   % Timers 
   ptHealth = $
   ptAdvancement = $
   ptRest = $

   % Poison info
   ptPoison = $
   piPoisonStrength = 0

   % List of objects adding overlays to us.
   plOverlays = $

   % List of objects with window overlays.
   plWindow_overlays = $

   % Object that set our icon (usually armor)
   poIcon_set = $

   % Object that ditched our hair (usually helmets)
   poHair_remove = $

   % object that set our legs (usually pants)
   poLegs_set = $
   poArms_set = $

   % Object that sets our entire look (overrides any part changes)
   poIllusion_set = $

   piBody_translations = 0
   piBody_translations2 = 0

   % Default: green shirt, brown pants.
   piDefault_Clothes = 143 | (121 * PANTS_MUL)

   % Light source at player.
   % Default strength of light source at player is 5
   piLight = 5

   % Attack modifiers to attack roll & damage (includes items & spells)
   plAttack_modifiers = $

   % Defense modifiers to defense roll & damage (includes items & spells)
   plDefense_modifiers = $

   % Gear preferences for 'set' and 'loadout'
   plLoadout_list = $

   piGender = GENDER_MALE

   piVigor_rest_threshold = 80

   % The user's string description, typed when created (and editable in game).
   psPlayerDescription = $

   % graphics stuff

   prLegs = player_legs_a_rsc
   prRight_arm = player_rightarm_a_rsc
   prLeft_arm = player_leftarm_a_rsc

   prHead = charinfo_head_ax_icon
   prEyes = charinfo_eyes_ax_icon
   prMouth = charinfo_nose_ax_icon
   prNose = charinfo_mouth_ax_icon
   prToupee = charinfo_hair_cd_icon

   % Animation type.  If none, then use piAction
   % piAnimation should be PANM_NONE in between KOD calls.
   piAnimation = PANM_NONE 

   % Action, such as "smiling", that player is currently doing
   piAction = 1

   % piNodeList is a bitvector of all of the mana nodes that the player has
   %  successfully melded with.  List of available nodelists in the
   %  blakston.khd constants file.
   piNodeList = 0

   piBorn_year = 0

   % Faction stuff.
   piFactionEffect = 0
   piFaction = FACTION_NEUTRAL
   piFactionServiceUpdate = 0
   piFactionTimeUpdated = 0
   ptFactionTimer = $

   piKill_count = 0
   piKill_count_decay = 0
   piJustified_kill_count = 0

   ptAttackTimer = $

   psHonor = $
   plHonor = $

   piMonsterChasers = 0

   piView = $

   poBondedItem = $
   ptBondedItemReport = $

   piLastDeathTime = 0

   % Temp safe timer for giving players a period of safety after a death
   ptTempSafe = $
   
   % This keeps the duration of our Second Wind skill's "downtime"
   ptSecondWind = $

   % Measures how long we have to wait before we're rescued.
   ptRescue = $

   % piTimeAttackedPlayer records the last time we attacked a player.
   %  This is used in conjunction with the constant ATTACKED_PLAYER_WAIT
   %  to disallow casting by angeled "mules".
   piTimeAttackedPlayer = 0 

   % piTimeAttackedByPlayer records the last time we were attacked by a player.
   piTimeAttackedByPlayer = 0
   
   % piDeathcost is used to tell the underworld what percent of normal
   %  penalties to apply when the players leaves.  FALSE means no penalties.
   piDeathCost = 100

   % List of integer years in which the player has donated money to the game.
   % Used to construct a string for their description.
   plDonationYears = $

   % Some spells let players choose teleport destinations by binding a location.
   piBound_Room = $
   piBound_row = 0
   piBound_col = 0
   piBound_fine_row = 0
   piBound_fine_col = 0
   piBound_angle = ANGLE_SOUTH

   % Is the player currently using a Death Rift spell?
   pbDeath_rift = FALSE
   ptDeathRiftTimer = $

   % This list keeps track of selfcast buffs for passive improvement.
   plPassiveImprovement = $

   % Crystalize Mana Surge data
   ptCrystalizeManaSurgeTimer = $
   piCrystalizeManaSurging = FALSE

   % Players will naturally fall out of groups if they aren't getting kills
   ptLeaveBuilderGroupTimer = $

   % Time remaining phased out
   ptPhaseTimer = $
   ptPhaseVisualEffectTimer = $
   piRemainingPhaseTime = 60000 * 8
   ptCanPhaseTimer = $

messages:

   Constructor()
   {
      % Let the poor bastards eat something.
      piTimeLastStomachUpdate = GetTime();
      piReward_timestamp = GetTime();

      propagate;
   }

   Delete()
   {
      local i;

      Send(self,@QuitGuild);
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth = $;
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptPoison <> $
      {
         DeleteTimer(ptPoison);
         ptPoison = $;
      }

      if ptAdvancement <> $
      {
         DeleteTimer(ptAdvancement);
         ptAdvancement = $;
      }

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
               #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }

      if ptTempSafe <> $
      {
         DeleteTimer(ptTempSafe);
         ptTempSafe = $;
      }

      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
               #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
         piCrystalizeManaSurging = FALSE;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      Send(self,@CancelRescue);

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      Send(self,@RemoveAllEnchantments,#report=FALSE);

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp = self);
      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);

      Send(Send(SYS,@GetAssassinGame),@RemoveFromGame,#who=self);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);
      plSchools = $;

      propagate;
   }

   %%% Player flags

   SetPlayerFlag(flag=0,value=FALSE,flagset=1)
   "This always requires the POSITIVE flag name."
   {
      local ccond;

      if flagset = 1 AND (flag & PFLAG_PKILL_ENABLE) AND value
      {
         if (piFlags & PFLAG_PKILL_ENABLE)
         {
            return;
         }
         else
         {
            ccond = player_safety_off_mail;
            if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
            {
               ccond = player_safety_on_mail;
            }

            if Send(SYS,@IsPKAllowed)
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                 #dest_list=[self],#nest_list=[4,player_ready_to_kill,4,ccond]);
            }
            else
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                 #dest_list=[self],#nest_list=[4,player_ready_to_guild,4,ccond]);
            }
         }
      }

      if flagset = 1
      {
         if NOT Value
         {
            piFlags = piFlags & ~flag;
         }
         else
         {
            piFlags = piFlags | flag;
         }
      }
      else if flagset = 2
      {
         if NOT Value
         {
            piFlags2 = piFlags2 & ~flag;
         }
         else
         {
            piFlags2 = piFlags2 | flag;
         }
      }
      else if flagset = 3
      {
         if NOT Value
         {
            piFlags3 = piFlags3 & ~flag;
         }
         else
         {
            piFlags3 = piFlags3 | flag;
         }
      }

      if (poOwner <> $)
         AND (flagset = 1)
         AND (flag & (PFLAG_MURDERER | PFLAG_OUTLAW | PFLAG_INVISIBLE))
      {
         % Tell room about change in case there are ramifications.
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if flag = PFLAG_MORPHED
      {
         Post(self,@DrawOffense);
      }

      if flag = PFLAG_NO_MOVE
         OR flag = PFLAG_NO_FIGHT
         OR flag = PFLAG_NO_MAGIC
         OR flag = PFLAG_MORPHED
      {
         Post(self,@DrawDefense);
      }

      return;
   }

   CheckPlayerFlag(flag=0,flagset=1)
   "This always checks to be sure that the flag exists."
   {
      if flagset = 1
      {
         return (piFlags & flag);
      }

      if flagset = 2
      {
         return (piFlags2 & flag);
      }

      if flagset = 3
      {
         return (piFlags3 & flag);
      }

      return FALSE;
   }

   % Player preference flags (e.g. safety, tempsafe etc.)
   SetPlayerPreference(flag = 0, value = 0)
   {
      if value
      {
         piPreferences = piPreferences | flag;
      }
      else
      {
         piPreferences = piPreferences & ~flag;
      }

      return;
   }

   CheckPlayerPreference(flag = 0)
   {
      if (flag = CF_SAFETY_OFF) AND NOT Send(SYS,@IsPKAllowed)
      {
         return FALSE;
      }

      return (piPreferences & flag);
   }

   % Added a nodraw paramater to this function to deal with buggy Jala
   % implementation. Can remove this and 3 instances of it used in 
   % player.kod when Jala fixed
   ResetPlayerFlagList(nodraw=FALSE)
   {
      local i;

      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=FALSE);

      piFlags = (piFlags & PFLAG_MASK);
      piFlags2 = (piFlags2 & PFLAG2_MASK);
      piFlags3 = (piFlags3 & PFLAG3_MASK);
      if Send(self,@IsResting)
      {
         piFlags = piFlags | PFLAG_NO_MOVE;
         piFlags = piFlags | PFLAG_NO_FIGHT;
         piFlags = piFlags | PFLAG_NO_MAGIC;
      }

      foreach i in plEnchantments
      {
         Send(Nth(i,2),@SetSpellPlayerFlag,#who=self);
      }

      foreach i in plUsing
      {
         Send(i,@SetItemPlayerFlag,#who=self);
      }

      if poOwner <> $
      {
         foreach i in Send(poOwner,@GetEnchantmentList)
         {
            Send(Nth(i,2),@SetSpellPlayerFlag,#who=self,#state=Nth(i,3));
         }
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      if nodraw=FALSE
      {
         Post(self,@DrawOffense);
         Post(self,@DrawDefense);
      }

      return;
   }

   GetGameSecurityFlag(flag = 0)
   {
      return 0;
   }

   GetLastRestartTime()
   {
      return piLast_restart_time;
   }

   SetLastRestartTime(time = 0)
   {
      piLast_restart_time = time;

      return piLast_restart_time;
   }

   %%% Vigor

   NewVigor()
   "Ensures vigor stays in bounds.  Also checks for second wind skill. "
   "NOTE: Do not modify vigor below SECONDWIND_THRESHOLD if you do not "
   "want the skill to kick in. Vigor display will be driven from here."
   {
      if piVigor < SECONDWIND_THRESHOLD
         AND ptSecondWind = $
         AND pbLogged_on
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) > 0
         AND Send(Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND),
                  @DoSkill,#who=self)
      {
         Send(self,@StartSecondWind);
      }

      piVigor = bound(piVigor,1,viMax_vigor);
      Send(self,@DrawVigor);

      return;
   }

   StartSecondWind()
   {
      local oWind, iTime;

      if Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) = 0
      {
         return FALSE;
      }

      oWind = Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND);
      iTime = Send(oWind,@GetWaitTime,#who=self);
      ptSecondWind = CreateTimer(self,@EndSecondWindTimer,iTime);
      Send(self,@SetVigorRestThreshold,#amount=10);

      return TRUE;
   }

   EndSecondWindTimer()
   {
      ptSecondWind = $;
      Send(self,@EndSecondWind);

      return;
   }

   EndSecondWind()
   {
      local iAmount;

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
      }

      % This prevents repeated triggering of the second wind skill.
      if piVigor < SECONDWIND_THRESHOLD
      {
         piVigor = SECONDWIND_THRESHOLD;
      }

      iAmount = 80 + ((Send(self,@GetSkillAbility,
                        #Skill_num=SKID_SECOND_WIND) + 1) / 5);
      Send(self,@SetVigorRestThreshold,#amount=iAmount);
      Send(self,@NewVigor);
      Send(self,@MsgSendUser,#message_rsc=second_wind_finished);
      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
            #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);

      return;
   }

   GetSecondWindTimer()
   {
      return ptSecondWind;
   }

   GetVigorRestThreshold()
   {
      return piVigor_rest_threshold;
   }

   SetVigorRestThreshold(amount = 0)
   {
      piVigor_rest_threshold = amount;

      % Don't go above rest threshold if we're still waiting for Second Wind.
      if ptSecondWind <> $
      {
         piVigor_rest_threshold = 10;
      }

      piVigor_rest_threshold = Bound(piVigor_rest_threshold,10,80 +
               ((Send(self,@GetSkillAbility,#skill_num=SKID_SECOND_WIND)+1)/5));

      Send(self,@DrawVigor);

      return;
   }

   AddExertion(amount = 0, SetToThreshold = FALSE)
   {
      local iExertionAdded, iPercentReduced, iVigorLost;

      % If we cannot gain vigor due to Second Wind, return out if trying
      % to take away exertion
      if ptSecondWind <> $ AND amount < 0
      {
         return;
      }

      iExertionAdded = amount;

      if iExertionAdded > 0
      {
         % Parliament adjustment for exertion reduction.  Remove a % from
         % the amount added.
         iPercentReduced = Send(Send(SYS,@GetParliament),@GetFactionVigorBonus,#who=self);
         iExertionAdded = (iExertionAdded * (100 - iPercentReduced))/100;
      }

      piExertion = piExertion + iExertionAdded;

      if abs(piExertion) > MIN_VIGOR_CHANGE OR SetToThreshold
      {
         if SetToThreshold AND piVigor < piVigor_rest_threshold
         {
            piVigor = piVigor_Rest_threshold;
            piExertion = 0;
         }
         else
         {
            iVigorLost = piExertion / 10000;
            piVigor = piVigor - iVigorLost;
            piExertion = piExertion - (iVigorLost * 10000);
         }

         Send(self,@NewVigor);
      }

      return;
   }

   RestAddExertion(amount = 0)
   "Gives inns a bonus as resting places."
   {
      local iAmount;

      % If we cannot gain vigor (probably due to Second Wind), return
      % out if trying to take away exertion
      if ((ptSecondWind <> $) AND (amount < 0))
         OR Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if piVigor > piVigor_rest_threshold
      {
         return;
      }

      iAmount = Amount;
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY) AND amount < 0
      {
         iAmount = 2 * Amount;
      }

      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_TRIPLE_HEAL) AND amount < 0
      {
         iAmount = 3 * Amount;
      }

      piExertion = piExertion + iAmount;
      if abs(piExertion) > MIN_VIGOR_CHANGE
      {    
         piVigor = piVigor - piExertion / 10000;
         if piVigor > piVigor_rest_threshold
         {
            piVigor = piVigor_rest_threshold;
         }

         piExertion = 0;
         Send(self,@NewVigor);
      }

      return;
   }

   UpdateStomach()
   "Removes consumed food from stomach"
   {
      local now;

      now = GetTime();
      piStomach = piStomach-(now-piTimeLastStomachUpdate)*FOOD_USE_RATE/100;
      piStomach = bound(piStomach,1,100);
      piTimeLastStomachUpdate = now;

      return;
   }

   HasVigor(amount = $)
   {
      if piVigor > amount
      {
         return TRUE;
      }

      return FALSE;
   }

   StartRescueTimer(time=5000)
   "Starts a timer which will rescue the player after time ms."
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      ptRescue = CreateTimer(self,@EndRescueTimer,time);

      return TRUE;
   }

   EndRescueTimer()
   {
      ptRescue = $;
      Send(self,@EndRescue);

      return;
   }

   EndRescue()
   "Deletes rescue timer if it exists and does the rescue operation."
   {
      Send(self,@CancelRescue);

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_RESCUE),@DoRescue,#who=self);
      }

      return;
   }

   CancelRescue()
   "Cancels the rescue timer if it exists and does not execute "
   "the rescue operation."
   {
      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      return;
   }

   CanRescue()
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   TryDeflect(what = $,caster=$)
   {
      local oDeflect;

      oDeflect = Send(SYS,@FindSpellByNum,#Num=SID_DEFLECT);
      if Send(self,@IsEnchanted,#what=oDeflect)
      {
         return Send(oDeflect,@TryDeflect,#caster=caster,#victim=self,
                     #oSpell=what);
      }

      return FALSE;
   }

   NewOwner(what = $)
   {
      local iBasePhaseTime;

      Send(self,@ResetGainFlags);

      % Are we moving somewhere "safe" or in a frenzy??
      if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         AND NOT Send(SYS,@GetChaosNight)
      {
         % Don't set the "haven't moved" flag if we're in a safe area.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

         % Don't create the revenant if we're in a safe location.
         if (piFlags & PFLAG_HAUNTED)
         {
            Create(&Revenant,#target=self,#location=poOwner,
                   #level=bound((((piBase_Max_health*150)/100)+
                        (5*piKill_Count_decay)),95,215),
                   #diff=bound(piBase_Max_health/10,4,9),
                   #karmic=-piKarma/100);
         }
      }

      Send(self,@BreakTrance,#event=EVENT_NEWOWNER);

      if (piFlags2 & PFLAG2_HUNTED)
      {
         Send(self,@InformHunters);
      }

      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
      {
         iBasePhaseTime = Send(self,@GetBasePhaseTime);
         if piRemainingPhaseTime <> iBasePhaseTime
         {
            Send(self,@MsgSendUser,#message_rsc=phase_fatigue_cleared);
            Send(self,@RefreshPhaseTimeToBase);
         }
      }

      % Stop any rescue attempts if the user changes rooms.
      if ptRescue <> $
      {
         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_newowner);
         }
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return;
   }

   InformHunters()
   {
      local i, j, oSpell, state, oSpellCloak, rLocation, lRoomlist, oRoom;

      oSpell = Send(SYS,@FindSpellByNum,#Num=SID_HUNT);
      oSpellCloak = Send(SYS,@FindSpellByNum,#Num=SID_CLOAK);
      rLocation = Send(poOwner,@GetName);

      if Send(self,@IsEnchanted,#what=oSpellCloak)
         AND (Random(1,100) < Send(self,@GetEnchantedState,#what=oSpellCloak))
      {
         % Will mislead hunters with random room if Cloak is on
         % and passes state check.
         oRoom = Send(oSpellCloak,@GetWrongRoom);
         rLocation = Send(oRoom,@GetName);
      }

      foreach i in plEnchantments
      {
         if Nth(i,2) = oSpell
         {
            state = Nth(i,3);
            if NOT IsClass(First(state),&Prism)
            {
               foreach j in state
               {
                  Send(j,@MsgSendUser,#message_rsc=player_to_hunters,
                        #parm1=Send(self,@GetDef),
                        #parm2=Send(self,@GetTrueName),
                        #parm3=rLocation);
               }
            }
         }
      }

      return $;
   }

   ShowDesc()
   {
      local i,oEnchanter, rank, HitPoint_Percent;

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         % Since piHealth is internally inflated by a factor of 100, this 
         % returns the percentage correctly.
         HitPoint_Percent = piHealth / piMax_Health;
         Send(poIllusion_set,@IllusionShowDesc,#who=self,
               #iHitPoint_Percent=HitPoint_Percent);

         return;
      }

      if psPlayerDescription <> $
      {
         AddPacket(4,player_desc_enchanted_none);
         AddPacket(0,psPlayerDescription);

         return;
      }

      propagate;
   }

   GetAge()
   {
      local age;

      age = Send(SYS,@GetYear) - Send(self,@GetBirthYear);

      % No more tutorial messages and bonuses if you've been around
      % for about 2 months. Clear the newbie string, too. Do a bit flag
      % check instead of a function call since this is called EVERY time
      % someone gets looked at.
      if age >= 2
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
         Send(self,@RemoveHonorString,#string=player_newbie_honor_string);
      }

      return age;
   }

   SetAge(age = 0)
   "Admin supported."
   {
      age = bound(age, 0, Send(SYS,@GetYear));
      piBorn_year = Send(SYS,@GetYear) - age;

      return age;
   }

   GetHonorStringList()
   {
      return plHonor;
   }

   HasHonorString(string = $)
   "Checks the plHonor list for the given string."
   {
      local i;

      if plHonor = $
         or string = $
      {
         return FALSE;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   AppendHonorStrings()
   "Appends all the honor strings to the temp string. Adds newline "
   "between strings."
   {
      local i;

      if plHonor <> $
      {
         foreach i in plHonor
         {
            % Add newbie tag separately so it gets translated.
            if i <> player_newbie_honor_string
            {
               AppendTempString(i);
               AppendTempString("\n");
            }
         }
      }

      return;
   }

   AddHonorString(string=$,iPosition = 1)
   "Adds string to plHonor list. iPosition allows string position "
   "to be chosen."
   {
      if string = $
      {
         return;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      if plHonor = $
      {
         plHonor = [string];
      }
      else
      {
         plHonor = InsertListElem(plHonor,iPosition,string);
      }

      return;
   }

   RemoveHonorString(string=$)
   "Removes the given string from plHonor. Searches the entire list, "
   "so it will remove any duplicates."
   {
      local i;

      if plHonor = $
         OR string = $
      {
         return;
      }

      % Convert temp string if we received it.
      if string = GetTempString()
      {
         string = SetString($,string);
      }

      foreach i in plHonor
      {
         if StringContain(i,string)
         {
            plHonor = DelListElem(plHonor,i);
         }
      }

      return;
   }

   ClearHonorStrings()
   "Removes all the honor strings."
   {
      plHonor = $;

      return;
   }

   ShowExtraInfo()
   {
      local i, j, obj, year, rCargoNum;

      % Master fixed info resource.
      AddPacket(4,player_fixed_info);

      %
      % Add hometown and age, or DM rank.
      %
      if NOT IsClass(self,&DM)
      {
         switch(Send(self,@GetHomeRoom))
         {
            case RID_NEWB1:
               j = player_citizen_raza;
               break;
            case RID_GUEST1:
               j = player_citizen_hazar;
               break;
            case RID_BAR_INN:
               j = player_citizen_barloque;
               break;
            case RID_COR_INN:
               j = player_citizen_cornoth;
               break;
            case RID_MAR_INN:
               j = player_citizen_marion;
               break;
            case RID_JAS_INN:
               j = player_citizen_jasper;
               break;
            case RID_TOS_INN:
               j = player_citizen_tos;
               break;
            case RID_KOC_INN:
               j = player_citizen_kocatan;
               break;
            default:
               j = player_citizen_unknown;
               break;
         }

         AddPacket(4,player_hometown_rsc,4,Send(self,@GetHeShe,#cap=TRUE),4,j);
         ClearTempString();
         i = Send(self,@GetAge);
         if (i < 1)
         {
            AddPacket(4,system_blank_resource,4,GetTempString(),
                      4,player_under_one_year);
         }
         else
         {
            AddPacket(4,player_for);

            Send(SYS,@AppendCardinalToTempString,#number=i);
            AddPacket(4,GetTempString());
            if i = 1
            {
               AddPacket(4,player_year);
            }
            else
            {
               AddPacket(4,player_years);
            }
         }
      }
      else
      {
         % For DMs
         i = Send(self,@GetRankRsc);
         if i <> $
         {
            AddPacket(4,i);
         }
         else
         {
            AddPacket(4,system_blank_resource);
         }
      }

      %
      % Add guild affiliation.
      %
      if poGuild <> $ AND NOT Send(poGuild,@IsSecret)
      {
         i = Send(poGuild,@GetRank,#who=self);
         % (example) Squire of the BootLickers.
         AddPacket(4,player_guild_rsc, 4,Send(poGuild,@GetRankName,#rank=i,#sex=piGender),
                   4,player_of, 4,Send(poGuild,@GetDef),4,Send(poGuild,@GetName));
      }
      else
      {
        AddPacket(4,system_blank_resource);
      }

      %
      % Add faction affiliation.
      %
      i = Send(self,@GetFaction);
      if (i = FACTION_DUKE)
      {
         AddPacket(4,player_faction_duke);
      }
      else if (i = FACTION_PRINCESS)
      {
         AddPacket(4,player_faction_princess);
      }
      else if (i = FACTION_REBEL)
      {
         AddPacket(4,player_faction_rebel);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      %
      % Add visible cargo types. The number of these doesn't really change,
      % but this section has error checking anyway just in case we change it.
      %
      j = Send(SYS,@GetVisibleCargoTypes);
      if j = $
      {
         AddPacket(4,system_blank_resource);
      }
      else
      {
         switch(Length(j))
         {
            case 5:
               rCargoNum = system_rsc_template_5;
               break;
            case 1:
               rCargoNum = system_rsc_template_1;
               break;
            case 2:
               rCargoNum = system_rsc_template_2;
               break;
            case 3:
               rCargoNum = system_rsc_template_3;
               break;
            case 4:
               rCargoNum = system_rsc_template_4;
               break;
            case 6:
               rCargoNum = system_rsc_template_6;
               break;
            case 7:
               rCargoNum = system_rsc_template_7;
               break;
            default:
               rCargoNum = system_rsc_template_1;
               break;
         }

         AddPacket(4,rCargoNum);

         foreach i in j
         {
            % (example) He is holding a purple pickle princess figurine.
            obj = Send(self,@FindHolding,#class=i);
            if obj <> $
            {
               if IsClass(obj,&Ring)
               {
                  AddPacket(4,player_is_wearing, 4,Send(self,@GetHeShe,#cap=True),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
               else
               {
                  AddPacket(4,player_is_holding, 4,Send(self,@GetHeShe,#cap=True),
                            4,Send(obj,@GetIndef), 4,Send(obj,@GetName));
               }
            }
            else
            {
              AddPacket(4,system_blank_resource);
            }
         }
      }

%%% Option turned off for review.
% Works with %q placed in the master fixed description resource.
%      ClearTempString();
%      if NOT Send(self,@PlayerIsImmortal)
%      {
%         % (example) Known far and wide for mastery of Jala and Kraanan magics 
%         % and weaponcraft skills.
%
%         j = FALSE;
%
%         % magic school masteries first
%         obj = Send(SYS,@FindSpellByNum,#num=SID_BONK); % any real spell will do
%         foreach i in [SS_JALA,SS_RIIJA,SS_QOR,SS_SHALILLE,SS_KRAANAN,SS_FAREN]
%         {
%            if Send(self,@CountKnownAtLevel,#school=i,#level=6) >= 1
%            {
%               if NOT j
%               {
%                  AppendTempString(player_known_for_mastery);
%                  j = TRUE;
%               }
%               else
%               {
%                  AppendTempString(player_and);
%               }
%               AppendTempString(Send(obj,@GetSchoolStr,#ischool=i));
%            }
%         }
%         
%         if j
%         {
%            AppendTempString(player_magics);
%         }
%
%         % weaponcraft
%         if Send(self,@CountKnownAtLevel,#school=SKS_FENCING,#level=5) >= 1
%         {
%            if NOT j
%            {
%               AppendTempString(player_known_for_mastery);
%               j = TRUE;
%            }
%            else
%            {
%               AppendTempString(player_and);
%            }
%            AppendTempString(player_skills);
%         }
%
%         AppendTempString(player_dot);
%         AppendTempString(player_nl);
%      }
%      AddPacket(4,GetTempString());

      %
      % Add newbie tag resource ID, so client can translate it.
      %
      if Send(self,@HasHonorString,#string=player_newbie_honor_string)
      {
         AddPacket(4,player_newbie_honor_string);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      %
      % Append all honor strings (except newbie tag) to the temp string.
      %
      ClearTempString();
      Send(self,@AppendHonorStrings);
      AddPacket(4,GetTempString());

      %
      % Add donation years.
      %
      ClearTempString();
      if plDonationYears <> $
      {
         i = 0;
         foreach year in plDonationYears
         {
            if i <> 0
            {
               AppendTempString(player_donation_separator);
            }
            AppendTempString(year);
            ++i;
         }
         AddPacket(4,player_donation_title,4,GetTempString());
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   UserLogonHook()
   {
      local i, oGame, oParl, iBonus, iDefaultBonus, iTimespan;

      SendList(plPassive, 0, @UserLogon);
      SendList(plActive, 0, @UserLogon);

      % Restart Health and Mana timers
      Send(self,@NewHealth);
      Send(self,@NewMana);

      Send(self,@SendUserAllWindowOverlays);

      oParl = Send(SYS,@GetParliament);
      if oParl <> $
      {
         if piFaction <> FACTION_NEUTRAL 
            AND (NOT Send(oParl,@IsShutdown))
         {
            piFactionTimeUpdated=GetTime();
            Send(self,@FactionServiceTimer);
         }

         if Send(self,@PlayerIsIntriguing)
         {
            Send(oParl,@UpdateEffects,#who=self); 
         }
      }

      oGame = Send(SYS,@GetAssassinGame);
      if oGame <> $
         AND Send(oGame,@InAcceptMode)
         AND (NOT Send(oGame,@IsCombatant,#who=self))
         AND Send(oGame,@IsAdvertised,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=player_assgame_soon);
      }

      if poGuild <> $
      {
         Send(poGuild,@SendUserMOTD,#who=self);
      }

      if ptTempSafe <> $
      {
         piFlags = piFlags | PFLAG_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe);
      }

      if piPoisonStrength > 0
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      % Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

      % If we log into the Raza/Hazar inn and aren't past the tutorial,
      %   then give us a commands list.
      if IsClass(poOwner,&Guest1)
         OR (IsClass(poOwner,&Newb1)
            AND NOT (piFlags & PFLAG_TUTORIAL))
      {
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Max mana could have changed while offline (e.g. mana node changes).
      % We used to do this when the mana nodes changed, but iterating
      % over all players became far too expensive.
      Send(self,@ComputeMaxMana);

      % Tell others that we're here
      if poOwner <> $ AND NOT IsClass(self, &DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_on_wav_rsc);
      }

      % Reward people for logging on by granting them some free training points!
      % We take the absolute value to automatically fix bugs with people
      % mysteriously ending up with a timestamp in the distant future.
      iTimespan = abs(GetTime() - piReward_timestamp);

      % We restrict the timespan to reasonable limits here since the bonus to
      % training points scales with the time since the last bonus has been
      % received. 36 hours means that players have a decent leeway to log on
      % again before missing out on training points, but are still encouraged
      % to log on daily to cash in maximum points.
      iTimespan = bound(iTimespan,0,36*60*60);

      if iTimespan > 16*60*60
      {
         if piTraining_points >= 1000
         {
            return;
         }

         % Retrieve the daily logon bonus from settings.
         iDefaultBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);
         
         % Scale the logon bonus with the time that has passed since it has last
         % been received for a total bonus of up to 150 percent.
         iBonus = iDefaultBonus * iTimespan / (24*60*60);
         
         Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
         Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

         piReward_timestamp = GetTime();
      }

      % For people who never log off, start the reward timer that will grant
      % them the daily training bonus every 24 hours, even if they don't log
      % off and back on.
      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);

      return;
   }

   UserLogoffHook()
   {
      local i;

      SendList(plPassive,0,@UserLogoff);
      SendList(plActive,0,@UserLogoff);

      % If this player has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         foreach i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      % client assumes not resting upon login
      Send(self,@StopResting);

      if piFaction <> FACTION_NEUTRAL
      {
         Send(self,@FactionServiceTimer,#renew=FALSE);
      }

      % Stop health and mana timers.
      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth=$;
      }

      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptReward_timer <> $
      {
         DeleteTimer(ptReward_timer);
         ptReward_timer = $;
      }

      Send(self,@CancelRescue);

      % Tell others that we're leaving
      if poOwner <> $ AND NOT IsClass(self,&DM)
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
               #wave_rsc=player_logged_off_wav_rsc);
      }

      return;
   }

   SendUserAllWindowOverlays()
   "Send the user any overlays that they might have.  Called when they logon "
   "or when garbage collected."
   {
      local i;

      foreach i in plWindow_overlays
      {
         Send(self,@SetWindowOverlay,#what=i);
      }

      return;
   }

   RestrictToResourceList(res = $, res_list = $)
   "If res is in res_list, return it.  Otherwise return the first element "
   "of res_list."
   {
      if FindListElem(res_list, res)
      {
         return res;
      }

      return Nth(res_list, 1);
   }

   PlayerNewCharInfo(desc = $,charinfo = $,gender = $)
   "This message is received when the user (re)started a character.\n"
   "<desc> contains a string with the description, charinfo is a list "
   "of values selected.  See system.kod, SendCharInfo(), for what these "
   "values mean."
   {
      local i, lFaceparts, lStats, lSpells, lSkills, iPoints, iLevel, oSpell,
            iHair_translation, iSkin_translation, bQor, bShalille, oSkill;

      bQor = FALSE;
      bShalille = FALSE;

      psPlayerDescription = desc;

      if Length(charinfo) <> 6
      {
         Debug("Bad charinfo message, length ",Length(charinfo));

         return;
      }

      % charinfo is a list of 4 elements:
      % list of face part resources
      % list of stats (might, intellect, etc.)
      % list of initial spells
      % list of initial skills

      lFaceparts = Nth(charinfo,1);
      if (Length(lFaceparts) <> 5)
      {
         % Hacking the protocol -> default char
         gender = GENDER_MALE;
         lFaceparts = [charinfo_head_ax_icon,charinfo_hair_ac_icon,
                       charinfo_eyes_ax_icon,charinfo_nose_ax_icon,
                       charinfo_mouth_ax_icon];
      }

      % Validate that all face parts were in the list of choices
      prHead = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,1),
          #res_list = Send(SYS, @GetAllowedHeadIcons, #iGender = gender));

      prToupee = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,2), 
          #res_list = Send(SYS, @GetAllowedHairIcons, #iGender = gender));

      prEyes = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,3), 
          #res_list = Send(SYS, @GetAllowedEyeIcons, #iGender = gender));

      prNose = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,4), 
          #res_list = Send(SYS, @GetAllowedNoseIcons, #iGender = gender));

      prMouth = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,5), 
          #res_list = Send(SYS, @GetAllowedMouthIcons, #iGender = gender));

      iHair_translation = Nth(charinfo,2);
      iSkin_translation = Nth(charinfo,3);

      if iHair_translation <> 0
         AND iHair_translation <> PT_GRAY_TO_ORANGE
         AND iHair_translation <> PT_GRAY_TO_RED
         AND iHair_translation <> PT_GRAY_TO_SKIN1
         AND iHair_translation <> PT_GRAY_TO_SKIN2
         AND iHair_translation <> PT_GRAY_TO_SKIN3
         AND iHair_translation <> PT_GRAY_TO_SKIN4
         AND iHair_translation <> PT_GRAY_TO_SKIN5
         AND iHair_translation <> PT_GRAY_TO_PLATBLOND
         AND iHair_translation <> PT_GRAY_TO_KORANGE
         AND iHair_translation <> PT_GRAY_TO_KRED
         AND iHair_translation <> PT_GRAY_TO_KGRAY
         AND iHair_translation <> PT_GRAY_TO_BLACK
         AND iHair_translation <> PT_GRAY_TO_BLOND
         AND iHair_translation <> PT_GRAY_TO_LSKY
      {
         % if they hacked char.dll...
         iHair_translation = PT_GRAY_TO_BLOND;
      }
      
      Send(self,@SetHairTranslation,#translation=iHair_translation);

      if iSkin_translation <> PT_BLUE_TO_SKIN1
         AND iSkin_translation <> PT_BLUE_TO_SKIN2
         AND iSkin_translation <> PT_BLUE_TO_SKIN3
         AND iSkin_translation <> PT_BLUE_TO_SKIN4
      {
         % if they hacked char.dll...
         iSkin_translation = PT_BLUE_TO_SKIN3;
      }

      Send(self,@SetSkinTranslation,#translation=iSkin_translation);
      Send(self,@SetDefaultClothes,#rand=TRUE);
      Send(self,@ResetPlayerIcon);
      Send(self,@ResetPlayerArms);
      Send(self,@ResetPlayerLegs);

      lStats = Nth(charinfo,4);
      if (Length(lStats) <> 6)
      {
         % Hacking the protocol -> junk char for you
         lStats = [1, 1, 1, 1, 1, 1];
      }

      iPoints = Nth(lStats,1) + Nth(lStats,2) + Nth(lStats,3);
      iPoints = iPoints + Nth(lStats,4) + Nth(lStats,5) + Nth(lStats,6);

      if Nth(lStats,1) < 1 OR Nth(lStats,1) > 50
         OR Nth(lStats,2) < 1 OR Nth(lStats,2) > 50
         OR Nth(lStats,3) < 1 OR Nth(lStats,3) > 50
         OR Nth(lStats,4) < 1 OR Nth(lStats,4) > 50
         OR Nth(lStats,5) < 1 OR Nth(lStats,5) > 50
         OR Nth(lStats,6) < 1 OR Nth(lStats,6) > 50
         OR iPoints > 200
      {
         % they hacked their char.dll
         piMight = 3;
         piIntellect = 1;
         piStamina = 4;
         piAgility = 1;
         piMysticism = 5;
         piAim = 9;
      }
      else
      {
         piMight = Nth(lStats,1);
         piIntellect = Nth(lStats,2);
         piStamina = Nth(lStats,3);
         piAgility = Nth(lStats,4);
         piMysticism = Nth(lStats,5);
         piAim = Nth(lStats,6);
      }

      % Set some other stats based on these

      piHealth = 2000;
      Send(self,@NewHealth);
      piBase_Max_Health = 20;
      piMax_health = piBase_max_health;
      Send(self,@GainBaseMaxHealth);
      
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," restarted character: ",piMax_health,
               pibase_max_health);
      }

      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;

      % need to determine male/female
      if gender = GENDER_MALE
      {
         piGender = GENDER_MALE;
         vrIcon = player_male_icon_rsc; 
         prLegs = player_legs_a_rsc;
         prRight_arm = player_rightarm_a_rsc;
         prLeft_arm = player_leftarm_a_rsc;
      }
      else
      {
         piGender = GENDER_FEMALE;
         vrIcon = player_female_icon_rsc; 
         prLegs = player_legs_b_rsc;
         prRight_arm = player_rightarm_b_rsc;
         prLeft_arm = player_leftarm_b_rsc;
      }

      Send(self,@ResetCharacter);

      % Setup default stuff

      Send(self,@AddDefaultSpells);
      Send(self,@AddDefaultSkills);

      lSpells = Nth(charinfo,5);
      lSkills = Nth(charinfo,6);

      iPoints = 0;
      foreach i in lSpells
      {
         iLevel = Send(Send(SYS,@FindSpellByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }

      foreach i in lSkills
      {
         iLevel = Send(Send(SYS,@FindSkillByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }

      if iPoints > 45
      {
         % they hacked their char.dll
      }
      else
      {
         if NOT IsClass(self,&Guest)
         {
            foreach i in lSpells
            {
               oSpell = Send(SYS, @FindSpellByNum, #num=i);
               % Not offered to new characters -> cheating, skip spell
               if (oSpell <> $ AND Send(oSpell,@OfferToNewCharacters))
               {
                  iLevel = Send(oSpell,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSpell,#num=i,#initial=TRUE);
                  }
                  if (Send(oSpell,@GetSchool) = SS_QOR)
                  {
                     bQor = TRUE;
                  }
                  if (Send(oSpell,@GetSchool) = SS_SHALILLE)
                  {
                     bShalille = TRUE;
                  }
               }
            }

            foreach i in lSkills
            {
               oSkill = Send(SYS,@FindSkillByNum,#num=i);
               if (oSkill <> $)
               {
                  iLevel = Send(oSkill,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSkill,#num=i,#initial=TRUE);
                  }
               }
            }
         }

         Send(self,@RefigureSchoolsLists);
      }

      % Do this after we add spells so that we can give reagents if appropriate.
      Send(self,@AddDefaultObjects);

      % If the player chose either a Qor spell or a Shalille spell to start,
      % give him a favorable karma to start from. However, if he chose both,
      % or if he chose neither, do nothing.

      piKarma = 0;
      if bQor AND NOT bShalille
      {
         piKarma = -2000;
      }

      if bShalille AND NOT bQor
      {
         piKarma = 2000;
      }

      Send(self,@SetInitialHomeroom);
      Send(self,@TeleportToInitialLocation);

      piBorn_year = Send(SYS,@GetYear);

      % Send first mail the first time player plays.
      % Set their honor strong if this is a truly new character (max 1 reroll)
      if NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_first_mail]);
         Send(self,@AddHonorString,#string=player_newbie_honor_string);
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Update stomach so it starts ticking down properly
      Send(self,@UpdateStomach);

      % Give them a new start on life, so that their newbie
      % friends can buff and heal them.
      piTimeAttackedPlayer = 0;

      return;
   }

   GetBirthYear()
   {
      return piBorn_year;
   }

   SetBirthYear(year=0)
   {
      piBorn_Year = year;

      return;
   }

   ResetCharacter()
   "Setup default stuff"
   {
      local i;

      % first, kill all their items

      foreach i in plActive
      {
         Send(i,@Delete);
      }

      foreach i in plPassive
      {
         Send(i,@Delete);
      }

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      plSpells = $;
      plSkills = $;

      if Send(self,@CheckLog)
      {
         Debug("LOG: ",vrName," restarted character, spells & skills are nil");
      }

      % Setup some stats
      piBase_max_health = 20;
      piMax_health = piBase_max_health;
      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;

      poKill_target = $;
      piKarma = 0;

      piVigor = 100;
      piVigor_rest_threshold = 80;
      piExertion = 0;
      % percent stomach is full
      piStomach = 0;
      piTimeLastStomachUpdate = 0;

      piKill_count = 0;
      piKill_count_decay = 0;
      piJustified_kill_count = 0;

      Send(self,@ZeroMods);

      Send(self,@PlayerIsIntriguing);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TEMPSAFE,#value=FALSE);

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp=self);

      % quit the guild, then be sure any guild commands are set to nil
      % important, keep this after the player flags part above.
      Send(self,@QuitGuild);
      piGuild_commands = 0;

      Send(Send(sys,@GetAssassinGame),@RemoveFromGame,#who=self);
      % Remove the guy from the Assassin's game.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      piLight = 5;

      % Be sure they aren't declared a 'former member' by any existing guilds.
      foreach i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      piNodelist = 0;

      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);

      if Send(SYS,@GetLastMurderer) = self
      {
         Send(SYS,@ClearLastMurderer);
      }

      return;
   }

   AddDefaultSpells()
   "Add the spells a player is given when creating a character"
   {
      Send(self,@AddSpell,#num=SID_BLINK,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_CONVEYANCE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_PHASE,#initial=TRUE);
      Send(self,@AddSpell,#num=SID_MEDITATE,#initial=TRUE,#iability=1);

      return;
   }

   AddDefaultSkills()
   "Add the skills that all players have."
   {
      return;
   }

   AddDefaultObjects()
   "Add the objects a player is given when creating a character in newbie zone"
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      % Give the poor newbie an weapon and a bit of cash.
      Send(self,@NewHold,#what=Create(&Mace));
      Send(self,@NewHold,#what=Create(&Money,#number=500));
      Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
      Send(self,@AddReagentsForSpells,#iNumCasts=10);

      % If player hasn't suicided in last 5 hours, give them cash and prizes!
      if (GetTime() - piLast_restart_time) > (5*60*60)   
      {
         Send(self,@NewHold,#what=Create(&Money,#number=500));
         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=500);
         Send(self,@AddReagentsForSpells,#iNumCasts=10);
      }

      return;
   }

   StripInventory()
   {
      local lItems,oItem;

      % Delete the old stuff.
      foreach lItems in [plActive,plPassive]
      {
         foreach oItem in lItems
         {
            Send(oItem,@Delete);
         }
      }

      return;
   }

   AddRealWorldObjects()
   "Add the objects a player is given when character leaves the newbie zone."
   {
      local lItems,oItem,iSchool;

      % If player hasn't suicided in last 5 hours,
      % give them cash and fancy clothes!
      if (GetTime() - piLast_restart_time) > (5*60*60)
      {
         Send(self,@NewHold,#what=Create(&Money,#number=1000));
         Send(Send(SYS,@GetStatistics),@MoneyCreated,#amount=1000);
         Send(self,@NewHold,#what=create(&InkyCap,#number=5));
         Send(self,@NewHold,#what=Create(&PantsC));
         Send(self,@NewHold,#what=Create(&Shirt,#color=XLAT_TO_GRAY));
      }

      if Send(Send(SYS,@GetLore),@BetaPotionsEnabled) 
         AND Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
      {
         Send(self,@NewHold,#what=create(&MysticSword));
         Send(self,@NewHold,#what=create(&MysticSword));
         Send(self,@NewHold,#what=create(&InkyCap,#number=20));
         Send(self,@NewHold,#what=create(&SimpleHelm));
         Send(self,@NewHold,#what=create(&ScaleArmor));
         Send(self,@NewHold,#what=create(&Gauntlet));
         Send(self,@AddReagentsForSpells,#iNumCasts=20);
      }

      Send(self,@NewHold,#what=Create(&Mace));
      Send(self,@NewHold,#what=Create(&Apple,#number=5));

      return;
   }

   AddReagentsForSpells(iNumCasts=5)
   "Add reagents to the player for the spells they have. Enough "
   "reagents for iNumCasts casts."
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      foreach iInfo in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=iInfo));
         lReagents = Send(oSpell,@GetReagents);

         foreach lItems in lReagents
         {
            cReagent = first(lItems);
            iNumber = Nth(lItems,2);

            Send(self,@NewHold,
                  #what=Create(cReagent,#number=(iNumber*iNumCasts)));
         }
      }

      return;
   }

   GetNumItemsInInventory()
   {
      return (length(plActive) + length(plPassive));
   }

   DropItem(droppedItem=$, targetGhost=$, dropRoom=$, dropRow=0, dropCol=0,
            dropFineRow=32,dropFineCol=32,index=$, merge=TRUE)
   {
      local oItem, oDropRoom, iDropRow, iDropCol, iDropFineRow, iDropFineCol,
            oItemAtt;

      if droppedItem <> $
      {
         oItem = droppedItem;
      }
      else if index = $
      {
         return FALSE;
      }

      oItem = Send(self,@FindItemByIndex,#index=index);

      % Can't drop nothing.
      if (oItem = $)
      {
         return FALSE;
      }

      if targetGhost = $
      {
         if dropRoom = $
         {
            oDropRoom = poOwner;
            iDropRow = piRow;
            iDropCol = piCol;
            iDropFineRow = piFine_row;
            iDropFineCol = piFine_col;
         }
         else
         {
            oDropRoom = dropRoom;
            iDropRow = dropRow;
            iDropCol = dropCol;
            iDropFineRow = dropFineRow;
            iDropFineCol = dropFineCol;
         }
      }
      else
      {
         % This is the result of a logoff ghost penalty.
         oDropRoom = Send(targetGhost,@GetOwner);
         iDropRow = Send(targetGhost,@GetRow);
         iDropCol = Send(targetGhost,@GetCol);
         iDropFineRow = Send(targetGhost,@GetFineRow);
         iDropFineCol = Send(targetGhost,@GetFineCol);
      }

      if Send(oItem,@ReqNewOwner,#what=oDropRoom)
         AND Send(oDropRoom,@ReqNewHold,#what=oItem,
                  #new_row=iDropRow,#new_col=iDropCol)
      {
         if Send(oItem,@DropOnDeath)
         {
            if targetGhost <> $
            {
               % Put the PK pointer attribute on the item to prevent
               % mules from grabbing penalty drops from ghosts.
               oItemAtt = Send(sys,@FindItemAttByNum,#num=IA_PKPOINTER);
               Send(oItemAtt,@AddToItem,#oItem=oItem,
                     #timer_duration=PKPOINTER_TIME,
                     #state1=self);
            }

            Send(oDropRoom,@NewHold,#what=oItem,#merge=merge,
                  #new_row=iDropRow,#new_col=iDropCol,
                  #fine_row=iDropFineRow,#fine_col=iDropFineCol);

            return TRUE;
         }
      }

      return FALSE;
   }

   FindItemByIndex(index = $)
   {
      local lInv;

      if index = $
      {
         return $;
      }

      if index <= length(plActive)
      {
         lInv = plActive;
      }
      else
      {
         lInv = plPassive;
         index = index - length(plActive);
      }

      if (lInv = $)
      {
         return $;
      }

      return Nth(lInv,index);
   }

   GetGuild()
   {
      return poGuild;
   }

   GetGuildHall()
   "Return this player's guild hall, or NIL if none"
   {
      local oGuild;
      oGuild = poGuild;

      if oGuild = $
      {
         return $;
      }

      return Send(oGuild, @GetGuildHall);
   }

   HasLeftAGuildTooRecently()
   {
      return (GetTime() < piGuildRejoinTimestamp);
   }

   SetGuildRejoinTime(delayMinutes=0)
   {
      piGuildRejoinTimestamp = GetTime() + (delayMinutes*60);

      return;
   }

   GetAnimation()
   {
      return piAnimation;
   }

   GetGender()
   {
      return piGender;
   }

   GetMaxHealth()
   {
      return piMax_health;
   }

   GetBaseMaxHealth()
   {
      return piBase_max_health;
   }

   GetLevel()
   {
      return Send(self,@GetBaseMaxHealth);
   }

   GetKillTarget()
   {
      return poKill_target;
   }

   GetTarget()
   {
      return poKill_target;
   }

   SetKillTarget(target=$)
   {
      poKill_target = target;

      return;
   }

   HealthTimer()
   {
      local iDifference;
      
      iDifference = bound(piMax_Health*100 - piHealth,-100,100);
      ptHealth = $;

      if iDifference > 0
      {
         Send(self,@GainHealth,#amount=iDifference,#precision=TRUE);
      }
      else
      {
         Send(self,@LoseHealth,#amount=-iDifference,#decay=TRUE,#precision=TRUE);
      }

      return;
   }

   EnchantmentTimer(timer = $)
   {
      local i, j, oEnchanter;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) >= ENCHANTMENT_LIST_STATE
               OR IsClass(Nth(i,2),&Boon)
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                 #type=ENCHANTMENT_PLAYER);

            % TODO: i no longer exists at this point?
            % EndEnchantment removing it?
            plEnchantments = DelListElem(plEnchantments,i);
            
            % Also remove from passive improvement list.
            foreach j in plPassiveImprovement
            {
               if First(j) = Nth(i,2)
               {
                  plPassiveImprovement = DelListElem(plPassiveImprovement,j);
               }
            }

            if IsClass(Nth(i,2),&Mirth)
               OR IsClass(Nth(i,2),&Melancholy)
            {
               Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
            }
            else
            {
               Send(self,@ResetPlayerFlagList,#who=self);
            }

            if poOwner <> $
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            if poOwner <> $
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   PeriodicEnchantmentTimer(timer = $)
   {
      local i ;

      foreach i in plEnchantments
      {
         if First(i) = timer
         {
            plEnchantments = DelListElem(plEnchantments,i);

            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,
                     #who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=$);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what=$,who=$,time=$,state=$,lastcall=TRUE,
                     addicon=TRUE,ltype=$,bItemCast=FALSE,iSpellPower=0)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else
      {
         if lastcall
         {
            oTimer = CreateTimer(self,@EnchantmentTimer,time);
         }
         else
         {
            oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
         }
      }

      if state = $
      {
         lNew_enchantment = [oTimer, what, iSpellPower];
      }
      else
      {
         lNew_enchantment = [oTimer, what, state, iSpellPower];
      }

      plEnchantments = Cons(lNew_enchantment,plEnchantments);

      % If we are also the source of the enchantment, add the enchantment
      % to our passive improvement list. ltype has the form:
      % [oSpell,Defensive,Offensive,Resistance]
      if who = self
         AND NOT bItemCast
      {
         plPassiveImprovement = Cons(ltype,plPassiveImprovement);
      }

      if IsClass(what,&Mirth)
         OR IsClass(what,&Melancholy)
      {
         Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
      }
      else
      {
         Send(self,@ResetPlayerFlagList,#who=self);
      }

      if addicon
      {
         Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
      }

      Post(self,@DrawResistances);

      return;
   }

   RemoveAllEnchantments(report=TRUE)
   "Remove all current enchantments and reset the passive improvement list."
   {
      local i;

      foreach i in plEnchantments
      {
         if NOT IsClass(Nth(i,2),&RadiusEnchantment)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      plPassiveImprovement = $;

      return;
   }

   RemoveAllRadiusEnchantments(report=TRUE)
   "Remove all current radius enchantments."
   {
      local i;

      foreach i in plRadiusEnchantments
      {
         Send(self,@RemoveRadiusEnchantment,#what=Nth(i,1),
               #iPower=Nth(i,2),#caster=Nth(i,3),#report=report);
      }

      plRadiusEnchantments = $;

      return;
   }

   RemoveAllPersonalEnchantments(report=TRUE,override=FALSE)
   "Remove all current *personal* enchantments and reset "
   "the passive improvement list."
   {
      local i, oSpell, removedSomething;

      removedSomething = FALSE;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsPersonalEnchantment)
            AND ((NOT IsClass(oSpell,&DMSpell)) OR override)
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
            removedSomething = TRUE;
         }
      }

      % Just to be sure, reset the player's flag list.
      % this should remove any excess flags like invis or shadowform.
      Send(self,@ResetPlayerFlagList);
      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=TRUE);

      plPassiveImprovement = $;

      return removedSomething;
   }

   FreezeAllEnchantments()
   "Called when a player logs off."
   {
      local i, iTime;

      if (piFlags & PFLAG_PHASED)
      {
         % Rare case where a user can log off while phased, e.g. system restart
         % Phase already froze the enchantments, so we don't need to do it again

         return;
      }

      foreach i in plEnchantments
      {
         % If we have the spectate enchantment, remove it.
         if IsClass(Nth(i,2),&Spectate)
         {
            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#report=FALSE);
            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);
            plEnchantments = DelListElem(plEnchantments,i);
            Send(self,@ResetPlayerFlagList,#who=self);

            continue;
         }

         if First(i) <> $
         {
            if NOT IsClass(Nth(i,2),&Boon)
            {
               % Convert timer to integer if we have a timer,
               % otherwise log for debugging.
               if IsTimer(First(i))
               {
                  iTime = GetTimeRemaining(First(i));
                  DeleteTimer(First(i));

                  % If it's a negative enchantment, add a bit to the time in
                  % order to prevent people from just "flashing" on and off
                  % to wait out an enchantment and be relatively unhittable.
                  if Send(Nth(i,2),@IsHarmful)
                  {
                     % Time is measured in milliseconds, 3000 = 3 seconds.
                     iTime = iTime + 3000;
                  }
               }
               else
               {
                  % We probably have an integer when we shouldn't have this
                  % here, and we should log it for debugging.
                  % $ values handed when the player logs in.
                  iTime = First(i);
                  Debug(self, " player ",Send(self,@GetTrueName),
                     " called FreezeAllEnchantments with invalid timer for ",
                     Send(Nth(i,2),@GetName), " timer value ",iTime);
               }

               SetNth(i,1,iTime);
            }
         }
      }

      return;
   }

   ReactivateAllEnchantments()
   "Called when a player logs on."
   {
      local i, tTimer, iTime, state;

      foreach i in plEnchantments
      {
         % Phase reactivates enchantments while it is still in plEnchantments
         if IsClass(Nth(i,2),&Phase)
            OR IsClass(Nth(i,2),&Spectate)
         {
            continue;
         }

         if IsClass(Nth(i,2),&Boon) = FALSE
         {
            state = $;
            if length(i) > ENCHANTMENT_LIST_NO_STATE
            {
               state = Nth(i,3);
            }

            iTime = First(i);

            if iTime = $
               OR IsTimer(iTime)
               OR iTime < 1
            {
               % Give them a short timer, and log this for debugging purposes.
               % We include timers since we're not supposed to have one here.
               Debug("Trying to make an invalid timer ",iTime," for ",
                     Send(Nth(i,2),@GetTrueName)," on player ",
                     self,Send(self,@GetTrueName));
               if Send(Nth(i,2),@IsHarmful)
               {
                  iTime = 5000;
               }
               else
               {
                  iTime = 20000;
               }
            }

            if Send(Nth(i,2),@IsPeriodic,#state=state,#who=self)
            {
               SetNth(i,1,CreateTimer(self,@PeriodicEnchantmentTimer,iTime));
            }
            else
            {
               SetNth(i,1,CreateTimer(self,@EnchantmentTimer,iTime));
            }

            Send(Nth(i,2),@RestartEnchantmentEffect,#who=self,#state=state);
         }
      }

      Send(self,@ResetPlayerFlagList,#who=self);

      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments 
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      % Kludgy, but oh well.  Not like any other code from this era is
      % exactly well-engineered or even "good", really.
      foreach i in plActive
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&NecromancerAmulet)
         {
            Send(each_obj,@DispelIllusions);
         }
      }

      return;
   }

   RemoveSchoolEnchantments(school = $,report=TRUE)
   {
      local i, oSpell, each_obj;

      foreach i in plEnchantments
      {
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }

      return;
   }

   RemoveEnchantment(what = $, report=TRUE)
   "If have a current enchantment set by <what>, end it."
   {
      local i,state;

      state = $ ;

      foreach i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if pbLogged_On
               OR IsClass(what,&Phase)
               OR IsClass(what,&Boon)
            {
               if First(i) <> $
               {
                  if IsTimer(First(i))
                  {
                     DeleteTimer(First(i));
                  }
                  SetNth(i,1,$);
               }
            }
            if Length(i) >= ENCHANTMENT_LIST_STATE
               OR IsClass(what,&Boon)
            {
               state = Nth(i,3);
            }

            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,
                  #state=state,#report=report);

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                  #type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i);

            if IsClass(what,&Mirth)
               OR IsClass(what,&Melancholy)
            {
               Send(self,@ResetPlayerFlagList,#nodraw=TRUE,#who=self);
            }
            else
            {
               Send(self,@ResetPlayerFlagList,#who=self);
            }
         }
      }

      % Also remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if First(i) = what
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      return;
   }

   RemoveEnchantmentClass(class = &Object)
   "If have a current enchantment set by anything in class, end it."
   {
      local i;

      % Remove from passive improvement list.
      foreach i in plPassiveImprovement
      {
         if IsClass(First(i),class)
         {
            plPassiveImprovement = DelListElem(plPassiveImprovement,i);
         }
      }

      % Rest of this now done in Battler.
      propagate;
   }

   GetPassiveImprovementList()
   "Returns the list of currently active, self-cast buffs, that "
   "the player is eligible to improve in passively."
   {
      return plPassiveImprovement;
   }

   SendEnchantmentIcons()
   "Users do this after GC to redisplay their enchantments"
   {
      local i,each_obj;

      foreach i in plEnchantments
      {
         each_obj = Nth(i,2);
         if NOT (IsClass(each_obj,&Seance)
            OR IsClass(each_obj,&IllusionaryWounds))
         {
            Send(self,@ShowAddEnchantment,#what=each_obj,
                  #type=ENCHANTMENT_PLAYER);
         }
      }

      if ptSecondWind <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSkillByNum,
            #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }
      if ptCrystalizeManaSurgeTimer <> $
      {
         Send(self,@ShowAddEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      }

      return;
   }

   AddAttackModifier(what = $)
   "Adds <what> to plAttack_modifiers, which can modify attack "
   "strength and damage."
   {
      plAttack_modifiers = Cons(what,plAttack_modifiers);
      Post(self,@DrawOffense);

      return;
   }

   RemoveAttackModifier(what = $)
   "Removes <what> from plAttack_modifiers."
   {
      local i;

      foreach i in plAttack_modifiers
      {
         if i = what
         {
            plAttack_modifiers = DelListElem(plAttack_modifiers,i);
            Post(self,@DrawOffense);

            return;
         }
      }

      % Karahol's Curse can get here, because it has to remove itself when
      % done, because it doesn't know if it was a normal ending or a
      % user-quit ending.

      return;
   }

   AddDefenseModifier(what = $)
   "Adds <what> to plDefense_modifiers, which can modify defense strength "
   "and damage."
   {
      plDefense_modifiers = Cons(what,plDefense_modifiers);
      Post(self,@DrawDefense);
      Post(self,@DrawArmor);

      return;
   }

   RemoveDefenseModifier(what = $)
   "Removes <what> from plDefense_modifiers."
   {
      local i, bFound;

      bFound = FALSE ;
      foreach i in plDefense_modifiers
      {
         if i = what
         {
            plDefense_modifiers = DelListElem(plDefense_modifiers,i);
            if pbLogged_on
            {
               Post(self,@DrawDefense);
               Post(self,@DrawArmor);
            }
            bFound = TRUE;

            return;
         }
      }

      if NOT bFound
      {
         Debug(self,"Tried to remove defense modifier",what,"but not in list",
               plDefense_modifiers);
      }

      return;
   }

   %
   % Squelch functions.
   %

   SquelchPlayer(value=$,type=PFLAG2_SQUELCHED_ALL)
   "Sets if a player can communicate or not.  Toggles condition by default."
   {
      local bSquelched;

      bSquelched = value;

      if bSquelched = $
      {
         % Toggle the current state.
         bSquelched = NOT Send(self,@CheckPlayerFlag,#flag=type,#flagset=2);
      }

      Send(self,@SetPlayerFlag,#flag=type,#value=bSquelched,#flagset=2);

      return bSquelched;
   }

   TrySay()
   "Called when user wants to say something. Return TRUE/FALSE.  "
   "If this returns FALSE, it will also block broadcasts and guild sends."
   {
      if piFlags2 & PFLAG2_SQUELCHED_SAYS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      return TRUE;
   }

   TryBroadcast()
   "Called when the user wants to broadcast a string.  Return True/False, "
   "and use some mana too."
   {
      local iCost;

      if piFlags2 & PFLAG2_SQUELCHED_BCAST
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      if NOT Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
         AND NOT IsClass(self,&DM)
      {
         iCost = piMana * Send(SETTINGS_OBJECT,@GetBroadcastManaCost) / 100;
         if piMana < iCost
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_broadcast);

            return FALSE;
         }
         Send(self,@LoseMana,#amount=iCost);
      }

      return TRUE;
   }

   TrySayGroup(users=$)
   "Called when the user wants to say a string to a list of people.  Return True/False, "
   "and use some mana too."
   {
      if piFlags2 & PFLAG2_SQUELCHED_TELLS
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      if NOT IsClass(self,&DM)
      {
         Send(self,@LoseMana,#amount=1);
      }

      return TRUE;
   }

   %
   % End squelch functions.
   %

   CheckPosition(what=$,type=$,space=0)
   {
      local i, iSpace;

      if space = 0 OR type = $ OR what = $
      {
         return FALSE;
      }

      iSpace = space;
      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & type
         {
            iSpace = iSpace - Send(i,@GetItemUseAmount);
         }
      }

      if iSpace < Send(what,@GetItemUseAmount)
      {
         if IsClass(what,&Token) OR IsClass(what,&Totem)
         {
            return FALSE;
         }

         % These unequip amongst themselves automatically.
         if IsClass(what,&DefenseModifier)
            OR IsClass(what,&Gauntlet)
         {
            return TRUE;
         }

         if type = ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full_hands);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full);
         }

         return FALSE;
      }

      return TRUE;
   }

   TryUseItem(what = $)
   {
      local i,iSpace,iUse_type;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      if (piFlags & PFLAG_MORPHED)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return FALSE;
      }

      if IsClass(what,&ReagentBag)
      {
         if Send(what,@GetReagentBagContents) = $
         {
            Send(self,@MsgSendUser,#message_rsc=player_regbag_empty);

            return FALSE;
         }

         Send(self,@UserObjectContents,#what=what);

         return TRUE;
      }

      iUse_type = Send(what,@GetItemUseType);

      if iUse_type & ITEM_SINGLE_USE
      {
         return Send(self,@TryApplyItem,#what=what,#apply_on=self);
      }

      if iUse_type & ITEM_BROKEN
      {
         Send(self,@MsgSendUser,#message_rsc=player_use_broken,
               #parm1=Send(what,@GetDef),
               #parm2=Send(what,@GetName));

         return FALSE;
      }

      if iUse_type & ITEM_CANT_USE
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);

         return FALSE;
      }

      if NOT Send(what,@ReqUse,#what=self)
      {
         return FALSE;
      }

      % make sure nothing in room disallows
      if poOwner <> $
         AND NOT Send(poOwner,@ReqSomethingUse,#what=self,#use_item=what)
      {
         return FALSE;
      }

      % make sure not already using or something using disallows
      foreach i in plUsing
      {
         if i = what
         {
            Send(self,@MsgSendUser,#message_rsc=player_using_already);

            return FALSE;
         }

         if NOT Send(i,@ReqUseSomething,#what=what)
         {
            return FALSE;
         }
      }

      if (iUse_type & ITEM_USE_HAND)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HAND,#space=viHand_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_BODY)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_BODY,#space=viBody_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_NECK)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_NECK,#space=viNeck_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_QUIVER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_QUIVER,#space=viQuiver_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_FINGER)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_FINGER,#space=viFinger_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_GAUNTLET)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_GAUNTLET,#space=viGauntlet_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_HEAD)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_HEAD,#space=viHead_space)
      {
         return FALSE;
      }

      if (iUse_type & ITEM_USE_LEGS)
         AND NOT Send(self,@CheckPosition,#what=what,
                     #type=ITEM_USE_LEGS,#space=viLeg_space)
      {
         return FALSE;
      }

      plUsing = Cons(what,plUsing);
      Send(self,@NewUsing,#what=what);
      Send(what,@NewUsed,#what=self);

      if poOwner
      {
         Send(poOwner,@SomethingUsed,#what=self,#use_item=what);
      }

      Send(self,@ResetPlayerFlagList);
      Post(self,@DrawResistances);

      return TRUE;
   }

   TryUnuseItem(what = $)
   {
      local bFound, i;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_use);

         return FALSE;
      }

      bFound = FALSE;

      %check and see if item disallows
      foreach i in plUsing
      {
         if i = what
         {
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         % This can happen if TryUnuseItem is called in, for example,
         % a ring of invisibility when you log off.
         return FALSE;
      }

      if Send(what,@ReqUnuse)
      {
         Post(self,@ResetPlayerFlagList);

         return Send(self,@UnuseItem,#what=what);
      }

      return FALSE;
   }

   UnuseItem(what = $, Recalibrate = FALSE)
   {
      local i;

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            Send(self,@NewUnusing,#what=what);
            
            if Recalibrate
            {
               Send(what,@NewUnused,#what=self,#Recalibrate=TRUE);
            }
            else
            {
               Send(what,@NewUnused,#what=self);
            }

            if pbLogged_on
            {
               Post(self,@DrawResistances);
            }

            return TRUE;
         }
      }

      Send(self,@MsgSendUser,#message_rsc=player_not_using);

      return FALSE;
   }

   TryApplyItem(what = $,apply_on = $)
   {
      local i,iUse_type;

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
               #parm1=Send(what,@GetName));

         return FALSE;
      }

      iUse_type = Send(what,@GetItemUseType);
      if iUse_type <> ITEM_SINGLE_USE
      {
         if iUse_type = ITEM_BROKEN
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_broken,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_apply,
                  #parm1=Send(what,@GetIndef),#parm2=Send(what,@GetName));
         }

         % Error
         return FALSE;
      }

      % make sure nothing in room disallows
      if NOT Send(poOwner,@ReqSomethingApply,#what=self,#use_item=what,#apply_on=apply_on)
      {
         return FALSE;
      }

      if Send(what,@ReqNewApply,#what=self,#apply_on=apply_on)
      {
         Send(what,@NewApplied,#what=self,#apply_on=apply_on);
         Send(poOwner,@SomethingApplied,#what=self,#use_item=what,#apply_on=apply_on);
      }

      Send(self,@ResetPlayerFlagList);

      return TRUE;
   }

   CanAdvance()
   {
      return TRUE;
   }

   AllowPlayerAttack(victim=$,stroke_obj=$,use_weapon=$,report=TRUE,
                     actual=TRUE,minion=FALSE)
   "Will not let a person attack someone who isn't pkill_enabled."
   "Will not let a person who isn't pkill_enabled attack another person."
   {
      local oRoom, oGuild, oVictimGuild;

      % Default location to check is where we are.
      oRoom = poOwner;

      % If the victim is in a room, then check that location instead.  This
      % allows distance attacks (like wall spells) to work properly.
      if victim <> $
         AND Send(victim,@GetOwner) <> poOwner
      {
         oRoom = Send(victim,@GetOwner);
      }

      % No attacking logged out players under any circumstances
      if Send(victim,@GetOwner) = $
      {
         return FALSE;
      }

      % Can always attack Escaped Convict regardless of room
      if IsClass(victim,&EscapedConvict)
      {
         return TRUE;
      }

      % But Escaped Convict can also fight back!
      if IsClass(self,&EscapedConvict)
      {
         return TRUE;
      }

      % Make sure room allows the attack. Check if room has
      % special combat affects.
      if actual
         AND NOT Send(oRoom,@ReqSomethingAttack,#what=self,#victim=victim,
                     #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                     #report=report,#actual=actual)
      {
         return FALSE;
      }

      % Don't halo non-attackables in guild_pk_only zones (typically an
      % unguilded outlaw). Necessary because it just looks confusing
      if NOT actual
         AND NOT Send(oRoom,@AllowGuildAttack,#what=self,#victim=victim)
      {
         return FALSE;
      }

      % If we're in an arena and it let us attack, then it's a legal attack.
      if Send(oRoom,@IsArena)
      {
         return TRUE;
      }
      
      if Send(oRoom,@GetChaosZone)
      {
         return TRUE;
      }

      % Frenzies!  Anything goes if allowed by the room!
      if Send(SYS,@GetChaosNight)
      {
         if Send(Send(SYS,@GetWarEvent),@IsActive)
         {
            % If there's a war event going, disallow attacks between teammates.
            if Send(Send(SYS,@GetWarEvent),@IsSameSide,#player1=self,#player2=victim)
               AND NOT Send(Send(SYS,@GetWarEvent),@CanAttackAllies)
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }

               return FALSE;
            }
         }

         return TRUE;
      }

      % Check for guildmates and allies
      if IsClass(victim,&Player)
         AND victim <> self
      {
         oVictimGuild = Send(victim,@GetGuild);
         oGuild = poGuild;
         if oVictimGuild <> $
            AND oGuild <> $
            AND (oGuild = oVictimGuild
               OR Send(oGuild,@IsAlly,#otherguild=oVictimGuild))
         {
            if report
            {
               if oGuild = oVictimGuild
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_guildmate,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
               if Send(oGuild,@IsAlly,#otherguild=oVictimGuild)
               {
                  Send(self,@MsgSendUser,#message_rsc=cannot_attack_ally,
                        #parm1=Send(victim,@GetName),
                        #parm2=Send(victim,@GetHeShe));
               }
            }

            return FALSE;
         }
      }

      % Check for temporary safety flag.
      if IsClass(victim,&Player)
         AND ((piFlags & PFLAG_TEMPSAFE)
            OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_TEMPSAFE))
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                  #parm1=Send(victim,@GetDef),
                  #parm2=Send(victim,@GetName));
         }

         return FALSE;
      }

      % Can always attack mortal event characters.
      if IsClass(victim,&DM)
         AND Send(victim,@IsEventCharacter)
         AND NOT Send(victim,@PlayerIsImmortal)
      {
         return TRUE;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         if report
         {
            Send(self,@MsgSendUser,#message_rsc=cannot_attack_phased_self_rsc);
         }
         return FALSE;
      }

      if IsClass(victim,&Player)
         AND Send(victim,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      if IsClass(victim,&Monster)
      {
         if IsClass(victim,&Reflection)
            OR IsClass(victim,&EvilTwin)
            OR Send(victim,@GetMaster) <> $
         {
            if NOT (piFlags & PFLAG_PKILL_ENABLE)
            {
               if report
               {
                  Send(self,@MsgSendUser,
                        #message_rsc=player_cant_hit_newbie_minion);
               }

               return FALSE;
            }

            if Send(victim,@GetMaster) = self
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=player_own_minion);
               }

               return FALSE;
            }

            % Check status and safety against the owner of the minion.
            if NOT IsClass(oRoom,&GuildHall)
            {
               if NOT Send(self,@AllowPlayerAttack,
                           #victim=Send(victim,@GetMaster),
                           #use_weapon=use_weapon,#stroke_obj=stroke_obj,
                           #report=report,#actual=actual,#minion=TRUE)
               {
                  return FALSE;
               }
            }
         }

         if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                     #parm1=Send(victim,@GetName));
            }

            return FALSE;
         }

         % No attacking pets on Sacred Haven
         if NOT Send(SYS,@IsPKAllowed)
            AND Send(victim,@GetMaster) <> $
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                    #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
            }

            return FALSE;
         }
      }
      else
      {
         % Not a monster; is a player.

         % No player attacks on Sacred Haven, but allow DM attacks for events.
         if NOT Send(SYS,@IsPKAllowed)
            AND NOT IsClass(victim,&DM)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safe_server);
            }

            return FALSE;
         }

         % This prevents attacks on immortal DMs.
         if NOT Send(victim,@IsLikelyVictim)
         {
            return FALSE;
         }

         if NOT Send(oRoom,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
         {
            if NOT (piFlags & PFLAG_PKILL_ENABLE)
            {
               % A newbie (someone below GetPKillEnableHP) tried to attack
               % another player! note that this does not affect murderers
               % who have been knocked below this level by angry retributers.

               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_cant_hit_newbie);
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }
            
               return FALSE;
            }

            if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
            {
               % The target is a newbie. Murderers are perfectly attackable
               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                           #parm1=Send(victim,@GetDef),
                           #parm2=Send(victim,@GetName));
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }

               return FALSE;
            }
         }
      }

      if IsClass(oRoom,&GuildHall)
      {
         return TRUE;
      }

      % Truce itself returns TRUE, not counting as an attack. 
      % Truce will only block actual attacks between two players who 
      % are both Truced.
      if stroke_obj <> $
         AND IsClass(stroke_obj,&Truce)
      {
         return TRUE;
      }
      else
      {
         if (Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Truce))
         {
            if (IsClass(victim,&Monster)
               OR (IsClass(victim,&User)
                  AND Send(victim,@IsAffectedByRadiusEnchantment,
                           #byClass=&Truce)))
               AND actual
            {
               if report
               {
                  Send(self,@MsgSendUser,#message_rsc=player_truced);
               }

               return FALSE;
            }
         }
      }

      % Finally, check status and safety.
      if NOT Send(self,@CheckStatusAndSafety,#victim=victim,
                  #report=report,#actual=actual,#minion=minion)
      {
         return FALSE;
      }

      % Stop any rescue attempts if the user makes an attack.
      if ptRescue <> $
         AND actual
      {
         Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue);
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return TRUE;
   }

   CheckStatusAndSafety(victim=$,report=TRUE,actual=TRUE,minion=FALSE)
   "CF_SAFETY_OFF prevents accidental attacks. You can always successfully "
   "hit a murderer or outlaw, though."
   {
      local oEnemyGuild, oSoldierShield;

      % Don't care about monsters.
      % And, free attacks on token holders.
      if IsClass(victim,&Monster)
         OR (Send(victim,@FindUsing,#class=&Token) <> $)
      {
         % Unless they're factioned.
         if NOT Send(self,@CheckFactionAttack,#what=victim,#report=report)
         {
            return FALSE;
         }

         return TRUE;
      }

      % We don't penalize you for trying to hurt yourself.
      % Also don't care about Morphed or Anonymous players.
      if (victim = self)
         OR (IsClass(victim,&Player)
            AND (Send(victim,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_MORPHED)))
      {
         return TRUE;
      }
      
      % No penalties for chaos zone battles
      if poOwner <> $
         AND Send(victim,@GetOwner) <> $
         AND IsClass(poOwner,&Room)
         AND IsClass(Send(victim,@GetOwner),&Room)
         AND Send(poOwner,@GetChaosZone)
         AND Send(Send(victim,@GetOwner),@GetChaosZone)
      {
         return TRUE;
      }

      oEnemyGuild = Send(victim,@GetGuild);
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      % Check for enemy guild or faction soldier fighting - If attacking a (mutual)
      %  enemy, then they can whack on each other freely, without outlaw penalty
      %  or faction loss.
      if (poGuild <> $
            AND oEnemyGuild <> $
            AND Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
         OR (oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#who=victim,#what=self,
                      #damage=FALSE))
      {
         % Okay, attack is against a player, so record the time
         if actual = TRUE
         {
            piTimeAttackedPlayer = GetTime();
         }

         return TRUE;
      }

      % Check to see if we deserve to be an outlaw.
      if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         AND NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
      {
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
         {
            % If your opponent is not a murderer or outlaw, you must
            % have your 'safety' off to attack anyone.
            if report
            {
               if IsClass(self,&Guest)
               {
                  Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                       #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  if minion
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safety_caught_minion,
                           #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                           #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
                  }
               }
            }

            return FALSE;
         }
         else
         {
            if NOT (piFlags & PFLAG_MURDERER)
               AND NOT (piFlags & PFLAG_OUTLAW)
               AND actual = TRUE
            {
               % attacking someone who is without fault is cause to
               % gain the outlaw flag.
               if minion
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor_minion,
                        #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=player_aggressor);
               }
               Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=TRUE);
               Send(self,@EvaluatePKStatus,#dbug=TRUE);
            }
         }
      }

      % Check for faction loss.  Handles appropriate conditions.
      if actual = TRUE
         AND NOT Send(self,@CheckFactionAttack,#what=victim,#report=report)
      {
         return FALSE;
      }

      % Okay, attack is against a player, so record the time
      if actual = TRUE
      {
         piTimeAttackedPlayer = GetTime();
      }

      return TRUE;
   }

   CheckFactionAttack(what=$,report=TRUE)
   "Checks if you are attacking something in the same faction as you are. "
   "Boots you out of your faction if you attack an innocent or a monster. "
   "Safety will catch a bad attack, however."
   {
      local bBooted, rMessage;

      % If attacking nothing, or faction is neutral, or attacking self
      %   or in the Arena, or during a Frenzy, don't go any further.
      if what = $
         OR piFaction = FACTION_NEUTRAL
         OR what = self
         OR (poOwner <> $ AND Send(poOwner,@IsArena))
         OR Send(SYS,@GetChaosNight)
      {
         return TRUE;
      }

      bBooted = FALSE;

      % If faction loss is disabled, then attacking a user never boots you
      if Send(SYS, @GetServerFlag, #flag = SERVER_FLAG_DISABLE_FACTION_LOSS)
         AND IsClass(what, &User) 
      {
         return TRUE;
      }

      % Checking for faction alignment. If you attack something of your
      % own faction, you get busted!
      if (Send(what,@GetFaction) = piFaction)
      {
         % Attacks vs. Outlaws, Murderers are not punishable by booting,
         % so just return. Also, attacks vs. anonymous or morphed people
         % are not punishable.
         if (IsClass(what,&User))
            AND (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
         {
            return TRUE;
         }

         bBooted = TRUE;
         rMessage = player_faction_attacked;
      }

      % Preying on non-intriguing, white-named newbies boots ya, too.
      if IsClass(what,&User)
         AND NOT Send(what,@PlayerIsIntriguing)
         AND NOT (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW))
      {
         bBooted = TRUE;
         rMessage = player_non_intriguing_attacked;
      }

      if bBooted
      {
         % Check for safety before booting.
         if NOT Send(self,@CheckPlayerPreference,#flag=CF_SAFETY_OFF)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }

            return FALSE;
         }

         % Get booted.
         Send(self,@MsgSendUser,#message_rsc=rMessage);
         Send(self,@ResignFaction);
      }

      return TRUE;
   }

   GetLastPlayerAttackTime()
   "Returns the last time the player attacked another player."
   {
      return piTimeAttackedPlayer;
   }

   CanHelpPlayer()
   "Checks to see if can be affected by spells cast by angeled characters."
   {
      if (piTimeAttackedPlayer + ATTACKED_PLAYER_WAIT) > GetTime()
         AND NOT Send(SYS,@GetChaosNight)
      {
         return FALSE;
      }

      return TRUE;
   }

   TryAttack(what = $,use_weapon = $,stroke_obj=$)
   {
      local i, iRange, lWindsState, lSandstormState;

      % Can't target self.
      if what = self
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_target_self);
         
         return FALSE;
      }

      % Check attack time.
      if NOT Send(self,@IsOkayAttackTime)
      {
         return FALSE;
      }

      % Is it in the same room?
      if poOwner <> Send(what,@GetOwner) 
      {
         return FALSE;
      }

      % Holding a token?  Then don't let them attack
      if send(self,@FindHolding,#class=&Token) <> $
      {
         return FALSE;
      }

      % If we have minions, see if they can attack too
      Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);

      % Can pay costs?  Only check for skills, spells have already been cast.
      if IsClass(stroke_obj,&Skill)
         AND NOT Send(stroke_obj,@CanPayCosts,#who=self,#oTarget=what)
      {
         return FALSE;
      }

      % Deny attack if no line of sight
      if NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);
         return FALSE;
      }

      % Send to the STROKE to get the range; unarmed attacks have ranges too
      iRange = Send(stroke_obj,@GetRange,#weapon_used=use_weapon);

      % A little fudge factor to account for lag drift, etc.
      %  Don't fudge for ranged weapons.
      if IsClass(what,&User) AND Send(what,@HasMovedRecently)
         AND (use_weapon <> $ AND NOT IsClass(use_weapon,&RangedWeapon))
      {
         iRange = iRange + RANGE_MOVEMENT_BONUS;
      }

      if NOT Send(self,@TargetWithinSightAndRange,#oTarget=what,#iRange=iRange,
                  #use_weapon=use_weapon,#stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      % Special case assassin's daggers
      if use_weapon <> $
         AND IsClass(use_weapon,&BlackDagger)
         AND IsClass(stroke_obj,&Stroke)
      {
         % Let the assassin's game handle it
         return Send(Send(SYS,@GetAssassinGame),@TryAssassinAttack,
                     #attacker=self,#target=what,#dagger_obj=use_weapon);
      }

      if IsClass(what,&Monster)
      {
         % Check if its a non hittable monster
         if NOT Send(what,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                     #use_weapon=use_weapon)
         {
            return FALSE;
         }
         else
         {
            if NOT Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Jig)
            {
               % Tell the monster this is a valid attack.
               Send(what,@ValidAttack,#who=self);
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=Jig_cannot_attack,
                     #parm1=Send(what,@GetName));

               return FALSE;
            }
         }
      }

      % Checking for legal PK attack here.
      if NOT Send(self,@AllowPlayerAttack,#victim=what,#stroke_obj=stroke_obj,
                  #use_weapon=use_weapon)
      {
         return FALSE;
      }

      % If this attack initiates pvp, notify victim (combatants maybe?) 
      % initially, but then not again until PVP_NOTIFY_DECAY has passed
      
      if IsClass(what,&User) 
         AND Send(what, @GetLastPvpWarned) < GetTime() - PVP_NOTIFY_DECAY
      {
         Send(what,@DoPvpNotify);
      }
      
      % Special stroke stuff 
      if NOT Send(stroke_obj,@CheckSpecial,#who=self,#victim=what)
      {
         return FALSE;
      }

      % Okay, checking is done, attack is okay.  Do the animation thing.
      if NOT Send(stroke_obj,@CheckWeaponAndDoAnimation,#who=self,
                  #weapon_used=use_weapon,#victim=what)
      {
         return FALSE;
      }

      % Switching targets?
      % Do this before paying skill costs, otherwise projectiles
      % will try to find our "kill target" and fail.
      if poKill_target <> what
      {
         Send(self,@ResetGainFlags);
         poKill_target = what;
      }

      % Pay costs here. Only check skills, because spells are already cast.
      if IsClass(stroke_obj,&Skill)
      {
         Send(stroke_obj,@PayCosts,#who=self);
      }

      % Special case:  Ranged weapons in windy room.
      %  Do this after paying the costs so that the arrow is used.
      if use_weapon <> $ AND IsClass(use_weapon,&RangedWeapon)
      {
         lWindsState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Winds);
         lSandStormState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                                 #byClass=&SandStorm);

         if lWindsState <> $
            AND Send(Nth(lWindsState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lWindsState,2))
         {
            return FALSE;
         }

         if lSandStormState <> $
            AND Send(Nth(lSandStormState,1),@TryRuinShot,#who=self,
                     #iSpellPower=Nth(lSandStormState,2))
         {
            return FALSE;
         }
      }

      Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
            #use_weapon=use_weapon,#stroke_obj=stroke_obj);

      % Record the swing for potential advancement.
      if Send(what,@CanPlayerAdvanceOnMe)         
      {
         % We got another swing in, so increment that.
         Send(self,@SwingWeapon,#times=1);
      }

      % Give offensive buffs a small chance to improve each swing!
      foreach i in plPassiveImprovement
      {
         if Nth(i,3) AND random(1,50) = 50
         {
            Send(First(i),@ImproveAbility,#who=self,#target=what);
         }
      }

      propagate;
   }

   % Determines if target is within attacking range, and within sight.
   % iRange=$ means there's no range check.
   TargetWithinSightAndRange(oTarget=$,iRange=$,use_weapon=$,stroke_obj=$)
   {
      local iSquareRange, iDist, oTargetOwner, oFinalTarget, iAngle,
            iRow, iCol, iTargetRow, iTargetCol;

      oTargetOwner = Send(oTarget,@GetOwner);

      % We are always in range of ourselves or anything we carry.
      if oTarget = self
         OR oTargetOwner = self
      {
         return TRUE;
      }

      oFinalTarget = oTarget;

      % Strange case of us targeting something that someone else is holding.
      % This cannot be owned by us, since we already checked that.
      if oTargetOwner <> $
         AND IsClass(oTargetOwner,&Battler)
      {
         oFinalTarget = oTargetOwner;
         oTargetOwner = Send(oFinalTarget,@GetOwner);
      }

      % If we don't share the same owner, then we're not in range.
      if poOwner <> oTargetOwner
      {
         return FALSE;
      }

      iDist = Send(self,@SquaredFineDistanceTo3D,#what=oFinalTarget);

      % See if target is within range, if we provided a range.
      if iRange <> $
      {
         iSquareRange = iRange;
         iSquareRange = iSquareRange * iSquareRange;

         if iDist > iSquareRange
         {
            Send(self,@SendAttackOutOfRangeMessage,#what=oFinalTarget,
                 #use_weapon=use_weapon,#stroke_obj=stroke_obj);

            return FALSE;
         }
      }

      % See if target is in a reasonable viewing area.
      % Only applies to weapon strokes and single-target spells.
      if IsClass(oFinalTarget,&Battler)
         AND stroke_obj <> $
         AND (IsClass(stroke_obj,&Stroke)
            OR (IsClass(stroke_obj,&Spell)
               AND Send(stroke_obj,@GetNumSpellTargets) = 1))
      {
         iAngle = Send(self,@GetAngle);
         iRow = piRow;
         iCol = piCol;
         iTargetRow = Send(oTarget,@GetRow);
         iTargetCol = Send(oTarget,@GetCol);

         % What this does:
         % Basically, it finds your direction and makes sure you aren't trying to target
         % something behind you. "Behind you" is defined as behind the line defined
         % by the cardinal directions that are the closest to being perpendicular to the
         % player's direction vector. For example, if you're facing mostly east, then
         % the cardinal direction direction line runs north/south; in essense, anything
         % that is further west than you is "behind" you. The more interesting cases
         % are when the player is facing one of the corner directions. We calculate
         % the equation of the line using the point-slope formula and determine which
         % side of the line the target is.
         % Equation of the SW-NE line: iTargetRow - iRow = iCol - iTargetRow
         % Equation of the SE-NW line: iTargetRow - iRow = iTargetCol - iCol
         if iDist > 1
            AND (((iAngle > ANGLE_ENE OR iAngle <= ANGLE_ESE)
                  AND iTargetCol < iCol)
               OR (iAngle > ANGLE_ESE AND iAngle <= ANGLE_SSE
                  AND (iTargetRow - iRow) < (iCol - iTargetCol))
               OR (iAngle > ANGLE_SSE AND iAngle <= ANGLE_SSW
                  AND iTargetRow < iRow)
               OR (iAngle > ANGLE_SSW AND iAngle <= ANGLE_WSW
                  AND (iTargetRow - iRow) < (iTargetCol - iCol))
               OR (iAngle > ANGLE_WSW AND iAngle <= ANGLE_WNW
                  AND iTargetCol > iCol)
               OR (iAngle > ANGLE_WNW AND iAngle <= ANGLE_NNW
                  AND (iTargetRow - iRow) > (iCol - iTargetCol))
               OR (iAngle > ANGLE_NNW AND iAngle <= ANGLE_NNE
                  AND iTargetRow > iRow)
               OR (iAngle > ANGLE_NNE AND iAngle <= ANGLE_ENE
                  AND (iTargetRow - iRow) > (iTargetCol - iCol)))
         {
            if iDist > 2
               AND IsClass(oFinalTarget,&Player)
               AND Send(self,@CheckLog)
            {
               Debug("ALERT! ",Send(self,@GetTrueName),self," at "
                     "[",iRow,iCol,"] and angle ",iAngle," tried to hit ",
                     Send(oFinalTarget,@GetTrueName),oFinalTarget," at "
                     "[",iTargetRow,iTargetCol,"] that was behind them.");
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);

            return FALSE;
         }
      }

      return TRUE;
   }

   % This returns the battler's ability to-hit.  Ranges from 1 to 1000
   GetOffense(what = $, stroke_obj=$)
   {
      local i, oWeapon, iStroke, iProficiency, iAim, iOffense,
            oMonster, lRadiusState;

      oWeapon = $;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iOffense = Send(oMonster,@GetOffense,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         % A player's offense is based on his stroke (basic),
         % proficiency (advanced) skills, aim and max hps.
         oWeapon = Send(self,@GetWeapon);

         if oWeapon <> $
         {
            % Get weapon's numbers.
            iStroke = Send(oWeapon,@GetStroke,#who=self);
            iProficiency = Send(oWeapon,@GetProf,#who=self);
         }
         else
         {
            % Unarmed
            iStroke = Send(self,@GetSkillAbility,#skill_num=SKID_PUNCH);
            iProficiency = Send(self,@GetSkillAbility,#skill_num=SKID_BRAWLING);
         }

         iAim = Send(self,@GetAim);
         iOffense = (iStroke*2) + (iProficiency*2) + (iAim*8) +
               (200 * piBase_Max_Health)/(100 + Send(self,@GetStamina));

         if oWeapon <> $
         {
            iOffense = Send(oWeapon,@ModifyHitRoll,#target=what,
                  #hit_roll=iOffense);
         }
      }

      % List of items and spells that affect chance-to-hit
      foreach i in plAttack_modifiers
      {
         iOffense = Send(i,@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#stroke_obj=stroke_obj);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Mirth);
         iOffense = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#lRadiusState=lRadiusState);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
               #byClass=&Melancholy);
         iOffense = Send(Nth(lRadiusState,1),@ModifyHitRoll,#who=self,#what=what,
                        #hit_roll=iOffense,#lRadiusState=lRadiusState);
      }

      iOffense = iOffense + Send(Send(SYS,@GetParliament),
                                 @GetFactionHitrollBonus,#who=self);

      % If we're using a ranged weapon and don't have a clear line of sight,
      %  then half our offense.
      if what <> $
         AND oWeapon <> $
         AND IsClass(oWeapon,&RangedWeapon)
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         AND NOT (IsClass(self,&DM) AND Send(self,@PlayerIsImmortal))
      {
         Send(self,@MsgSendUser,#message_rsc=bad_line_of_sight);
         iOffense = iOffense / 2;
      }

      return Bound(iOffense,1,2000);
   }

   GetDefense(what = $, stroke_obj=$)
   "This returns the battler's ability to avoid being hit. "
   "Ranges from 1 to 2000."
   {
      local i, oWeapon, oShield, iParry, iDodge, iBlock, iAgility,
            iDefense, iHealth, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDefense = Send(oMonster,@GetDefense,#what=what,
                        #stroke_obj=stroke_obj);
      }
      else
      {
         % A player's defense is based on his dodge, parry,
         % block skills, agility, and max hps.
         iParry = 0;
         iDodge = 0;
         iBlock = 0;

         % Ask the weapon, it might give a bonus to parrying.
         iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);

         % Ask the shield, it might give a bonus to block.
         iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);

         iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);

         iAgility = Send(self,@GetAgility);

         % Bind health between 20-150 for defense calculation.
         iHealth = Bound(piBase_Max_Health,20,150);

         iDefense = iParry + iBlock + (iDodge*2) + (iAgility*8)
                     + (200 * iHealth)/(100 + Send(self,@GetStamina));
      }

      foreach i in plDefense_modifiers
      {
         iDefense = Send(i,@ModifyDefensePower,#who=self,
                           #what=what,#defense_power=iDefense);
      }

      foreach i in plRadiusEnchantments
      {
         iDefense = Send(Nth(i,1),@ModifyDefensePower,#attacker=what,
                     #iPower=Nth(i,2),#caster=Nth(i,3),#defense_power=iDefense);
      }

      iDefense = iDefense + Send(Send(SYS,@GetParliament),
                                 @GetFactionDefenseBonus,#who=self);

      return Bound(iDefense,1,2000);
   }

   % The next three messages deal with the three defense skills.  These
   % messages return the relative values of the three skills.  Used in
   % player for defense, used in battler for defense messages.
   GetParryAbility(stroke_obj=$)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetParryAbility,#stroke_obj=stroke_obj);
      }

      oWeapon = Send(self,@GetWeapon);
      if oWeapon = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_PARRY),
                     @CanPayCosts,#who=self)
         OR (stroke_obj <> $ AND NOT Send(stroke_obj,@CanParry))
      {
         return 0;
      }

      return Send(oWeapon,@GetParryAbility,#who=self);
   }

   GetBlockAbility(stroke_obj=$)
   {
      local oShield, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         % Should only be one morph enchantment on the player.
         return Send(oMonster,@GetBlockAbility,#stroke_obj=stroke_obj);
      }

      oShield = Send(self,@LookupPlayerShield);
      if oShield = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_BLOCK),
                     @CanPayCosts,#who=self)
         OR ((stroke_obj <> $) AND NOT Send(stroke_obj,@CanBlock))
      {
         return 0;
      }

      return Send(oShield,@GetBlockAbility,#who=self);
   }

   GetDodgeAbility(stroke_obj=$)
   {
      local oMonster;

      if stroke_obj <> $ AND NOT Send(stroke_obj,@CanDodge)
      {
         return 0;
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
         AND NOT (piFlags & PFLAG_NO_MOVE)
      {
         return Send(oMonster,@GetDodgeAbility,#stroke_obj=stroke_obj);
      }

      if Send(Send(sys,@FindSkillByNum,#num=SKID_DODGE),@CanPayCosts,#who=self)
      {
         return Send(self,@GetSkillAbility,#skill_num=SKID_DODGE);
      }

      return 0;
   }

   % This returns the damage done to target "what" before resistances.
   GetDamage(what = $, stroke_obj=$)
   {
      local i, iDamage, oStroke, oWeapon, iStrokeNum, iModBonus, iDamageBonus,
            oSpell, oMonster, lRadiusState;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         iDamage = Send(oMonster,@GetDamage,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         oStroke = stroke_obj;
         if stroke_obj = $
         {
            oWeapon = Send(self,@GetWeapon);
            if oWeapon = $
            {
               oStroke=Send(SYS,@FindSkillByNum,#num=SKID_PUNCH);
            }
            else if IsClass(oWeapon,&Weapon)
            {
               oStroke=Send(SYS,@FindSkillByNum,
                     #num=Send(oWeapon,@GetDefaultStrokeNumber));
            }
            else
            {
               % It's a spell, use it as the stroke object.
               oStroke = oWeapon;
            }
         }

         % Currently considers the damage of the weapon and player's might.
         % Stroke sets damage
         iDamage = Send(oStroke,@FindDamage,#weapon_used=Send(self,@GetWeapon),
                        #who=self,#victim=what); 
      }

      % Spells and attmods that modify damage
      iDamageBonus = 0;
      foreach i in plAttack_modifiers
      {
         % Attack modifiers return the total damage, subtract out the original
         %  damage to get the damage bonus.
         iModBonus = Send(i,@ModifyDamage,#who=self,#what=what,#damage=iDamage,
                          #stroke_obj=oStroke);
         iDamageBonus = iDamageBonus + (iModBonus - iDamage);

         Send(i,@WeaponHitTarget);
      }

      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Melancholy)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Melancholy);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus);
      }
      if Send(self,@IsAffectedByRadiusEnchantment,#byClass=&Mirth)
      {
         lRadiusState = Send(self,@GetMostPowerfulRadiusEnchantmentState,
                              #byClass=&Mirth);
         iDamageBonus = Send(Nth(lRadiusState,1),@ModifyDamage,#who=self,
                              #what=what,#damage=iDamageBonus);
      }

      iDamageBonus = iDamageBonus + Send(Send(SYS,@GetParliament),
                                          @GetFactionDamageBonus,#who=self);

      % Convert to high precision. Super dirty, will be cleaned up shortly.
      iDamageBonus = iDamageBonus*100;

      iDamage = iDamage + iDamageBonus;

      return iDamage;
   }

   % This is the type of damage done.
   GetDamageType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetDamageType,#what=what);
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         % No weapon means we are punching
         return ATCK_WEAP_UNARMED+ATCK_WEAP_PUNCH;
      }

      return Send(oWeapon,@GetAttackType);
   }

   GetSpellType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
         AND (piFlags & PFLAG_MORPHED)
      {
         return Send(oMonster,@GetSpellType,#what=what);
      }

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         % No weapon means we are punching, no magical damage
         return 0;
      }

      return Send(oWeapon,@GetAttackSpell);
   }

   AssessHit(what = $, stroke_obj = $, damage = $)
   {
      local oMonster;

      if stroke_obj <> $
         AND Send(self,@GetWeaponSwingBonus) > 0
      {
         Send(stroke_obj,@ImproveStroke,#who=self,#target=what,
               #use_weapon=Send(self,@GetWeapon));
      }

      % Morphed? As a bonus, people in illusionary form
      % get the hit side effect.  :)
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
      {
         Send(oMonster,@HitSideEffect,#what=what,#who=self);
      }

      Send(self,@DoHitMessageSound,#what=what,#damage=damage,#stroke_obj=stroke_obj);

      propagate;
   }

   % Handles damage done to player
   % IMPORTANT NOTE: AssessDamage handles both legacy damage calculations and 
   % high precision damage calculation which avoid truncation. If you feed 
   % AssessDamage with a high precision damage number such as 941 for 9.41 
   % points of damage, you need to notify AssessDamage by passing it a 
   % #precision=TRUE. If you don't, AssessDamage will assume that you are 
   % passing a legacy damage value and multiply it by 100 for further 
   % calculations. Most notably, damage from attackspells and melee is now 
   % handled with high precision. Eventually, all damage calculations should 
   % be handled in high precision mode.
   AssessDamage(what=$,damage=$,atype=0,aspell=0,stroke_obj=$,bonus=0,
      scalefactor=1000,report=TRUE,report_resistance=TRUE,absolute=FALSE,
      precision=FALSE)
   {
      local i, j, iResistance, oSoldierShield, gainchance, color_rsc,
            iDuration, oSpell, oGort,iLimit, origdamage, oWeapon, shrunken,
            bAttackerEmpowered, bShielded;

      if NOT precision
      {
         damage = damage * 100;
      }

      origdamage = damage/100;
      color_rsc = player_hit_color_none;

      % Attacks against a minion master will cause minions to defend the master.
      if what <> $
         AND IsClass(what,&Battler)
      {
         Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=what);
      }

      if what <> $ AND IsClass(what,&monster)
      {
         color_rsc = player_hit_color_blue;
      }

      if NOT absolute
      {
         % Armor of Gort has a special effect that must go first
         oGort = Send(SYS,@FindSpellByNum,#Num=SID_ARMOR_OF_GORT);
         if Send(self,@IsEnchanted,#what=oGort)
         {
            damage = Send(oGort,@PriorityModifyDefenseDamage,#who=self,
                           #what=what,#damage=damage,
                           #atype=atype,#aspell=aspell);
         }
         
         foreach i in plDefense_modifiers
         {
            damage = Send(i,@ModifyDefenseDamage,#who=self,#what=what,
                           #damage=damage,#atype=atype,#aspell=aspell,
                           #report_resistance=report_resistance);
            Send(i,@DefendingHit,#who=self,#what=what);
         }
      
         iResistance = Send(self,@ResistanceCheck,#atype=atype,#aspell=aspell);

         foreach i in plRadiusEnchantments
         {
            iResistance = Send(First(i),@ModifyResistance,#attacker=what,
                  #atype=atype,#iPower=Nth(i,2),
                  #caster=Nth(i,3),#resistance=iResistance);
         }

         damage = Send(self,@GetDamageFromResistance,#what=damage,
                        #value=iResistance);

         % Allow protective spells a chance to improve when they take effect!
         foreach i in plPassiveImprovement
         {
            if (aspell & -Nth(i,4)) AND random(1,10) = 10
            {
               Send(First(i),@ImproveAbility,#who=self,#target=what);
            }
         }

         % Add attmods AFTER resistance/suscep mods.
         damage = damage + bonus;

         damage = damage * scalefactor / 1000;
      }

      % Make sure we don't deal negative damage.
      damage = Bound(damage,0,$);

      iDuration = 800;
      if damage <= 600
      {
         iDuration = 600;
      }

      if damage <= 300
      {
         iDuration = 400;
      }

      % Spell damage types do different flashes to inform the victim.
      % If it's just physical damage, do pain instead. Notably: spell
      % damage type flashes cannot be turned off by unchecking the
      % Show Pain option in client config.
      if aspell <> 0
      {
         iDuration = iDuration / 2;
         Send(self,@DamageTypeFlashEffect,#aspell=aspell,#duration=iDuration);
      }
      else
      {
         Send(self,@EffectSendUserDuration,#what=self,
               #effect=EFFECT_PAIN,#duration=iDuration);
      }

      if damage > 0
      {
         if (piFlags2 & PFLAG2_PARALYZED)
         {
            Send(self,@RemoveEnchantment,
                  #what=Send(SYS,@FindSpellByNum,#num=SID_PARALYZE));
         }
      }

      if NOT absolute
         AND what <> $
         AND IsClass(what,&Player)
      {
         % If we have more health than twice our max, no percent limit on damage.
         % If we are outlaw or murderer, no percent limit on damage.
         if piHealth < (piBase_Max_Health * 200)
            AND ((NOT (piFlags & PFLAG_OUTLAW)
               AND NOT (piFlags & PFLAG_MURDERER))
               OR Send(SETTINGS_OBJECT,@DamageCapProtectionMurderersEnabled))
         {
            % Cap damage to 1/3 of max health (+2 so we "round up")
            iLimit = ((piBase_Max_Health*100) + (MAX_HEALTH_DAMAGE_FRACTION-1))
                                             / MAX_HEALTH_DAMAGE_FRACTION;
            damage = Bound(damage,$,iLimit);
         }

         % maximum of 30 damage per hit
         damage = bound(damage,$,MAX_DAMAGE_PER_HIT*100);
      }

      % Faction enemies an extra 15% damage to each other, above caps.
      if what <> $ AND IsClass(what,&Player)
      {
         oSoldierShield = Send(what,@FindUsing,#class=&SoldierShield);
         if oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#who=self,#what=what,
                      #damage=TRUE)
         {
            damage = (damage * 115)/100;
         }
      }

      if IsClass(what,&Monster)
      {
         RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
            Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
            player_monster_attack_string);
      }

      if IsClass(what,&Player)
      {
         oWeapon = Send(what,@GetWeapon);
         if oWeapon <> $
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
               Send(Send(what,@GetWeapon),@GetTrueName));
         }
         else
         {
            RecordStat(STAT_ASSESS_DAM,Send(self,@GetTrueName),
               Send(what,@GetTrueName),aspell,atype,damage/100,origdamage,
               player_no_weapon_string);
         }
      }

      % Increase final damage by 35 percent if attacker damage rod is active
      bAttackerEmpowered = FALSE;
      if what <> $
         AND IsClass(what,&Player)
      {
         foreach i in Send(what,@GetHolderPassive)
         {
            if IsClass(i,&DamageRod)
               AND Send(i,@IsActive)
            {
               bAttackerEmpowered = TRUE;
            }
         }
      }
      
      if bAttackerEmpowered
      {
         damage = damage * 135 / 100;
      }

      % Look for active shield rods in inventory, reduce final damage to 1 if any active
      bShielded = FALSE;
      foreach i in plPassive
      {
         if IsClass(i,&ShieldRod)
            AND Send(i,@IsActive)
         {
            bShielded = TRUE;
         }
      }

      if bShielded
      {
         if precision
         {
            damage = 100;
         }
         else
         {
            damage = 1;
         }
      }

      Send(self,@LoseHealth,#amount=damage,#precision=TRUE);

      if piHealth <= 0
      {
         if stroke_obj = $
            OR NOT Send(stroke_obj,@PlayerWasKilledMsg,#who=self,
                        #attacker=what,#damage=$)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=Send(self,@PlayerWasHit,
                     #atype=atype,#aspell=aspell),#parm1=color_rsc,
                     #parm2=Send(what,@GetCapDef),#parm3=Send(what,@GetName));
            }
         }

         return $;
      }

      % flip flag for possible HP gain.
      if poKill_target = $
      {
         poKill_target = what;
      }

      if what = poKill_target AND damage > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE,#value=TRUE);
      }

      % Should we print resistance message?
      if report_resistance
      {
         if IsClass(what,&User)
         {
            Post(what,@MsgPlayerHitResisted,#what=what,
                  #resistance=iResistance,#target=self);
         }

         Post(self,@MsgPlayerResistsHit,#what=what,#resistance=iResistance,
               #target=self,#color_rsc=color_rsc);
      }

      % Report to shrunken head
      shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
      if damage > 0 AND shrunken <> $
      {
         Send(shrunken,@DamageTaken,#what=what,#amount=damage/100);
      }
      
      Send(self,@AddHurtMeRecently,#who=what,#amount=damage);

      return damage;
   }

   % This message kicks in when damage is done to the opponent.
   DidDamage(what = $, amount = 0)
   {
      local oWeapon, i, shrunken;

      oWeapon = Send(self,@GetWeapon);

      if oWeapon <> $
      {
         Send(oWeapon,@WeaponHitTarget);
      }

      foreach i in plAttack_modifiers
      {
         Send(i,@WeaponHitTarget);
      }

      if Send(self,@GetSkillAbility,#Skill_num=SKID_DISARM) > 0
      {
         if oWeapon <> $ AND IsClass(oWeapon,&Spell)
         {
            oWeapon = $;
         }

         Send(Send(SYS,@FindSkillByNum,#num=SKID_DISARM),@DoSkill,#who=self,
               #oTarget=what,#oWeapon=oWeapon);
      }

      if amount > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         % Report to shrunken head
         shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
         if shrunken <> $
         {
            Send(shrunken,@DamageDealt,#what=what,#amount=amount/100);
         }
      }

      return;
   }

   % Returns weapon used.
   GetWeapon()
   {
      local oWeapon;

      oWeapon = Send(self,@LookupPlayerWeapon);
      % If there is no wielded melee weapon, then see if we
      % have a touch attack active.
      if oWeapon = $
      {
         % This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetEnchantmentsByClass,
               #EnchClass=&TouchAttackSpell);
         if oWeapon <> $
         {
            % The spell object is the second element of the list. Get that.
            oWeapon = Nth(first(oWeapon),2);
         }
      }

      return oWeapon;
   }

   % The next three functions deal with weapon improvement.

   % This keeps track of the weapon swings.
   SwingWeapon(times=1)
   {
      local oWeapon, iProfNum;

      oWeapon = Send(self,@LookupPlayerWeapon);

      if oWeapon <> $
      {
         % Get weapon's numbers.
         iProfNum = Send(oWeapon,@GetProfNumber,#who=self);
      }
      else
      {
         % Unarmed or touch attacks.
         iProfNum = SKID_BRAWLING;
      }

      if iProfNum <> (piWeaponInfo MOD 1000)
      {
         Send(self,@ResetWeaponSwings,#prof=iProfNum);
      }

      piWeaponSwings = piWeaponSwings + times;
      if (piWeaponSwings MOD Send(SETTINGS_OBJECT,
                                 @GetSwingsPerImproveCheck)) = 0
      {
         % Increase this number. Allows us to advance, and
         % get bonuses for advancement.
         piWeaponInfo = piWeaponInfo + 1000;
      }

      return;
   }

   % This resets the weapon swings, for example, after an improvement or a
   % weapon type change.
   ResetWeaponSwings(prof=$)
   {
      local iProf;

      if prof <> $
      {
         iProf = prof;
      }
      else
      {
         iProf = piWeaponInfo mod 1000;
      }

      piWeaponSwings = 0;
      piWeaponInfo = iProf;

      return;
   }

   GetWeaponSwingBonus()
   {
      % Separate out the number of groups of swings (the bonus) fromt he proficiency number.
      return piWeaponInfo/1000;
   }

   KilledSomething(what = $,use_weapon = $,stroke_obj = $)
   "Called when the player killed something."
   {
      local bReflection, i, oSoldierShield, monstkarma, iChance, oEnemyGuild,
      shrunken, oVictimRoom;

      % If we killed someone or something, we did damage.
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

         % Stop minions ruining our karma, they are kind of bloodthirsty
         % and tend to kill indiscriminately (especially mobs)
         bReflection = FALSE;
         if use_weapon <> $
            AND IsClass(use_weapon,&Monster)
         {
            bReflection = TRUE;
         }

      % Send text message - a stroke may want to provide it's own.
      if NOT Send(what,@SayDyingWords,#what=self)
      {
         if stroke_obj
         {
            if NOT Send(stroke_obj,@PlayerKilledSomethingMsg,#who=self,#victim=what)
               AND self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
         else
         {
            if self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
      }

      if pbLogged_on
      {
         if (IsClass(what,&Monster)
               AND NOT (IsClass(what,&Brambles)
                  OR Send(what,@IsIllusion)))
            AND (use_weapon = $
               OR NOT IsClass(use_weapon,&ActiveWallElement))
            AND (piPreferences & CF_GROUPING)
         {
            Send(self,@JoinBuilderGroup);
         }

         Send(poOwner,@SomethingKilled,#what=self,#victim=what);
      }

      % Let our shield know we killed something.
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         Send(oSoldierShield,@KilledSomething,#what=what);
      }

      if IsClass(what,&User)
         AND what <> self
      {
         % Use the room the victim died in to determine if there are penalties
         % for this kill. Otherwise we can get away with it in rare instances.
         % Victim's room is still the one they died in.
         oVictimRoom = Send(what,@GetOwner);

         if (oVictimRoom = $
            OR NOT Send(oVictimRoom,@SafePlayerAttack))
            AND NOT Send(oVictimRoom,@GetChaosZone)
         {
            Send(Send(SYS,@GetStatistics),@PlayerKillsCounter);

            if Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            {
               piJustified_kill_count = piJustified_kill_count + 1;
            }
            else
            {
               piKill_count = piKill_count + 1;
               piKill_count_decay = piKill_count_decay + 1;
            }

            if NOT bReflection
               AND NOT Send(what,@IsIllusion)
            {
               Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
                     #karma_killer=Send(self,@GetKarma),
                     #karma_victim=Send(what,@GetKarma)));
            }

            if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
               AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
               AND NOT IsClass(oVictimRoom,&GuildHall)
            {
               % Attacked an innocent!

               % Check for enemy guild - If both guilds are enemies, then
               % they can whack on each other freely, without murderer or
               % faction penalty.
               oEnemyGuild = Send(what,@GetGuild);

               % Check for various murderer things if any are true:
               % We're not in a guild, opponent wasn't in a guild, we're
               % not in a mutual war
               % AND if we're not a faction soldier, the opponent isn't an
               % opposing faction soldier
               if (poGuild = $
                   OR oEnemyGuild = $
                   OR NOT Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
                  AND (oSoldierShield = $
                       OR NOT Send(oSoldierShield,@IsEnemyAttack,#who=what,
                                    #what=self,#damage=TRUE))
               {
                  % SUBTLE BUG: Somehow, the faction check is missed when you
                  % kill something. We check it here, but only for players.
                  % This means that if you score just the killing blow on a
                  % factioned monster, you won't get checked for faction loss.
                  % It's a bug, but currently not that vital.
                  
                  % Check to see if the attack was faction-based.
                  Send(self,@CheckFactionAttack,#what=what);

                  % Apply penalties for someone NOT holding a token
                  if Send(what,@FindUsing,#class=&Token) = $
                  {
                     if (piFlags & PFLAG_MURDERER)
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_killed_player);
                     }
                     else
                     {
                        Send(self,@MsgSendUser,#message_rsc=player_wanted_now,
                              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
                        Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=TRUE);
                        Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
                        Send(self,@EvaluatePKStatus,#dbug=TRUE);
                     }

                     % Does the lucky murderer win a Revenant?
                     % If it was an easy fight, lets haunt em more often than if
                     % it was competitive (or the victim at least had a shot)
                     % If were twice as strong as them, we get haunted.
                     % If the victim was good, we get haunted.
                     iChance = Send(self,@RevenantChance,#target=what);
                     if (random(1,100) < iChance) AND NOT Send(SYS,@GetChaosNight)
                     {
                        Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=TRUE);
                        if poOwner <> $
                        {
                           Send(self,@MsgSendUser,#message_rsc=player_haunted_on,
                                 #parm1=Send(what,@GetCapDef),
                                 #parm2=Send(what,@GetName,#Cap=TRUE));
                           Create(&Revenant,#target=self,#location=poOwner,
                                 #level=Bound((((piBase_Max_health*110)/100)+
                                    (7*piKill_Count_decay)),95,180),
                                 #diff=bound(piBase_Max_health/12,4,9),
                                 #karmic=-piKarma/100);
                        }
                     }
                  }
               }
            }
         }
      }

      if IsClass(what,&Monster)
         AND NOT bReflection
         AND NOT Send(what,@IsIllusion)
      {
         Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
               #karma_victim=Send(what,@GetKarma),
               #karma_killer=Send(self,@GetKarma)),
               #bIsMob=TRUE);
      }

      Send(what,@Killed,#what=self,#stroke_obj=stroke_obj);
      Send(self,@DrawHPChance);

      % Report to shrunken head
      shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
      if shrunken <> $
      {
         Send(shrunken,@OpponentKilled,#what=what,#stroke_obj=stroke_obj);
      }

      return;
   }

   GetSomethingMissedYouSound(what = $,weapon_used = $)
   {
      local i,iRoll;

      if Send(self,@LookupPlayerWeapon)
      {
         iRoll = Random(1,3);
         if iRoll = 1
         {
            return player_sound_sword1;
         }

         if iRoll = 2
         {
            return player_sound_sword2;
         }

         if iRoll = 3
         {
            return player_sound_sword3;
         }
      }

      iRoll = Random(1,3);

      if iRoll = 1
      {
         return player_sound_metal1;
      }

      if iRoll = 2
      {
         return player_sound_metal2;
      }

      if iRoll = 3
      {
         return player_sound_metal3;
      }

      Debug("Can't get here");

      return $;
   }

   GetOuchSound()
   {
      local iHealthFraction;

      % Since piHealth is inflated by a factor of 100, 
      % this returns the correct fraction.
      if piMax_health > 0
      {
         iHealthFraction = piHealth / piMax_health;
      }
      else
      {
         iHealthFraction = 0;
      }

      if piGender = GENDER_MALE
      {
         if iHealthFraction > 75
         {
            return player_sound_male_ouch1;
         }

         if iHealthFraction > 50
         {
            return player_sound_male_ouch2;
         }

         if iHealthFraction > 25
         {
            return player_sound_male_ouch3;
         }

         return player_sound_male_ouch4;
      }

      if iHealthFraction > 75
      {
         return player_sound_female_ouch1;
      }

      if iHealthFraction > 50
      {
         return player_sound_female_ouch2;
      }

      if iHealthFraction > 25
      {
         return player_sound_female_ouch3;
      }

      return player_sound_female_ouch4;
   }

   RevenantChance(who=$,target=$)
   {
      local oChance, oGuild, iFaction, oSpell, oVictimRoom;

      oVictimRoom = Send(target,@GetOwner);

      if oVictimRoom = $
         OR IsClass(oVictimRoom,&Guildhall)
      {
         return 0;
      }

      % PFLAG2_NOHAUNT is only settable by a guide or guardian. The last
      % two checks prevent outlaw/murderer players from creating revenants.
      if (piFlags2 & PFLAG2_NOHAUNT)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         return 0;
      }

      oChance = 30;
      oGuild = Send(target,@GetGuild);

      if poGuild <> $ AND oGuild <> $
      {
         if poGuild = oGuild
         {
            oChance = oChance + 20;
         }
         else
         {
            if Send(poGuild,@IsMutualEnemy,#otherguild=oGuild)
            {
               return 0;
            }
            if Send(poGuild,@IsAlly,#otherguild=oGuild)
            {
               oChance = oChance + 10;
            }
            if Send(oGuild,@IsAlly,#otherguild=poGuild)
            {
               oChance = oChance + 10;
            }
            if Send(poGuild,@IsEnemy,#otherguild=oGuild)
            {
               oChance = oChance - 10;
            }
            if Send(oGuild,@IsEnemy,#otherguild=poGuild)
            {
               oChance = oChance - 10;
            }
         }
      }

      iFaction = Send(target,@GetFaction);
      if piFaction <> FACTION_NEUTRAL AND iFaction <> FACTION_NEUTRAL
      {
         if piFaction <> iFaction
         {
            oChance = oChance - 5;
         }
         else
         {
            oChance = oChance + 15;
         }
      }

      % Punish them more if they beat up someone weaker than they are.
      oChance = oChance + ((10*piBase_Max_Health)/Send(target,@GetBaseMaxHealth));

      % People with greater absolute Karma have a greater chance to produce
      % a revenant.  Being a good person, in general, decreases your chance.
      % Even if you are murderous scum.
      oChance = oChance + (abs(Send(target,@GetKarma)-piKarma/100))/20;

      % Punish them more if they walked away with more health.
      oChance = oChance + bound(piHealth/(5*piBase_Max_health),0,20);

      % Bind the number to a reasonable amount, then add in the penalty
      % for being a repeat killer.
      oChance = (bound(oChance,20,80) + (5*piKill_count_decay));

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_MARTYRS_BATTLEGROUND);
      if Send(oVictimRoom,@IsEnchanted,#what=oSpell)
      {
         oChance = oChance +
               (oChance * Send(oVictimRoom,@GetEnchantmentState,#what=oSpell) / 100);
      }
      oChance = Bound(oChance,40,95);

      return oChance;
   }

   DoHitMessageSound(what = $,damage = 0,stroke_obj = $)
   {
      local iRoll,rSound;

      if (stroke_obj = $)
      {
         return;
      }

      if IsClass(stroke_obj,&Spell)
      {
         rSound = Send(stroke_obj,@GetHitSound);
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
         if IsClass(what,&Player)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,
                  #wave_rsc=Send(what,@GetOuchSound));
         }

         return;
      }

      if IsClass(what,&Monster)
      {
         if damage <> $
         {
            if damage <= 300
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_flesh1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_flesh2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_flesh3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }

            if damage <= 600
            {
               iRoll = Random(1,3);
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_leather1;
               }
               else
               {
                  if iRoll = 2
                  {
                     rSound = player_sound_hit_monster_leather2;
                  }
                  else
                  {
                     rSound = player_sound_hit_monster_leather3;
                  }
               }

               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

               return;
            }
         }

         iRoll = Random(1,3);
         if iRoll = 1
         {
            rSound = player_sound_hit_monster_metal1;
         }
         else
         {
            if iRoll = 2
            {
               rSound = player_sound_hit_monster_metal2;
            }
            else
            {
               rSound = player_sound_hit_monster_metal3;
            }
         }

         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

         return;
      }

      if damage <> $
      {
         if damage <= 300
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_flesh1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_flesh2;
               }
               else
               {
                  rSound = player_sound_hit_monster_flesh3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }

         if damage <= 600
         {
            iRoll = Random(1,3);
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_leather1;
            }
            else
            {
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_leather2;
               }
               else
               {
                  rSound = player_sound_hit_monster_leather3;
               }
            }

            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,
                     #wave_rsc=Send(what,@GetOuchSound));
            }

            return;
         }
      }

      iRoll = Random(1,3);
      if iRoll = 1
      {
         rSound = player_sound_hit_monster_metal1;
      }
      else
      {
         if iRoll = 2
         {
            rSound = player_sound_hit_monster_metal2;
         }
         else
         {
            rSound = player_sound_hit_monster_metal3;
         }
      }

      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);

      if IsClass(what,&Player)
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
      }

      return;
   }

   CheckAttackTimer()
   {
      if ptAttackTimer <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   IsOkayAttackTime(time = 1000, seconds = $)
   "Have we waited long enough since the last attack/spell? Sets new "
   "valid attack time (time in msec, default 1 second)."
   {
      local i;

      if ptAttackTimer <> $
      {
         return FALSE;
      }

      if seconds <> $
      {
         i = seconds*1000;
      }
      else
      {
         i = time;
      }

      if i > 0
      {
         ptAttackTimer = CreateTimer(self,@AttackTimer,i);
      }

      return TRUE;
   }

   AttackTimer()
   "Sets the attack timer variable to NIL so we know it's OK to attack again."
   {
      ptAttackTimer = $;

      return;
   }

   SendAttackOutOfRangeMessage(what = $, use_weapon = $, stroke_obj = $)
   {
      if use_weapon = $
         AND stroke_obj = $
      {
         return;
      }

      if use_weapon <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_range,
               #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
               #parm3=Send(use_weapon,@GetIndef),
               #parm4=Send(use_weapon,@GetName));
      }
      else
      {
         if IsClass(stroke_obj,&spell)
         {
            if IsClass(stroke_obj,&RadiusEnchantment)
            {
               return;
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_SPELL_range,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                  #parm3=Send(stroke_obj,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_PUNCH_range,
                  #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                  #parm3=Send(stroke_obj,@GetName));
         }
      }

      return;
   }

   SendNoLineOfSightMessage()
   {
      Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);
      return;
   }

   GetMoneyObject()
   {
      local i;

      foreach i in plPassive
      {
         if IsClass(i,&Money)
         {
            return i;
         }
      }

      return $;
   }

   % Returns wielded Melee/Ranged weapon.
   LookupPlayerWeapon()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Weapon)
         {
            return i;
         }
      }

      return $;
   }

   LookupPlayerShield()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Shield)
            AND Send(i,@GetBlockAbility,#who=self) > 0
         {
            return i;
         }
      }

      return $;
   }

   LeaveHold(what = $)
   {
      local i;

      % in case it's on the list of window overlays 
      Send(self,@RemoveWindowOverlayObject,#what=what);

      % in case it set our icon
      if poIcon_set = what
      {
         Send(self,@ResetPlayerIcon);
      }

      % in case it removed our hair
      if poHair_remove = what
      {
         Send(self,@ResetHair);
      }

      % in case it set our legs
      if poLegs_set = what
      {
         Send(self,@ResetPlayerLegs);
      }

      if poArms_set = what
      {
         Send(self,@ResetPlayerArms);
      }

      foreach i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            % implied by drop: Send(self,@NewUnusing,#what=what)
            Send(what,@NewUnused,#what=self);

            break;
         }
      }

      propagate;
   }

   GetPlayerUsing()
   {
      return plUsing;
   }

   GetEquippedItems()
   {
      return Send(self,@GetPlayerUsing);
   }

   IsUsingA(class=$)
   {
      local i;

      if class = $
      {
         return FALSE;
      }

      if GetListElemByClass(plUsing, class)
      {
         return TRUE;
      }

      return FALSE;
   }

   FindUsing(class=$)
   "Find the first instance of 'class' that player has equipped. "
   "Returns $ if nothing is found."
   {
      local i;

      if class = $
      {
         return $;
      }

      return GetListElemByClass(plUsing, class);
   }

   ChooseArmorPosition()
   "Defense now chooses a body place at random, and checks to see if the "
   "defender has any defense value there. Much better than random pattern "
   "of previous combat."
   {
      local rand, armor_pos;

      rand = random(1,12);
      armor_pos = 0;

      if rand < 6
      {
         return ITEM_USE_BODY;
      }

      if rand < 8
      {
         return ITEM_USE_LEGS;
      }

      if rand < 9
      {
         return ITEM_USE_HEAD;
      }

      if rand < 10
      {
         return ITEM_USE_GAUNTLET;
      }

      % Default position: shield
      return -1;
   }

   GetDefenseModifier()
   "Returns a number from 0-100."
   {
      local armor_mod, armor_pos, i, shirt;

      armor_mod = 0;
      armor_pos = Send(self,@ChooseArmorPosition);

      if armor_pos = -1
      {
         foreach i in plUsing
         {
            if IsClass(i,&Shield)
            {
               return i;
            }
         }

         return $;
      }
      else
      {
         if armor_pos & ITEM_USE_BODY
         {
            shirt = $;
            foreach i in plUsing
            {
               if Send(i,@GetItemUseType) & armor_pos
               {
                  return i;
               }
               if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
               {
                  shirt = i;
               }
            }

            return shirt;
         }
         else
         {
            foreach i in plUsing
            {
               if Send(i,@GetItemUseType) = armor_pos
               {
                  return i;
               }
            }
         }

         return $;
      }

      return $;
   }

   CalculateHealthTime()
   "Calculate # of milliseconds until user will gain a health point"
   {
      local iTime, iMaxHealth, lRadiusState;

      % Faster regen with higher vigor
      iTime = ((200-piVigor)*(200-piVigor))/6 + 1000;

      iTime = ((125-Send(self,@GetStamina)) * iTime)/100;
      iMaxHealth = bound(piMax_health,40,100);
      iTime = (iTime *100)/iMaxHealth;

      iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                           #who=self,#hpregen=TRUE);

      return bound(iTime,1000,60000);
   }

   CalculateManaTime()
   "Calculate # of milliseconds until user will gain a mana point"
   {
      local iTime, oSpell, iSpellPower;

      if piMana > piMax_mana
      {
         iTime = BOOST_DECAY_TIME;
      }
      else
      {
         iTime = BASE_REGEN_TIME + (25-Send(self,@GetMysticism))*1000;
         iTime = iTime * 200 / bound(piVigor,1,$);
         iTime = iTime/ bound(piMax_Mana,1,$);

         iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                              #who=self,#hpregen=FALSE);

         iTime = Bound(iTime,1000,60000);

         % Mana Focus will adjust mana regen time based on its spellpower.
         % Flag check for speed.
         if piFlags & PFLAG_MANA_FOCUS
         {
            oSpell = Send(SYS,@FindSpellByNum,#Num=SID_MANA_FOCUS);
            % Spellpower is returned directly from this.
            iSpellPower = Send(self,@GetEnchantedState,#what=oSpell);
            % Mana Focus bounds this to 500-60000 ms.
            iTime = Send(oSpell,@AdjustManaTime,#iSpellPower=iSpellPower,
                           #time=iTime);
         }
      }

      return iTime;
   }

   ReqEatSomething(filling = 0, what = $)
   {
      % This is the only place we need piStomach to be correct
      Send(self,@UpdateStomach);

      if (piStomach + filling) > 100
      {
         if what = $ OR NOT Send(what,@IsBeverage)
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full_drink);
         }

         return FALSE;
      }

      return TRUE;
   }

   EatSomething(nutrition = 0, filling = 0)
   {
      Send(self,@AddExertion,#amount=-10000*nutrition);
      piStomach = piStomach + filling;

      return;
   }

   LoseHealth(amount = $, decay = FALSE, precision = FALSE)
   "decay = TRUE if you lose a HP over time because you are boosted over max "
   "by some sort of vamp effect. If this is true, you shouldn't break a trance."
   {
      if NOT precision
      {
         amount = amount*100;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if piFlags & PFLAG_TRANCE AND NOT decay
      {
         Send(self,@BreakTrance,#event=EVENT_DAMAGE);
      }

      piHealth = piHealth - amount;
      Send(self,@NewHealth);

      return;
   }

   GainHealth(amount = $, precision = FALSE)
   "Some attempt here to quell the vamp touch bugs"
   {
      if NOT precision
      {
         amount = amount*100;
      }

      if NOT Send(self,@IsInCannotInteractMode)
      {
         if (200*piMax_health) < (piHealth+amount)
         {
            Send(self,@MsgSendUser,#message_rsc=player_health_gain_maxed);
            piHealth = 200 * piMax_health;
         }
         else
         {
            piHealth = piHealth + amount;
         }
      }

      Send(self,@NewHealth);

      return;
   }

   GainHealthNormal(amount = $, precision = FALSE)
   "Don't add beyond piMax_health"
   {
      local iOldhealth;

      if amount = $
      {
         Debug("Player ",Send(self,@GetTrueName)," had GainHealthNormal called",
               " with amount = $! Precision was ",precision);

         return;
      }

      if NOT precision
      {
         amount = amount*100;
      }

      iOldhealth = piHealth;

      if amount < 0
      {
         return;
      }

      if piHealth > piMax_health*100
      {
         return 0;
      }

      if NOT Send(self,@IsInCannotInteractMode)
      {
         pihealth = piHealth + amount;
         if piHealth > piMax_health*100
         {
            piHealth = piMax_health*100;
         }
      }

      Send(self,@NewHealth);

      return (piHealth - iOldhealth);
   }

   NewHealth()
   {
      if piHealth < 0
      {
         piHealth = 0;
      }

      % Keep health from going above natural max if affected by Mark of Dishonor.
      if piHealth > piBase_Max_health*100
         AND Send(self,@IsEnchanted,#byClass=&MarkOfDishonor)
      {
         piHealth = piBase_Max_health*100;
      }

      if ptHealth = $
      {
         if piHealth <> piMax_health*100
            AND piHealth > 0
         {
            ptHealth = CreateTimer(self,@HealthTimer,Send(self,@CalculateHealthTime));
         }
      }
      else
      {
         if piHealth = piMax_health*100
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }
      }

      Send(self,@DrawHealth);

      return;
   }

   GainLight(amount = $)
   "Adds <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight + amount;
      Send(self,@NewLight);

      return amount;
   }

   LoseLight(amount = $)
   "Subtracts <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }

      piLight = piLight - amount;
      Send(self,@NewLight);

      return amount;
   }

   NewLight()
   "Call this everytime player light is changed."
   {
      Send(self,@SourceLightChanged);

      return;
   }

   GainBaseMaxHealth(amount = 0)
   {
      local iPrev_max, iApparentStamina;

      iPrev_max = piBase_max_health;

      % To deal with potential valid HP being stripped if the player has
      % a temporary negative stamina modifier, we need to check if
      % piStaminaMod is negative and if so, use just the raw stamina itself.
      if piStaminaMod >= 0
      {
         iApparentStamina = Send(self,@GetStamina);
      }
      else
      {
         iApparentStamina = Send(self,@GetRawStamina);
      }

      piBase_max_health = Bound(piBase_max_health + amount, 20,
                              (100 + iApparentStamina));
      % Bound ourselves at the top end to 150.
      piBase_max_health = Bound(piBase_max_health,$,150);
      amount = piBase_max_health - iPrev_max;

      % Give them the "further info" gmail if they've advanced to 25.
      if piBase_Max_health = 25
         AND amount > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_tutorial_mail]);
      }

      Send(self,@PlayerIsIntriguing);
      Send(self,@GainMaxhealth,#amount=amount);

      return;
   }

   GainMaxHealth(amount = 0)
   "Call this any time you modify piMax_health, to set stuff on the user's "
   "display, and make sure the value doesn't get too high.  Returns "
   "actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_health;
      piMax_health = bound(piMax_health + amount, 20, $);

      %  no longer reset health to max - will need to test for abusability
      %     the motivation for this originated in using a circlet with health > max_health,
      %     which would erase hp boons or vamptouch gains - kinda mean.
      %     thought about preserving (health - max_health):
      %           OOOOOOOOOOOOOOOOOOOOoooooo       (o is health above max)
      %     -->   OOOOOOOOOOOOOOOOoooooo
      %     but in parallel with this scheme, we should also do:
      %           OOOOOOOOOOOOOO......             (. is space to max)
      %     -->   OOOOOOOOOO......
      %     which could result in death!
      %     the behavior could be made assymetrical,
      %           OOOOOOOOOOOOOO......
      %     -->   OOOOOOOOOOOOOO..
      %     but what about this case?
      %           OOOOOOOOOOOOOOOOO...    or    OOOOOOOOOOOOOOOOO...
      %     -->   OOOOOOOOOOOOOOOOo             OOOOOOOOOOOOOOOO
      %     the left is obviously abusable - compound it with the first gain above,
      %     and by putting on and removing a circlet we gain health!
      %     the right might be ok, and is closest to the current scheme,
      %     but this introduces even more assymmetry and thus makes me nervous.
      %     so my first pass is to do nothing to health here:
      %
      %if piHealth > piMax_health { piHealth = piMax_health; }
      %
      %     if this becomes undesirable, use this new code:
      %if piHealth > iPrev_max { piHealth = piMax_health + (piHealth - iPrev_max); }
      %else { piHealth = bound(piHealth, $, piMax_health); }

      Send(self,@NewHealth); % in case need heal timer

      return piMax_health - iPrev_max;
   }

   GetInitialMaxMana()
   {
      return 15 + Send(self,@GetMysticism)/5;
   }

   StripNodeList(number=$)
   {
      local nodelist, count;

      nodelist = Send(self,@GetNodelist);

      if number = $
      {
         number = length(nodelist);
      }

      count = 1;

      while nodelist >=1
      {
         if ((nodelist/2)*2) <> nodelist  %we do an "# was odd" operator
         {
            Send(Send(SYS,@FindNodeByNum,#num=count),@UnMeld,#who=self);
         }
         count = count*2;
         nodelist = nodelist/2;
      }

      Send(self,@ResetNodeList);
      Send(self,@NewMana);

      return;
   }

   StripOneNode(report=TRUE)
   {
      local lNodes, index, bFaerieNode, bQNode, oNode;

      if piNodeList = 0
      {
         return;
      }

      lNodes = $;
      index = 1;
      bFaerieNode = FALSE;
      bQNode = FALSE;

      while index <= NODE_MAX_VALUE
      {
         if piNodelist & index
         {
            if index = NODE_FAERIE
            {
               bFaerieNode = TRUE;
            }
            else
            {
               if index = NODE_Q
               {
                  bQNode = TRUE;
               }
               else
               {
                  lNodes = cons(index,lNodes);
               }
            }
         }

         index = index * 2;
      }

      if lNodes = $
      {
         % No nodes; let's rip out one of the special ones, then.
         if bFaerieNode
         {
            lNodes = Cons(NODE_FAERIE,lNodes);
         }
         if bQNode
         {
            lNodes = Cons(NODE_Q,lNodes);
         }
      }

      if lNodes
      {
         index = Nth(lNodes,random(1,length(lNodes)));
         oNode = Send(SYS,@FindNodeByNum,#num=index);
         Send(oNode,@UnMeld,#who=self);

         if report
         {
            Post(self,@MsgSendUser,#message_rsc=player_lose_node,
                 #parm1=Send(oNode,@GetLocationName));
         }
      }

      Send(self,@NewMana);

      return;
   }

   RemoveNodeFromList(node_num=0)
   {
      piNodelist=piNodelist & ~node_num ;

      return;
   }

   ResetNodeList()
   {
      piNodelist = 0;

      return;
   }

   NewMaxMana(amount=0,node_num=-1)
   "This is called from the mana node.  Unlike newMaxHealth, the amount is "
   "checked here.  Returns actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_mana;
      if amount > 0 AND node_num <> -1
      {
         piNodelist = piNodelist | node_num;
      }

      if amount < 0 AND node_num <> -1
      {
         if piNodelist & node_num
         {
            piNodelist = piNodelist & ~node_num;
         }
         else
         {
            Debug("BAD: missing node_num from nodelist in mana adjust.",self);
         }
      }

      piMax_Mana = piMax_mana+amount;
      Post(self,@ComputeMaxMana);

      return (piMax_mana - iPrev_max);
   }

   ComputeMaxMana()
   {
      local index, iNodeList, oNode, i, oCrystalizeMana, iCrystalizeManaAbility;

      index = 1;
      iNodelist = piNodelist;
      piMax_mana = Send(self, @GetInitialMaxMana);

      while iNodeList > 0 AND index <= NODE_MAX_VALUE
      {
         if (iNodeList & index)
         {
            oNode = Send(SYS,@FindNodeByNum,#num=index);
            piMax_mana = piMax_mana + Send(oNode,@GetManaAdjust,#who=self);
            iNodelist = iNodelist & ~index;
         }
         index=index*2;
      }

      % Account for any items that may affect max mana
      foreach i in plUsing
      {
         if Send(i,@AdjustsMaxMana)
         {
            piMax_mana = piMax_mana + Send(i,@GetManaChange);
         }
      }

      foreach i in plEnchantments
      {
         if Send(Nth(i,2),@AffectsMaxMana)
         {
            piMax_mana = piMax_mana + Send(Nth(i,2),@GetManaBonus,
                                          #state=Nth(i,3));
         }
      }

      oCrystalizeMana = Send(SYS,@FindSpellByNum,#num=SID_CRYSTALIZE_MANA);
      iCrystalizeManaAbility = Send(self,@GetSpellAbility,
                                    #spell_num=SID_CRYSTALIZE_MANA);

      if oCrystalizeMana <> $
         AND iCrystalizeManaAbility <> 0
      {
         piMax_mana = piMax_mana + Send(oCrystalizeMana,@GetManaBonus,
                                       #spell_ability=iCrystalizeManaAbility);
      }

      if Send(self,@IsCrystalizeManaSurging)
      {
         piMax_mana = Send(self, @GetInitialMaxMana);
      }

      Send(self,@NewMana);

      return;
   }

   NumManaNodes()
   {
      local i, n;

      n = 0;
      i = 1;

      while i <= NODE_MAX_VALUE
      {
         if piNodelist & i
         {
            n = n + 1;
         }

         i = 2 * i;
      }

      return n;
   }

   GetNodeList()
   "Returns the list of nodes that a player has successfully melded with."
   {
      return piNodelist;
   }


   GetSpellList()
   {
      return plSpells;
   }

   % These next three functions handle school casts.

   % This message handles adding a weighted cast to the school casts list.
   AddSchoolCast(school=$, amount=$)
   {
      local iToAdd;

      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > Length(plSchoolCasts)
         OR amount = $
      {
         return;
      }

      iToAdd = amount;

      SetNth(plSchoolCasts,school,(Nth(plSchoolCasts,school)+iToAdd));

      return;
   }

   % This message returns the appropriate school cast amount from the list.
   GetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return 0;
      }

      return Nth(plSchoolCasts,school);
   }

   % This message resets the weighted cast count back to 0.
   ResetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return;
      }

      SetNth(plSchoolCasts,school,0);

      return;
   }

   GetNumAbilityPointsInSchool(school=0)
   {
      if school = 0
         OR plSchools = $
      {
         return 0;
      }

      return Nth(plSchools,school);
   }

   GetNumSpellsInSchool(school = 0)
   "Used by the advancement checker to see the odds of a player advancing."
   {
      local num, i, oSpell;

      num = 0;
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,
               #num=Send(self,@DecodeSpellNum,#compound=i));
         if school = Send(oSpell,@GetSchool)
         {
            ++num;
         }
      }

      return num;
   }

   GetSkillList()
   {
      return plSkills;
   }

   GetHealth()
   {
      return piHealth/100;
   }

   GetExactHealth()
   {
      return piHealth;
   }

   SetHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount*100,0,$);
      }

      Send(self,@DrawHealth);

      return;
   }

   SetExactHealth(amount=$)
   {
      if amount <> $
      {
         piHealth = bound(amount,0,$);
      }
      
      return;
   }

   GetMight()
   {
      return bound((piMight + piMightMod),1,MAXIMUM_STAT);
   }

   GetIntellect()
   {
      return bound((piIntellect + piIntellectMod),1,MAXIMUM_STAT);
   }

   GetAgility()
   {
      return bound((piAgility + piAgilityMod),1,MAXIMUM_STAT);
   }

   GetAim()
   {
      return bound((piAim + piAimMod),1,MAXIMUM_STAT);
   }

   GetStamina()
   {
      return bound((piStamina + piStaminaMod),1,MAXIMUM_STAT);
   }

   GetMysticism()
   {
      return bound((piMysticism + piMysticismMod),1,MAXIMUM_STAT);
   }

   GetRawMight()
   {
      return bound(piMight,1,50);
   }

   GetRawIntellect()
   {
      return bound(piIntellect,1,50);
   }

   GetRawAgility()
   {
      return bound(piAgility,1,50);
   }

   GetRawAim()
   {
      return bound(piAim,1,50);
   }

   GetRawStamina()
   {
      return bound(piStamina,1,50);
   }

   GetRawMysticism()
   {
      return bound(piMysticism,1,50);
   }

   GetKarma()
   "Returns karma in natural units"
   {
      return piKarma/100;
   }

   GetVigor()
   {
      return piVigor;
   }

   AddKarma(amount = 0)
   "Adds argument (which must be in hundredths of karma units) to karma"
   {
      piKarma = piKarma + amount;
      Send(self,@NewKarma);

      return;
   }

   LoseKarma(amount = 0)
   {
      piKarma = piKarma - 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   GainKarma(amount = 0)
   {
      piKarma = piKarma + 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   NewKarma()
   {
      if piKarma < -10000
      {
         piKarma = -10000;
      }

      if piKarma > 10000
      {
         piKarma = 10000;
      }

      Send(self,@DrawKarma);

      return;
   }

   SetKarma(value = 0)
   "Changes karma to specified amount"
   {
     piKarma = value;
     Send(self,@NewKarma);

     return;
   }

   CalculateKarmaChangeFromAct( karma_doer=$, karma_act=$, Swing_factor = 1)
   {
      local iBase, iChange;

      if karma_doer = $ OR karma_act = $
      {
         return 0;
      }

      % Neutral mobs and event mobs do not change karma
      if karma_act = 0
      {
         return 0;
      }

      % Do not change karma if player is good, act is good, but not as
      % good as player. I.e. only change karma if good player does bad
      % stuff (or vice versa).
      if (karma_doer > 0 AND karma_act > 0 AND karma_doer > karma_act)
      OR (karma_doer < 0 AND karma_act < 0 AND karma_doer < karma_act)
      {
         return 0;
      }

      iBase = karma_doer  - karma_act;

      iChange = - ((iBase*iBase*ibase)/2500 + (5*iBase));

      % Swing factor must be a number from 1 to 10
      swing_factor = bound(swing_factor,1,10);

      return (iChange / (11 - swing_factor));
   }

   CalculateKarmaChangeFromKill(karma_killer=0,karma_victim=0,bIsMob=FALSE)
   {
      local iChange, iSwing, oSpellDeathLink;

      % No karma change in survival room. Mobs in this room *should*
      % return 0 karma, but there are cases where it doesn't happen.
      if poOwner <> $
         AND IsClass(poOwner,&SurvivalRoom)
      {
         return 0;
      }

      % No karma changes from killing players during Frenzies.
      % Also, no Karma change from event monsters: Xeos and admin-spawned.
      if (Send(SYS,@GetChaosNight) AND NOT bIsMob)
         OR karma_victim = $
      {
         return 0;
      }

      % No karma changes in the newbie area. Otherwise e.g. killing a negative
      % karma monster may make your spell inoperable.
      if poOwner <> $
         AND Send(poOwner,@GetRegion) = RID_NEWB_BASE
      {
         return 0;
      }

      % No karma changes from killing neutral monsters.
      if bIsMob AND karma_victim = NEUTRAL
      {
         return 0;
      }

      % Death link prevents karma changes
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#num=SID_DEATH_LINK);
      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         return 0;
      }

      % A kill is merely an act, like all other acts, with the
      % strongest swing factor possible.  The karma of a kill
      % is equal to the negative karma of the person who died -
      % thus, killing someone with 100 karma is a -100 karma act.
      if bIsMob
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingMonster);
      }
      else
      {
         iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingPlayer);
      }

      % Okay, let's give them a break if they are moving towards
      % neutrality, and they've just killed a monster.  This happens,
      % for example, if a player with 20 karma kills a monster with
      % -10.  It moves the player towards 10, but at a slower pace.

      if bIsMob
      {
         if (karma_killer > 0) <> (karma_victim > 0)
            AND (abs(karma_killer) > abs(karma_victim))
         {
            iSwing = Send(SETTINGS_OBJECT, @GetKillKarmaSwingNeutral);
         }
      }

      iChange = Send(self,@CalculateKarmaChangeFromAct,#karma_doer = karma_killer,
                     #karma_act = -(karma_victim),#swing_factor = iSwing);

      if bIsMob
      {
         iChange = Bound(iChange,-150,150);
      }

      return iChange;
   }

   %%% Guild Command Stuff

   RemoveAllGuildCommands()
   "Removes all of the player's guild commands from him."
   {
      piGuild_commands = 0;

      return;
   }

   HasGuildCommand(command_num=0)
   "This always checks to be sure that the flag exists."
   {
      return (piGuild_commands & command_num);
   }

   AddGuildCommand(command_num = 0)
   "Adds a guildcommand to player's arsenal.  Usually called by resetpowers"
   "in guild.kod."
   {
      local oCommand;

      if Send(self,@HasGuildCommand,#command_num=command_num)
      {
         return FALSE;
      }
      piGuild_Commands = piGuild_Commands | command_num;

      return TRUE;
   }

   RemoveGuildCommand(command_num=0)
   {
      piGuild_commands = piGuild_commands & ~command_num;

      return;
   }

   SetGuild(guild_obj=$)
   "Sets the player's poGuild to be equal to the guild object."
   {
      poGuild = guild_obj;
      Send(self,@EvaluatePKStatus,#dbug=TRUE);

      return;
   }

   QuitGuild()
   "Call this if you're an admin trying to kick someone out of a guild."
   "This will tell the guild to delete the user."
   {
      if poGuild <> $
      {
         Send(poGuild,@RemoveFromGuild,#who=self);
      }

      return;
   }

   ResetGuildStuff()
   "This should never be called directly, except from 'RemoveFromGuild' in"
   "guild.kod!  Otherwise, the guild lists may not match with player's poGuild!"
   {
      poGuild = $;
      piGuild_commands = 0;
      if poOwner <> $ AND Send(poOwner,@GetWatcher) <> $
      {
         Send(Send(poOwner,@GetWatcher),@PlayerQuitGuild,#who=self);
      }

      return;
   }

   %%%  Spells Stuff

   HasSpell(num = 0)
   "Returns TRUE if a spell is in a player's spell list,"
   "FALSE if it is not."
   {
      local i,oSpell;

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSpell(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used=TRUE
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSpellNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSpellAbility(compound = 0)
   {
      return Abs(compound) MOD 100;
   }

   GetSpellAbility(spell_num = 0)
   {
      local i;

      foreach i in plSpells
      {
         if Abs(i) / 100 = spell_num
         {
            return Abs(i) MOD 100;
         }
      }

      % This spell is not in the player's spell list. Return 0 ability.
      return 0;
   }

   ChangeSpellAbility(spell_num = 0, amount = 0, report = FALSE,
                      refigureschools = TRUE)
   {
      local i, bFound, elemNum, iAbility, bUsed, spellName, iChange,
            newAbility, oSpell, shrunken;

      oSpell = Send(SYS,@FindSpellByNum,#num=spell_num);
      if oSpell = $
      {
         return FALSE;
      }

      % Make sure user has this spell (should always have it if this is being called)
      bFound = FALSE;
      elemNum = 0;
      spellName = Send(oSpell,@GetName);
      iChange = 0;

      % Do _not_ replace with HasSpell.
      % This also finds the spell/ability pair and puts it in 'i' for later use.
      foreach i in plSpells
      {
         ++elemNum;
         if spell_num = Send(self,@DecodeSpellNum,#compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % Can't advance a spell you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if NOT bUsed
      {
         bUsed = -1;
      }

      iAbility = Send(self,@DecodeSpellAbility,#compound=i);
      newAbility = bound(iAbility+amount,1,99);
      iChange = newAbility-iAbility;

      SetNth(plSpells,elemNum,Send(self,@EncodeSpell,
            #num=spell_num,#iAbility=newAbility));
      Send(self,@DrawStatSpell,#index=elemNum);
      if report AND iChange > 0
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=spellName);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);

            % Report to shrunken head.
            shrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
            if shrunken <> $
            {
               Send(shrunken,@Improvement,#spellName=spellName);
            }
         }
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),#change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed in spell ability of ",spellname,
               " by ",iChange," to ",abs(i));
      }

      return TRUE;
   }

   AddToSchools(school=0, change=0)
   {
      local iOldValue, oLore;

      if school = $
         OR school < 1
         OR change = $
         OR change = 0
      {
         return FALSE;
      }

      if plSchools = $
      {
         % 11 elements right now.
         plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];
      }

      while length(plSchools) < school
      {
         plSchools = cons(0, plSchools);
      }

      iOldValue = Nth(plSchools,school);
      SetNth(plSchools,school,(iOldValue+change));

      oLore = Send(SYS,@GetLore);
      Send(oLore,@PlayerAdvanced,#who=self,#school = school);

      return TRUE;
   }

   RefigureSchoolsLists(informlore=FALSE)
   {
      local i, lOldList, oAbility, iSchool, iAbility, iValue, oLore, bChanged,
            index, iNum;

      lOldList = plSchools;

      % 11 elements right now.
      plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];

      foreach i in plSpells
      {
         iAbility = Send(self,@DecodeSpellAbility,#compound=i);
         iNum = Send(self,@DecodeSpellNum,#compound=i);
         oAbility=Send(SYS,@FindSpellByNum,#num=iNum);
         if IsClass(oAbility,&spell)
         {
            iSchool = Send(oAbility,@GetSchool);
            iValue = Nth(plSchools,iSchool);
            SetNth(plSchools,iSchool,(iValue+iAbility));
         }
      }

      foreach i in plSkills
      {
         oAbility=Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oAbility,@GetSchool);
         iAbility = Send(self,@DecodeSkillAbility,#compound=i);
         iValue = Nth(plSchools,iSchool);
         SetNth(plSchools,iSchool,(iValue+iAbility));
      }

      if informlore OR lOldList = $
      { 
         % Assume that something has changed
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school = iSchool);
         
         return;
      }

      % We want to know if something has changed.
      bChanged = FALSE;
      index = 0;
      foreach i in lOldList
      {
         index = index + 1;
         if Nth(lOldList,index) <> Nth(plSchools,index)
         {
            bChanged = TRUE;
         }
      }

      % If they changed, update them in the lore.
      if bChanged
      {
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school=-1);
      }

      return TRUE;
   }

   AdminSetSpell(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a spell by an additional or absolute value."
   {
      local oSpell, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSpellAbility,#spell_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSpell,#num=num,#iability=ability)
         {
            return player_admin_added_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 and add <= -oldAbility
      {
         if Send(self,@RemoveSpell,#num=num)
         {
            return player_admin_removed_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 and add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSpellAbility,#spell_num=num,#amount=add)
      {
         return player_admin_modified_spell;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSpell(num = 0, iability=0, bDM=FALSE, initial=FALSE, dontSend=FALSE)
   "Admin supported\n"
   "Adds a spell by spell ID to the user's castable list of spells"
   {
      local i, j, oSpell, lSpell_info, lPrereqs, bFound,
            iBoundAbility, lEncode;

      if Send(self,@HasSpell,#num=num)
      {
         if Send(self,@GetSpellAbility,#spell_num=num) < iAbility
         {
            Send(self,@ChangeSpellAbility,#spell_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

%  When I re-enabled the shadow rift spell, it was only sold by the lich,
%  and the Ao3/SotH quest that was needed to get the spell was broken and unfixable,
%  so I made the spell sold by a different NPC.  I had to remove this check
%  (which clearly doesn't belong in player; should be in the spell itself) to
%  make it buyable.  - ARK 10/26/2010
%
%      if num = SID_DEATHS_DOOR
%          AND ((NOT Send(self, @IsUsingA,#class=&NecromancerAmulet))
%               AND (NOT IsClass(self,&Admin)))
%      {
%         return FALSE;
%      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return FALSE;
      }
      
      lPrereqs = Send(oSpell,@GetPrerequisites);

      foreach i in lPrereqs
      {
         if NOT Send(self,@HasSpell,#num=i)
         {
            %Player can't learn this spell without all the prerequisites.
            return FALSE;
         }
      }

      % Spell format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSpell,@InitialAbility,#who=self);
      }

      lEncode = Send(self,@EncodeSpell,#num=num,#iability=iBoundAbility);
      plSpells = Cons(lEncode,plSpells);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added spell ",Send(oSpell,@GetName));
      }

      if dontSend = FALSE
      {
         Send(self,@ToCliAddSpell,#oSpell=oSpell);
      }

      if NOT bDM
         AND NOT initial
      {
          Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),
               #change=iBoundAbility);
      }

      if poOwner <> $
         AND NOT bDM
         AND NOT dontSend
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
              #wave_rsc=player_sound_learn_spell);
      }

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@PlayerIsIntriguing);

      return TRUE;
   }

   RemoveAllSpells()
   {
      local i;
      
      plSpells=$;
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," lost all spells.");
      }

      Send(self,@PlayerIsIntriguing);

      foreach i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@ToCliStats,#group=3);

      return TRUE;
   }

   RemoveSpell(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a spell by spell ID from the user's castable list of spells"
   {
      local oSpell, i, j, bFound;

      oSpell = Send(SYS,@FindSpellbyNum,#num=num);
      if oSpell = $
      {
         Debug("Trying to delete a spell that doesn't exist in system.");

         return FALSE;
      }

      bFound = FALSE;
      foreach i in plSpells
      {
         if num = Send(self,@DecodeSpellNum,#compound=i)
         {
            plSpells = DelListElem(plSpells,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," removed spell ",Send(oSpell,@GetName));
            }

            Send(self,@ToCliRemoveSpell,#oSpell=oSpell);
            Send(self,@PlayerIsIntriguing);

            bFound = TRUE;
            foreach j in plUsing
            {
               if IsClass(j,&DiscipleRobe)
               {
                  Send(j,@ResetColors);
               }
            }

            if NOT isDM
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

     Debug("Trying to delete a spell not on spell list",self,num);

     return FALSE;
   }

   WasSpellUsed(compound=0)
   {
      if compound > 0
      {
         return TRUE;
      }

      return FALSE;
   }


   FlipSpellAtrophyFlag(SID=0)
   "This spell was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, spellnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum + 1;
         if Send(self,@DecodeSpellNum,#compound=i) = SID
         {
            SetNth(plspells,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSpellAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSpell, bSpell,
            bFound, highmark, iAmount;

      % Must get below highmark for atrophy to activate
      iAmount = -2;

      foreach i in plSpells
      {
         if i < 0
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            if iAbility > 2
            {
               aSpell = Send(SYS,@FindSpellByNum,
                     #num=Send(self,@DecodeSpellNum,#compound=i));
               bFound = FALSE;

               foreach j in plSpells
               {
                  bSpell = Send(SYS,@FindSpellByNum,
                        #num=Send(self,@DecodeSpellNum,#compound=j));
                  if j > 0 AND Send(aSpell,@GetSchool) = Send(bSpell,@GetSchool)
                  {
                     iAmount = -1;

                     break;
                  }
               }
               Send(self,@ChangeSpellAbility,#spell_num=Send(aSpell,@GetSpellNum),
                    #amount=iamount);
            }
         }
      }

      return;
   }

   %%%  Skills Stuff

   HasSkill(num = $)
   "Returns TRUE if a Skill is in a player's Skill list,"
   "FALSE if it is not."
   {
      local i,oSkill;

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillNum,#compound=i) = num
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   EncodeSkill(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used
      {
         return num*100 + iability;
      }

      return -(num*100 + iability);
   }

   DecodeSkillNum(compound = 0)
   {
      return Abs(compound) / 100;
   }

   DecodeSkillAbility(compound = 0)
   {
      return Abs(compound) MOD 100;
   }

   GetSkillAbility(Skill_num = 0, absolute=FALSE)
   {
      local i;

      foreach i in plSkills
      {
         if Abs(i) / 100 = Skill_num
         {
            return Abs(i) MOD 100;
         }
      }

      % this Skill is not in the player's Skill list.  return 0 ability.
      return 0;
   }

   ChangeSkillAbility(Skill_num=0,amount=0,report=FALSE,refigureschools=TRUE,bDM=FALSE)
   {
      local i, bFound, elemnum, iability, bUsed, iChange, skillname, 
            newability, oSkill;

      oSkill = Send(SYS,@FindSkillByNum,#num=skill_num);
      if oSkill = $
      {
         return FALSE;
      }

      % Make sure user has this Skill (should always have it if this is being called)
      bFound = FALSE;
      elemnum = 0;
      skillname = Send(oSkill,@GetName);
      iChange = 0;

      % Do _not_ replace with HasSkill.
      % This also finds the Skill/ability pair and puts it in 'i' for later use.
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Skill_num = Send(self, @DecodeSkillNum, #compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % Can't advance in a skill you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if bUsed = 0
      {
         bUsed = -1;
      }

      iability = Send(self,@DecodeSkillAbility,#compound=i);
      newability = bound(iability+amount,1,99);
      iChange = newability - iability;

      % If we advance a stroke or a proficiency, then
      % reset our stroke count (and bonuses)
      if IsClass(oSkill,&Stroke) OR IsClass(oSkill,&Proficiency)
      {
         Send(self,@ResetWeaponSwings);
      }

      SetNth(plSkills,elemnum,Send(self,@EncodeSpell,#num=skill_num,
            #iability=newability));
      Send(self,@DrawStatSkill,#index=elemnum);
      if report AND (iChange > 0)
      {
         if poOwner <> $
         {
            Post(self,@MsgSendUser,#message_rsc=player_improved,
                  #parm1=skillName);
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=player_improved_wav_rsc);
         }
      }

      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed skill ",skillname,"by ",iChange,
               " to ",abs(i)); 
      }

      return TRUE;
   }

   AdminSetSkill(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a skill by an additional or absolute value."
   {
      local oSkill, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if oSkill = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSkillAbility,#skill_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSkill,#num=num,#iability=ability)
         {
            return player_admin_added_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 AND add <= -oldAbility
      {
         if Send(self,@RemoveSkill,#num=num)
         {
            return player_admin_removed_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 AND add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }

      if Send(self,@ChangeSkillAbility,#skill_num=num,#amount=add)
      {
         return player_admin_modified_skill;
      }

      return Send(SYS,@GetFailureRsc);
   }

   AddSkill(num=0,iability=0,bDM=FALSE,initial=FALSE,dontSend=FALSE)
   "Admin supported\n"
   "Adds a Skill by Skill ID to the user's castable list of Skills"
   {
      local i,j,oSkill, lSkill_info, lPrereqs, bFound, iBoundAbility;

      if Send(self,@HasSkill,#num=num)
      {
         % Already has it.
         if Send(self,@GetSkillAbility,#skill_num=num) < iAbility
         {
            Send(self,@ChangeSkillAbility,#skill_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if (oSkill = $)
      {
         % System has no info on this skill.
         return False;
      }

      % Skill format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSkill,@InitialAbility,#who=self);
      }

      plSkills = Cons(Send(self,@EncodeSkill,#num=num,
                     #iability=iBoundAbility),plSkills);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added skill ",Send(oSkill,@GetName));
      }

      if NOT dontSend
      {
         Send(self,@ToCliAddSkill,#oSkill=oSkill);
      }

      if NOT bDM and NOT initial
      {
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
               #change=iBoundAbility);
      }

      return True;
   }

   RemoveAllSkills()
   {
      plSkills = $;

      if Send(self,@checklog)
      {
         Debug("LOG:  ",vrName," loses all skills.");
      }

      Send(self,@ToCliStats,#group=4);

      return TRUE;
   }

   RemoveSkill(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a Skill by Skill ID from the user's castable list of Skills"
   {
      local oSkill, i, iVigorChange;

      oSkill = Send(SYS,@FindSkillbyNum,#num=num);
      if oSkill = $
      {
         Debug("Trying to delete a skill the system doesn't recognize.");

         return FALSE;
      }

      % If we remove Second Wind, we need to adjust the player's
      % resting vigor threshold.
      if num = SKID_SECOND_WIND
      {
         iVigorChange = (Send(self,@GetSkillAbility,
                              #Skill_num=SKID_SECOND_WIND) + 1) / 5;
         Post(self,@SetVigorRestThreshold,
               #amount=piVigor_rest_threshold - iVigorChange);
      }

      foreach i in plSkills
      {
         if num = Send(self,@DecodeSkillNum,#compound=i)
         {
            plSkills = DelListElem(plSkills,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," lost skill ",Send(oSkill,@GetName));
            }

            Send(self,@ToCliRemoveSkill,#oSkill=oSkill);

            if NOT isDM
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

      Debug("Tried to delete skill not in skill list",self,num);

      return FALSE;
   }

   FlipSkillAtrophyFlag(SKID=0)
   "This Skill was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, Skillnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum + 1;
         if Send(self,@decodeSkillNum,#compound=i) = SKID
         {
            SetNth(plSkills,elemnum,abs(i));

            break;
         }
      }

      return;
   }

   ActivateSkillAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSkill, bSkill,
            bFound, highmark, iAmount;

      iAmount = -2;

      foreach i in plSkills
      {
         if i < 0
         {
            iAbility = Send(self,@decodeSkillability,#compound=i);
            if iAbility > 2
            {
               aSkill = Send(SYS,@FindSkillByNum,
                     #num=Send(self,@DecodeSkillNum,#compound=i));
               bFound = FALSE;
               foreach j in plSkills
               {
                  bSkill = Send(SYS,@FindSkillByNum,
                        #num=Send(self,@DecodeSkillNum,#compound=j));
                  if j > 0 AND Send(aSkill,@GetSchool) = Send(bSkill,@GetSchool)
                     AND aSkill <> bSkill
                  {
                     iAmount=-1;
                     break;
                  }
               }

               Send(self,@ChangeSkillAbility,#skill_num=Send(aSkill,@GetSkillNum),
                    #amount=iAmount);
            }
         }
      }

      return;
   }

   %%%  Advancement

   ResetAtrophyFlags()
   "This sets all of a player's spell values to negative."
   "This means that the player has not used these spells in a while."
   "Meaning they have a chance to atrophy when ptAdvancement goes off."
   {
      local i, elemnum;

      % This system is usually off.
      if NOT Send(SETTINGS_OBJECT,@IsAtrophyOn)
      {
         return;
      }

      elemnum = 0;
      foreach i in plSpells
      {
         elemnum = elemnum+1;
         SetNth(plSpells,elemnum,-(abs(i)));
      }

      elemnum = 0;
      foreach i in plSkills
      {
         elemnum = elemnum+1;
         SetNth(plSkills,elemnum,-(abs(i)));
      }

      return;
   }

   AdvancementTimer()
   "This checks for spell or skill atrophy, "
   "and resets the atrophy flags."
   {
      ptAdvancement = $;

      if pbLogged_on
      {
         if Send(SETTINGS_OBJECT, @IsAtrophyOn)
         {
            Send(self,@ActivateSpellAtrophy);
            Send(self,@ActivateSkillAtrophy);
         }

         Send(self,@ResetAtrophyFlags);
      }

      return;
   }

   %%% Advancement in combat

   SomethingKilled(what=$,victim=$,use_weapon=$)
   {
      local i, bGainedCharge, oSpellDeathLink;

      if NOT IsClass(victim,&Battler)
      {
         propagate;
      }

      % If we have death link up, give a vigor boost
      oSpellDeathLink = Send(SYS,@FindSpellByNum,#Num=SID_DEATH_LINK);

      if Send(self,@IsEnchanted,#what=oSpellDeathLink)
      {
         Send(oSpellDeathLink,@GiveKilledBenefits,#Caster=self,#Victim=victim);
      }

      % Let our recharging rods know we killed something.
      if what = self
      {
         bGainedCharge = FALSE;

         foreach i in plPassive
         {
            if IsClass(i,&Rod)
               AND Send(i,@SomethingKilled,#what=what,#victim=victim)
            {
               bGainedCharge = TRUE;
            }
         }

         % Notify the player if he gained a charge on any recharging
         % wand (just one message for all of them)
         if bGainedCharge
         {
            Send(self,@MsgSendUser,#message_rsc=rod_gained_charge_msg);
         }
      }

      if victim = poKill_target
      {
         if what = self
         {
            Send(self,@AdvancementCheck,#what=victim,#killing_blow=TRUE);
         }
         else
         {
            Send(self,@AdvancementCheck,#what=victim,
                  #killing_blow=FALSE,#group_member=what);
         }

         Send(self,@ResetGainFlags);
      }
      else
      {
         % Let players share XP if they're grouped, even if
         % they're not fighting the same mob.
         if Send(poOwner,@AreGroupedHere,#who=self,#what=what)
         {
            Post(self,@AdvancementCheck,#what=victim,#killing_blow=FALSE,
                  #group_member_kill=TRUE,#group_member=what);
         }
      }

      propagate;
   }

   ResetGainFlags()
   {
      poKill_target = $;
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE, #value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_DODGED, #value=FALSE);

      return;
   }

   AdvancementCheck(what=$,killing_blow=TRUE,group_member_kill=FALSE,group_member=$)
   "A player will need, on average, to kill a number of monsters equal to"
   "their maxhealth to gain a HP.  This number is reduced by the player's"
   "stamina, all the way down to half for those with high staminas."
   {
      local i, dodgeskill, oSkill, monster_level, gain, gainmult, roll,
            oWeapon, lBuilderGroup, bGainedHP;

      gain = 0;
      roll = FALSE;
      bGainedHP = FALSE;

      % Some things just never allow advancement.
      % Can advance in arena if realdeath is on in an arena.
      if NOT Send(what,@CanPlayerAdvanceOnMe)
         OR Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         OR (Send(poOwner,@IsArena) AND NOT Send(poOwner,@ArenaRealDeath))
      {
         return FALSE;
      }

      if IsClass(what,&User)
      {
         monster_level = Send(what,@GetBaseMaxHealth);
      }
      else
      {
         monster_level = Send(what,@GetLevel);
      }

      if ((piFlags & PFLAG_DID_DAMAGE)
         AND poKill_target = what)
         OR group_member_kill
      {
         % Allow players to improve defensive spells!
         if killing_blow 
            AND ((piFlags & PFLAG_TOOK_DAMAGE)
               OR (piFlags & PFLAG_DODGED))
         {
            foreach i in plPassiveImprovement
            {
               if Nth(i,2) and random(1,5) = 5
               {
                  Send(First(i),@ImproveAbility,#who=self,#target=what);
               }
            }
         }

         if monster_level > piBase_Max_health
         {
            if killing_blow
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
            {
               % Player took damage and landed killing blow
               gain = 2;
               roll = TRUE;
            }
            else
            {
               % Player either did not take damage, but did killing blow (mage),
               %  or did take damage, did not land killing blow, or
               %  it's a group member kill.
               
               gain = 1;

               % We still roll for a tougher if we killed the monster but
               % didn't take damage or dodge, if we helped kill the monster,
               % or if it was a group member kill and the setting for group
               % member toughers is set to TRUE.
               if NOT group_member_kill
                  OR Send(SETTINGS_OBJECT,@GetGroupTougherSetting)
               {
                  roll = TRUE;
               }
               
               % Inform the player that a group kill successfully garnered XP.
               if group_member_kill
                  AND group_member <> $
                  AND gain = 1
               {
                  Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                        #parm1=Send(group_member,@GetName),
                        #parm2=Send(what,@GetName));
               }
               
               % Give an informative message about non-group
               % kills that are still shared
               if NOT killing_blow
                  AND NOT group_member_kill
                  AND group_member <> $
               {
                  Send(self,@MsgSendUser,#message_rsc=group_experience_rsc,
                        #parm1=Send(group_member,@GetName),
                        #parm2=Send(what,@GetName));
               }
            }
         }
         else
         {
            % Monster was equal or close to player level.  Small bonus,
            %  no roll chance.
            if (monster_level + 5) > piBase_Max_health
               AND IsClass(what,&monster) AND killing_blow 
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
            {
               gain = 1;
            }
            else
            {
               % Monster was too easy for player to kill!
               if random(1,100) < 30 AND killing_blow
               {
                  Send(self,@MsgSendUser,#message_rsc=player_spits);
               }
            }
         }

         % Give newbies a little bonus.
         if piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
         {
            gain = gain + 1;
         }
         else
         {
            % Give solo pkill-enabled builders a little bonus, for
            % appropriate monsters. This will roughly equal building 
            % with one other player in the room. Bonus requires that the 
            % player is fighting normally (no firewalls / distance killing)
            lBuilderGroup = Send(poOwner,@GetBuilderGroup);
            if (lBuilderGroup = $
                  OR Length(lBuilderGroup) = 1
                  OR (FindListElem(lBuilderGroup,self) = 0
                     AND (piPreferences & ~CF_GROUPING)))
               AND NOT group_member_kill
               AND killing_blow
               AND (monster_level + 5) > piBase_Max_health
               AND ((piFlags & PFLAG_TOOK_DAMAGE)
                  OR (piFlags & PFLAG_DODGED))
            {
               gain = gain + 1;
            }
         }
         
         % Give a bonus for Survival Rooms
         if Send(what,@GetBoostedLevel) > 0
         {
            gain = gain + (Send(what,@GetBoostedLevel)
                 / Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalXP));
         }

         % If they're cheesing the situation by fighting wussy monsters
         % in an altered form, penalize the gain amount.
         if piMax_health > piBase_Max_health * 2
            AND monster_level < piMax_health
         {
            gain = gain / 2;
            roll = FALSE;
         }

         gainmult = Bound(Send(SETTINGS_OBJECT,
                     @GetHPGainMultiplier),1,500);
         gain = gain * gainmult;

         piGain_chance = piGain_chance + gain;

         % Here, we work out if the player deserves a training point.
         % They qualify if they got at least one gain point from the monster,
         % and also got the killing blow (no double points from single mobs).
         if gain > 0
            AND killing_blow
            AND piTraining_points < 1000
         {
            piTraining_points = piTraining_points + 1
               + (Send(what,@GetBoostedLevel)
               / Send(Send(SYS,@GetSurvivalRoomMaintenance),@GetSurvivalTP));

            if monster_level > 75
            {
               if monster_level <= 121
               {
                  piTraining_points = piTraining_points + 1;
               }
               else
               {
                  if monster_level <= 150
                  {
                     piTraining_points = piTraining_points + 2;
                  }
                  else
                  {
                     piTraining_points = piTraining_points + 3;

                  }
               }
            }
         }

         % Let the player know how many training points they have, if they
         % either reached the max, or a multiple of 100.
         if piTraining_points > 999
         {
            if piInform
            {
               Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
                  #parm1=piTraining_points);
               piInform = FALSE;
            }
         }
         else
         {
            if piTraining_points MOD 100 = 0
               AND piTraining_points <> 0
               AND piInform
            {
               Send(self,@MsgSendUser,#message_rsc=player_training_inform,
                     #parm1=piTraining_points);
            }
         }

         % Draw the training points bar.
         Post(self,@DrawTraining);

         % RollForTougher handles the actual tougher check. Will return
         % TRUE if player gains a HP, FALSE if they don't.
         if roll
         {
            bGainedHP = Send(self,@RollForTougher,#iLevel=monster_level);
         }
      }

      % Draw the tougher chance bar. Send this here because RollForTougher
      % will also draw it, no need to do so twice.
      if NOT roll
      {
         Post(self,@DrawHPChance);
      }

      if (piFlags & PFLAG_DODGED)
         AND NOT group_member_kill
      {
         oWeapon = Send(self,@LookupPlayerWeapon);
         if oWeapon <> $
            AND (not IsClass(oWeapon,&RangedWeapon))
            AND Send(self,@HasSkill,#num=SKID_PARRY)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_PARRY) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_PARRY);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if (Send(self,@LookupPlayerShield) <> $)
            AND Send(self,@HasSkill,#num=SKID_BLOCK)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_BLOCK) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_BLOCK);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }

         if Send(self,@HasSkill,#num=SKID_DODGE)
            AND Send(self,@GetSkillAbility,#skill_num=SKID_DODGE) < 99
         {
            oSkill=Send(SYS,@FindSkillByNum,#num=SKID_DODGE);
            Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
         }
      }

      % If RollForTougher returned TRUE, we gained a hitpoint.
      return bGainedHP;
   }

   RollForTougher(iLevel=0)
   "Handles the roll for tougher based on the player's gain chance plus "
   "the iLevel parameter.  Returns TRUE if the player gaints a hit point, "
   "FALSE otherwise.  The iLevel parameter has the player's base max HP "
   "taken from it, then divided by 5 before being bound between 1 and 10."
   {
      local iRandom, iNumber, oShrunken;

      if iLevel = $
      {
         iLevel = 0;
      }

      iRandom = Random(1,Send(self,@GetHighMark));
      iNumber = piGain_chance + Bound((iLevel-piBase_Max_health)/5,0,10);

      % Draw tougher chance bar.
      Post(self,@DrawHPChance);

      if iRandom < iNumber
         AND piBase_Max_health < (101 + Send(self,@GetStamina))
      {
         Send(self,@GainBaseMaxHealth,#amount=1);
         if Send(self,@CheckLog)
         {
            Debug("LOG:  ",vrName," gained a health point: ",
                  piMax_health,pibase_max_health);
         }

         Send(self,@EvaluatePKStatus);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=player_improve_maxhealth);
            Send(self,@WaveSendUser,#what=self,#wave_rsc=player_tougher_wav_rsc);

            % Boost the player to max health, and give them 200 vigor.
            Send(self,@MsgSendUser,#message_rsc=player_improve_health_invigorate);
            piHealth = piMax_Health * 100;
            Send(self,@DrawHealth);
            Send(self,@EatSomething,#nutrition=200);
            Post(self,@DrawOffense);
            Post(self,@DrawDefense);

            % Report to shrunken head, if they have one.
            oShrunken = Send(self,@FindHolding,#class=&ShrunkenHead);
            if oShrunken <> $
            {
               Send(oShrunken,@Tougher,#hp=pibase_max_health);
            }
         }

         piGain_chance = -(piBase_Max_health / 2);

         if piBase_max_health > 30
         {
            %stam = 50
            %pigain = pigain - ((50-50)/2) =  pigain - 0
            %stam = 25 
            %pigain = pigain - ((50-25)/2) = pigain - 12.5
            % So, after 30 hps, any stamina less than 50
            % penalizes you by about 0.5 piGain points
            piGain_chance = piGain_chance - ((50-Send(self,@GetStamina))/2);
         }

         return TRUE;
      }

      return FALSE;
   }

   GetGainChance()
   {
      return piGain_chance;
   }

   AddGainChance(iAmount=$)
   {
      if iAmount <> $
         AND iAmount <> 0
      {
         piGain_chance = piGain_chance + iAmount;

         if pbLogged_on
         {
            if iAmount > 0
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_gained,
                  #parm1=iAmount);
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=player_experience_lost,
                  #parm1=iAmount);
            }

            Post(self,@DrawHPChance);
         }
      }

      return;
   }

   GetTrainingPoints()
   {
      return piTraining_points;
   }

   AddTrainingPoints(points=0,report=TRUE,bCap=TRUE)
   {
      if points = 0
      {
         return;
      }

      if bCap
      {
         if piTraining_points <= 1000
         {
            points = bound(points,-piTraining_points,1000 - piTraining_points);
         }
         else if points > 0
         {
               % We're respecting the 1000 point cap, have more than 1000
               % points and are trying to add more. Don't add the points,
               % return out.
               return;
         }
      }

      if report AND points > 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_gained_training,
               #parm1=points);
      }

      if report AND points < 0
      {
         Send(self,@MsgSendUser,#message_rsc=player_spent_training,
               #parm1=-points);
      }

      piTraining_points = piTraining_points + points;

      if piTraining_points < 1000
         OR NOT bCap
      {
         piInform = TRUE;
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=player_reached_maxtraining,
               #parm1=piTraining_points);
         piInform = FALSE;
      }

      Post(self,@DrawTraining);

      return;
   }

   GetDailyTrainingReward()
   {
      local iBonus;

      ptReward_timer = CreateTimer(self,@GetDailyTrainingReward,24*60*60*1000);

      if piTraining_points >= 1000
      {
         return;
      }

      % Retrieve the daily logon bonus from settings.
      iBonus = Send(SETTINGS_OBJECT,@GetLogonBonus);

      Send(self,@MsgSendUser,#message_rsc=player_logon_bonus,#parm1=iBonus);
      Send(self,@AddTrainingPoints,#points=iBonus,#report=FALSE);

      piReward_timestamp = GetTime();

      return;
      
   }

   GetHighMark()
   {
      local index, highmark;

      index = (piBase_Max_health*(100-Send(self,@GetStamina)))/100;
      highmark = (index+1)*index;

      return highmark;
   }

   %%% Player Killed %

   Killed(what = $, stroke_obj = $)
   {
      local lItems,i, j, amount, oBody, oSoldierShield, bNo_drop_death, oItemAtt,
            oRoom, iRow, iCol, iFine_Row, iFine_Col, iAngle, oItem,
            iRoom, lInventoryContents, lReagentBagContents;

      % If this player has created any evil twins, delete them.
      if plEvilTwins <> $
      {
         foreach i in plEvilTwins
         {
            Send(i,@Delete);
         }
         plEvilTwins = $;
      }

      % If we have Apparitions attacking us, delete them.
      if plApparitionList <> $
      {
         foreach j in plApparitionList
         {
            Send(j,@Delete);
         }
         plApparitionList = $;
      }

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
      {
         return;
      }

      if poOwner <> $
         AND IsClass(poOwner,&Room)
         AND Send(poOwner,@OverridesDeathFunction)
      {
         Send(poOwner,@OverrideDeathFunction,#who=self,#what=what);

         return;
      }

      % Skill, spell and hp penalties are handled by ApplyDeathPenalties, which
      % is called from LeaveHold() in the Underworld.  This is to allow time
      % for Portal of Life to reduce penalties.  We get the default value of
      % piDeathCost from SYS, so that we can adjust global death penalties.
      % "Normal" value is 100.
      piDeathCost = Send(SETTINGS_OBJECT,@GetDefaultDeathCost);

      % A player (probably) cannot die twice in two seconds in any valid way.
      if GetTime() < (piLastDeathTime + 2)
      {
         Debug("Averted double-death of",vrName);

         return;
      }

      % Stop any rescue attempts that were going on.
      Send(self,@CancelRescue);
      
      piLastDeathTime = getTime();

      % Grab the location of the deceased.
      % Might need to grab the old location if logged off.

      if pbLogged_on
      {
         oRoom = poOwner;
         iRow = piRow;
         iCol = piCol;
         iFine_Row = piFine_Row;
         iFine_Col = piFine_Col;
         iAngle = Send(self,@GetAngle);
         iRoom = Send(poOwner,@GetRoomNum);
      }
      else
      {
         if NOT Send(self,@IsUsingA,#class=&NecromancerAmulet)
         {
            Debug("Player died while offline, but not a necromancer: ",
                  Send(self,@GetName));
         }

         iRoom = Send(self,@GetSaveRoom);
         oRoom = Send(SYS,@FindRoomByNum,#num=iRoom);
         iRow = Send(self,@GetSaveRow);
         iCol = Send(self,@GetSaveCol);
         iFine_Row = Send(self,@GetSaveFineRow);
         iFine_Col = Send(self,@GetSaveFineCol);
         iAngle = Send(self,@GetSaveAngle);
      }

      % Any other quick escapes from certain death?
      % Such as the Arena "loser", or while in the Out of Grace prison.
      % These aren't cheap deaths, these are ways to avoid actual death.
      if pbLogged_on
         AND ((Send(poOwner,@IsArena)
               AND Send(poOwner,@InPlay,#what=Self)
               AND NOT Send(poOwner,@ArenaRealDeath))
              OR IsClass(poOwner,&OutOfGrace)
              OR Send(poOwner,@SafePlayerAttack))
      {
         piHealth = 1;
         Send(self,@NewHealth);

         % Currently, the following block is only for
         % Necromancer Amulets and Hunter Swords.
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }

         return;
      }

      % Okay, we're really dying now.
      % Now we need to determine if it's a 'cheap'
      % death where we don't lose stuff.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      bNo_drop_death = FALSE;

      % Reign of Blood Frenzy death?  Newbie death?
      % Don't drop anything or take any penalties.
      if Send(SYS,@GetChaosNight)
        OR (iRoom >= RID_NEWB_BASE AND iRoom <= RID_NEWB_MAX)
        OR Send(self,@HasHonorString,#string=player_newbie_honor_string)
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
      }

      % Currently, the following block is only for Necromancer Amulets
      % and Hunter Swords. This is placed before the token death check,
      % so that token deaths _will_ make you lose your artifact.
      if bNo_drop_death
      {
         foreach i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }
      }

      % Record-keeping. Keep this before the token check,
      % so we can give proper message.
      Send(SYS,@UserKilled,#what=self,#killer=what,#oRoom=oRoom,#stroke_obj=stroke_obj);
      Send(Send(SYS,@GetStatistics),@PlayerDiedCounter);

      % Token death?
      i = GetListElemByClass(plUsing,&Token);
      if i <> $
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;
         Send(self,@MsgSendUser,#message_rsc=player_token_death);
         Send(i,@NewUnused,#what=self,#where=oRoom);
      }

      % Create the corpse.
      oBody = Send(self,@CreateCorpse);
      Send(oRoom,@NewHold,#what=oBody,#new_row=iRow,#new_col=iCol,
            #fine_row=iFine_Row,#fine_col=iFine_Col,#new_angle=iAngle);

      % Start losing stuff if applicable.
      if NOT bNo_drop_death
      {
         if ptHealth <> $
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }

         % Lose the inventory.  It falls onto the corpse.
         if (what = $) OR (NOT IsClass(what,&user))
         {
            oItemAtt = $;
         }
         else
         {
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_PKPOINTER);

            if what <> $
            {
               % We've been killed by a player, so set the PKed flag for
               % the temp safety angel to trigger later, provided we meet
               % all the requirements. Check for not $ here - fastest way
               % to implement this without performing another IsClass check.
               piFlags = piFlags | PFLAG_KILLED_BY_PLAYER;
            }
         }

         lReagentBagContents = Send(self,@GetReagentBagContents);
         if lReagentBagContents <> $
         {
            lInventoryContents = [plActive,plPassive,lReagentBagContents];
         }
         else
         {
            lInventoryContents = [plActive,plPassive];
         }

         foreach lItems in lInventoryContents
         {
            foreach i in lItems
            {
               % Let the item know we died, in case it does something special.
               Send(i,@OwnerKilled);

               if Send(i,@DropOnDeath)
               {
                  if Send(oRoom,@ReqNewHold,#what=i,#new_row=iRow,#new_col=iCol)
                  {
                     if oItemAtt <> $
                     {
                        % We know this was a pk.  Only let PKillables pick up the loot.
                        % Put the appropriate item attribute on it.
                        Send(oItemAtt,@AddToItem,#oItem=i,
                              #timer_duration=PKPOINTER_TIME,
                              #state1=self);
                     }

                     Send(oRoom,@NewHold,#what=i,#merge=FALSE,
                           #new_row=iRow,#new_col=iCol,
                           #fine_row=iFine_row,#fine_col=iFine_col);
                  }
               }
            }
         }

         % Atrophy of skills or learning progress.
         piGain_chance = piGain_chance/2;
         Send(self,@ResetGainFlags);
         Send(self,@ResetAtrophyFlags);
         if ptAdvancement <> $
         {
            DeleteTimer(ptAdvancement);
            ptAdvancement = $;
         }

         Post(self,@EvaluatePKStatus);

         % Let SoldierShields know we died. It handles itself as appropriate.
         oSoldierShield = Send(self,@FindUsing,#what=&SoldierShield);
         if oSoldierShield <> $
         {
            Send(oSoldierShield,@OwnerDied,#what=what);
         }

         % Positive karma makes us eligible for a booby prize.
         if piKarma > 5000 AND (Send(self,@GetHomeRoom) <> RID_NEWB1)
         {
            % To prevent mule money abuse, make the hammer "created".
            % This makes it worthless to try to sell. It lasts for 5 hours.
            oItem = Create(&Hammer);
            oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
            Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
            Send(self,@NewHold,#what=oItem);
         }
         else
         {
            if piKarma >= 0
            {
               % To prevent mule money abuse, make the mace "created".
               % This makes it worthless to try to sell. It lasts for 5 hours.
               oItem = Create(&Mace);
               oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
               Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
               Send(self,@NewHold,#what=oItem);
            }
         }
      }

      % Give out your dying scream.
      if piGender = GENDER_FEMALE
      {
         i = playerf_death_wav;
      }
      else
      {
         i = playerm_death_wav;
      }

      Send(oRoom,@SomethingWaveRoom,#what=oBody,#wave_rsc=i);
      if pbLogged_on
      {
         Send(self,@WaveSendUser,#what=self,#wave_rsc=i);
      }

      % Teleport to the Underworld.
      Send(self,@UserGotoDeadRoom);
      
      % Change health, mana, vigor.
      if Send(SYS,@GetChaosNight)
      {
         % It's a frenzy!  Give us a leg up.
         piHealth = 80*piMax_Health;
         piMana = 4*(piMax_Mana/5);
         piVigor = 200;
      }
      else
      {
         % We're not in a frenzy.  Give us the bare minimums.
         piMana = 1;
         piHealth = 1;
         piVigor = Bound(piVigor/4,15,50);
      }

      Send(self,@NewHealth);
      Send(self,@NewMana);
      Send(self,@NewVigor);

      % Refresh the client with what's really going on.
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);

         % Wake up with red foggy hangover.
         Send(self,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=5000);
      }

      if piDeathCost > 0
         AND NOT (piFlags & PFLAG_TUTORIAL)
         AND NOT (piFlags & PFLAG_MURDERER)
      {
         % Give an encouraging gmail and some mana to broadcast.
         Send(self,@ReceiveNestedMail,#from=player_angel,
               #dest_list=[self],#nest_list=[4,player_death_mail]);
         Send(self,@MsgSendUser,#message_rsc=player_death_mail_notice);

         % Give them half their mana to broadcast for help with.
         piMana = (piMax_mana / 2) + 2;
         Send(self,@NewMana);
      }

      if poOwner = oRoom
      {
         Debug("Player didn't teleport after death!",vrName);
      }

      propagate;
   }

   ApplyDeathPenalties()
   {
      local iAmount, bLostHealth, i, bTempSafe;

      bTempSafe = FALSE;

      if (piFlags & PFLAG_KILLED_BY_PLAYER)
      {
         bTempSafe = TRUE;
         piFlags = piFlags & ~PFLAG_KILLED_BY_PLAYER;
      }

      if Send(self,@GetDeathRiftProtection)
      {
         % Leaving the Underworld while protected, no penalties. Protection
         % is removed in NewOwner to allow them to log off without penalties.
         return;
      }

      if Send(SYS,@GetChaosNight)
      {
         % Remove any revenants.
         Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);

         % Return out.  Don't apply death penalties during frenzies.
         return;
      }

      bLostHealth = FALSE;

      % Lose your revenant, satisfied if you took a real death.
      if piDeathCost >= Send(SETTINGS_OBJECT,@GetDefaultDeathCost)
      {
         % As an outlaw, justice was met by dying. But, not if it's a cheap death!
         Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
         Post(self,@EvaluatePKStatus);

         if (piFlags & PFLAG_HAUNTED)
         {
            if pbLogged_on
            {
               Send(self,@MsgSendUser,#message_rsc=player_haunted_off);
            }

            Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
         }
      }

      % Only do this stuff if the cost of death is not zero.
      if piDeathCost > 0
      {
         if NOT (piFlags & PFLAG_TUTORIAL)
            AND NOT (piFlags & PFLAG_MURDERER)
         {
            piDeathCost = piDeathCost / 3;
         }
         else
         {
            % If you're not new, chance to lose a hp!
            if Random(1,100) <= piDeathCost
            {
               Send(self,@GainBaseMaxHealth,#amount=-1);
               bLostHealth = TRUE;
            }

            % Under 100HP and killed by a player? Receive a temporary angel.
            if bLostHealth
               AND bTempSafe
               AND piBase_max_health <= 99
               AND NOT ((piFlags & PFLAG_MURDERER)
                  OR (piFlags & PFLAG_OUTLAW))
               AND (piPreferences & CF_TEMPSAFE)
               AND Send(self,@FindUsing,#class=&SoldierShield) = $
               AND ptTempSafe = $
            {
               Post(self,@StartTempSafe);
            }
         }
      }
      else
      {
         return;
      }

      if Send(self,@CheckLog)
      {
         if bLostHealth
         {
            Debug("LOG:  ",vrName," died, lost a health point: ",
                  piMax_health,pibase_max_health,"Death Cost = ",piDeathCost);
         }
         else
         {
            Debug("LOG:  ",vrName," died, but made death cost check: ",
                  piDeathCost);
         }
      }

      % Remove from guild if now under min HP
      if piBase_max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
      {
         Send(self, @QuitGuild);
      }

      % Lose some skill or spell proficiency.

      % Murderers get hit harder.
      if (piFlags & PFLAG_MURDERER)
      {
         iAmount = -2;
      }
      else
      {
         iAmount = -1;
      }

      foreach i in plSpells
      {
         if Send(self,@DecodeSpellAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSpellAbility,#spell_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      foreach i in plSkills
      {
         if Send(self,@DecodeSkillAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSkillAbility,#skill_num=Send(self,@DecodeSpellNum,
                  #compound=i),#amount=iAmount);
         }
      }

      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);
      }

      Debug("Player ",Send(self,@GetTrueName),self," took death penalties of ",
            piDeathCost," percent.");

      piDeathCost = 0;

      return;
   }

   SetDeathCost(DeathCost = $, bOverride = FALSE)
   {
      % Don't raise the cost of death, unless we want to override it.
      if DeathCost < piDeathCost
         OR bOverride
      {
         piDeathCost = DeathCost;
      }

      return;
   }

   GetDeathCost()
   {
      return piDeathCost;
   }

   CreateCorpse(Assassinated=FALSE)
   {
      local inKocatan;

      % Send current pant/shirt color to body only if they both use
      % the new two-color xlats. Otherwise, Send default colors.
      inKocatan = FALSE;
      if pbLogged_on
      {
         if Send(poOwner,@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }
      else
      {
         if Send(Send(SYS,@FindRoomByNum,
               #num=Send(self,@GetSaveRoom)),@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }

      if Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetBodyTranslation))
         AND Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetLegsTranslation))
      {
         if piGender = GENDER_MALE
         {
            % male, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan);
         }
         else
         {
            % female, current colors
            return Create(&DeadBody,
                          #victim=self,
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan);
         }
      }

      if piGender = GENDER_MALE
      {
         % male, default colors
         return Create(&DeadBody,
                       #victim=self,
                       #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                       #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                       #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                       #inKocatan = inKocatan);
      }
      % female, default colors
      return Create(&DeadBody,
                    #victim=self,
                    #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                    #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                    #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                    #inKocatan = inKocatan);
   }

   GetDeadName()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_name_rsc;
      }
      
      return player_dead_female_name_rsc;

   }
   
   GetDeadIcon()
   {
      if piGender = GENDER_MALE
      {
         return player_dead_male_icona_rsc;
      }
 
      return player_dead_female_icona_rsc;
   }
   
   FreeHands()
   "Attempts to remove all items from hands if possible."
   {
      local i;

      foreach i in plUsing
      {
         if (Send(i,@GetItemUseType) & ITEM_USE_HAND)
            AND Send(i,@ReqUnuse)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   DoDance()
   {
      local i, iSpace;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_dance);

            return FALSE;
         }
      }

      if ptRest <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_dance_resting);

         return FALSE;
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_dance);

      piAnimation = PANM_DANCE;
      Send(poOwner,@SomethingChanged,#what=self);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=TRUE,#flagset=2);
      piAnimation = PANM_NONE;

      return;
   }

   StopDancing()
   {
      Send(self,@MsgSendUser,#message_rsc=player_stop_dance);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=FALSE,#flagset=2);
      Send(poOwner,@SomethingChanged,#what=self);
      
      return;
   }

   DoWave()
   "Causes the user do the wave animation, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_wave);

      piAnimation = PANM_WAVE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoFistAttack()
   "Causes the user do the fight animation w/fist, 1st and 3rd person"
   {
      Send(self,@DoWindowOverlayFistAttack);

      piAnimation = PANM_FIST_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoPoint()
   "Causes the user to point, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_point);

      piAnimation = PANM_POINT;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoCast()
   "Causes the user to do spell casting arm, 1st & 3rd person"
   {
      Send(self,@DoWindowOverlayHandGlow);

      piAnimation = PANM_CAST;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoBowFire()
   {
      piAnimation = PANM_BOW_FIRE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoWindowOverlayFistAttack()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         AddPacket(1,ANIMATE_ONCE, 4,175, 2,1, 2,3, 2,0);
         AddPacket(1,0);

         SendPacket(poSession);
      }

      return;
   }

   DoWindowOverlayHandGlow()
   {
      local i,iGroup;

      if pbLogged_on
      {
         iGroup = 0;
         foreach i in plWindow_overlays
         {
            if Send(i,@GetWindowOverlayID) = PWO_RIGHT_HAND
            {
               % Of right hand overlay already exists, we can't
               % restore it correctly yet, so just don't change it
               return;
            }
         }

         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         AddPacket(1,ANIMATE_ONCE,4,300,2,4,2,6,2,iGroup);
         AddPacket(1,1);
         AddPacket(4,player_window_overlay_glow, 1,HS_RIGHT_HAND,
                   1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,0);

         SendPacket(poSession);
      }

      return;
   }

   SetWindowOverlay(what = $)
   "Sends a message to the client about a window overlay, and adds <what> "
   "to plWindow_overlays."
   {
      Send(self,@AddWindowOverlayObject,#what=what);
      Send(self,@ChangeWindowOverlay,#what=what);

      return;
   }

   ChangeWindowOverlay(what = $)
   "Things can call this when they have a current window overlay and want "
   "to change it, such as for an attack.  Note--it's NOT verified that it's "
   "in plWindow_overlays."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,Send(what,@GetWindowOverlayHotspot));
         AddPacket(4,Send(what,@GetWindowOverlayID)); % supposedly "object id" in client
         AddPacket(4,Send(what,@GetWindowOverlay));
         AddPacket(4,Send(what,@GetName)); % useless field, used to make client parsing easier
         % Flags, drawing flags, minimapflags, namecolor, playertype, moveon type.
         AddPacket(4,0, 1,0, 4,0, 4,0, 1,0, 1,0);
         Send(what,@SendWindowOverlayAnimation);
         Send(what,@SendWindowOverlayOverlays);

         SendPacket(poSession);
      }

      return;
   }

   AddWindowOverlayObject(what = $)
   "Adds <what> to plWindow_overlays, in case the user leaves and relogs on"
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            return;
         }
      }

      plWindow_overlays = Cons(what,plWindow_overlays);

      return;
   }

   RemoveWindowOverlay(what = $)
   "Removes <what> from plWindow_overlays if it's in there, "
   "after updating client."
   {
      Send(self,@ChangeWindowOverlay,#what=what);
      Send(self,@RemoveWindowOverlayObject,#what=what);

      return;
   }

   RemoveWindowOverlayObject(what = $)
   "Removes <what> from plWindow_overlays if it's in there."
   {
      local i;

      foreach i in plWindow_overlays
      {
         if i = what
         {
            plWindow_overlays = DelListElem(plWindow_overlays,what);
            return;
         }
      }

      return;
   }

   VerifyOverlays()
   "Removes overlays of any overlaid item whose owner is not the player."
   {
      local i;

      foreach i in plOverlays
      {
         if Send(i,@GetOwner) <> self
         {
            Send(self,@RemoveOverlay,#what=i);
         }
      }

      return;
   }

   SetOverlay(what = $)
   "Adds <what> to plOverlays, and tells everyone we changed."
   {
      Send(self,@AddOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveOverlay(what = $)
   "Removes <what> from plOverlays if it's in there, and "
   "tells everyone we changed."
   {
      Send(self,@RemoveOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   AddOverlayObject(what = $)
   "Adds <what> to plOverlays, so we can keep track of whom to "
   "call about overlays"
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            return;
         }
      }

      plOverlays = Cons(what,plOverlays);

      return;
   }

   RemoveOverlayObject(what = $)
   "Removes <what> from plOverlays if it's in there."
   {
      local i;

      foreach i in plOverlays
      {
         if i = what
         {
            plOverlays = DelListElem(plOverlays,what);

            return;
         }
      }

      return;
   }

   RemoveHair(what = $)
   {
      if what = $
      {
         return;
      }

      poHair_remove = what;
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   ResetHair()
   {
      poHair_remove = $;

      if poOwner
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx | drawfx;
      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx & drawfx;

      if poOwner <> $ AND SendSomethingChanged
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIcon(what = $,new_icon = $,translation = $, alldone = TRUE)
   "Sets our icon to <new_icon>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poIcon_set = what;
      vrIcon = new_icon;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
                  (translation * PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   GetPlayerIcon()
   {
      return vrIcon;
   }

   ResetPlayerIcon(alldone=TRUE)
   "Sets our icon to its natural, unarmored state."
   {
      local i;

      poIcon_set = $;

      % A player may be wearing something under his armor.
      foreach i in plUsing
      {
         % Shirt or armor.
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            Send(i,@SetIcon);

            return;
         }
      }

      if piGender = GENDER_MALE
      {
         vrIcon = player_male_icon_rsc;
      }
      else
      {
         vrIcon = player_female_icon_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultShirtTranslation)*PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerArms(what=$,new_left_arm=$,new_right_arm=$,translation=$,alldone=TRUE)
   "Sets our legs to <new_legs>, and keeps track of <what> to undo "
   "when necessary. Tells everyone we changed."
   {
      poArms_set = what;
      prleft_Arm = new_left_arm;
      prRight_Arm = new_right_arm;

      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (translation * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerArms(alldone = TRUE)
   "Sets our icon to its natural, default-shirted state."
   {
      local iShirt_xlat, i, bFound;
      poArms_set = $;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@OverrideArms)
         {
            % Gauntlets, probably.
            prRight_arm = Send(i,@GetOverrideRightArm,#who=self);
            prleft_arm = Send(i,@GetOverrideleftArm,#who=self);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         if piGender = GENDER_MALE
         {
            prRight_arm = player_Rightarm_a_rsc;
            prLeft_arm = player_leftarm_a_rsc;
         }
         else
         {
            prRight_arm = player_Rightarm_b_rsc;
            prLeft_arm = player_leftarm_b_rsc;
         }
      }

      iShirt_xlat = Send(self,@GetDefaultShirtTranslation);
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 |
            (iShirt_xlat * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerLegs(what = $,new_legs = $,translation = $)
   "Sets our legs to <new_legs>, and keeps track of <what> to "
   "undo when necessary. Tells everyone we changed."
   {
      poLegs_set = what;
      prLegs = new_legs;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
               (translation * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerLegs()
   "Sets our icon to its natural, un-panted state."
   {
      poLegs_set = $;

      if piGender = GENDER_MALE
      {
         prLegs = player_legs_a_rsc;
      }
      else
      {
         prLegs = player_legs_b_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations |
            (Send(self,@GetDefaultPantsTranslation) * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetDefaultClothes(pants_color=-1,shirt_color=-1,rand=FALSE,increment=TRUE)
   {
      local shirt_color_xlat, pants_color_xlat, skin_color, i,
            bShirt, bLegs, bArms;

      skin_color = Send(self,@GetSkinColor);
      skin_color = Send(self,@ConvertSkinColorToXLAT,#skin_color=skin_color);

      if rand
      {
         pants_color = random(XLAT_TO_SKIN1, XLAT_TO_SKIN4);
         shirt_color = random(XLAT_TO_ORANGE, XLAT_HIGH_VALUE);
         if shirt_color = XLAT_TO_SKIN4
         {
            shirt_color = XLAT_TO_RED;
         }

         shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=shirt_color,#color2=skin_color);
         pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                 #color1=pants_color,#color2=skin_color);
      }

      else
      {
         if shirt_color = -1
         {
            shirt_color_xlat = Send(self,@GetDefaultShirtTranslation);
         }
         else
         {
            shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=shirt_color,#color2=skin_color);
         }

         if pants_color = -1
         {
            pants_color_xlat = Send(self,@GetDefaultPantsTranslation);
         }
         else
         {
            pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,
                                    #color1=pants_color,#color2=skin_color);
         }
      }

      piDefault_clothes = (shirt_color_xlat*SHIRT_MUL) | (pants_color_xlat*PANTS_MUL);

      bShirt = FALSE;
      bLegs = FALSE;
      bArms = FALSE;

      foreach i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
         {
            bArms = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            % ITEM_USE_BODY is armor
            bShirt = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_LEGS
         {
            bLegs = TRUE;
         }
      }

      if NOT bArms
      {
         Send(self,@ResetPlayerArms);
      }

      if NOT bShirt
      {
         Send(self,@ResetPlayerIcon);
      }

      if NOT bLegs
      {
         Send(self,@ResetPlayerLegs);
      }

      Send(self,@RefreshPlayerVisualGear);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RefreshPlayerVisualGear()
   {
      local n, lRefreshItemTypes, i, iHighestLayer, oHighestGear,
            iLowestLayer, oLowestGear, oSoldierShield, bSoldierShieldSlung;

      lRefreshItemTypes = [ITEM_USE_SHIRT,ITEM_USE_BODY,ITEM_USE_LEGS];

      foreach n in lRefreshItemTypes
      {
         iHighestLayer = 0;
         oHighestGear = $;
         foreach i in plUsing
         {
            if IsClass(i,&DefenseModifier)
               AND Send(i,@GetItemUseType) & n
            {
               if Send(i,@GetLayer) >= iHighestLayer
               {
                  iHighestLayer = Send(i,@GetLayer);
                  oHighestGear = i;
               }
            }
         }

         if oHighestGear <> $
         {
            Send(oHighestGear,@DoPlayerArt);
         }
      }

      % Check for headgear, which has special overlays
      % In this case, we actually refresh the lowest layer to put it underneath
      iLowestLayer = 100000;
      oLowestGear = $;
      foreach i in plUsing
      {
         if IsClass(i,&DefenseModifier)
            AND Send(i,@GetItemUseType) & ITEM_USE_HEAD
         {
            if Send(i,@GetLayer) <= iLowestLayer
            {
               iLowestLayer = Send(i,@GetLayer);
               oLowestGear = i;
            }
         }

         if oLowestGear <> $
         {
            Send(oLowestGear,@UndoPlayerArt);
            Send(oLowestGear,@DoPlayerArt);
         }
      }

      % Check for Soldier Shield sling
      bSoldierShieldSlung = FALSE;
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         foreach i in plUsing
         {
            if (IsClass(i,&Shield)
               AND NOT IsClass(i,&SoldierShield))
               OR IsClass(i,&Bow)
               OR IsClass(i,&Lute)
            {
               Send(oSoldierShield,@SlingOnBack,#report=FALSE);
               bSoldierShieldSlung = TRUE;

               % Now restore the first-person view of other shield
               % if we're using one
               foreach n in plUsing
               {
                  if (IsClass(n,&Shield)
                     AND NOT IsClass(n,&SoldierShield)
                     AND NOT IsClass(n,&Torch))
                  {
                     Send(self,@SetWindowOverlay,#what=n);
                  }
               }
            }
         }

         if bSoldierShieldSlung = FALSE
         {
            Send(oSoldierShield,@RemoveFromBack,#report=FALSE);
         }
      }

      return;
   }

   ConvertskincolortoXLAT(Skin_color = 0)
   {
      % Since the face translates use a single translate and the body uses
      % a double translate which has less color values available,
      % here we map the face translate to a similar body translate.
      if skin_color = PT_BLUE_TO_SKIN1
         OR skin_color = PT_BLUE_TO_SKIN2
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_SKIN3
      {
         return XLAT_TO_SKIN2;
      }

      if skin_color = PT_BLUE_TO_SKIN4
      {
         return XLAT_TO_SKIN4;
      }

      if skin_color = PT_BLUE_TO_GREEN
         OR skin_color = PT_BLUE_TO_YELLOW
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_GRAY
         OR skin_color = PT_BLUE_TO_ASHEN
      {
         return XLAT_TO_GRAY;
      }

      if skin_color = PT_BLEND25YELLOW
         OR skin_color = PT_BLUE_TO_LBLUE
      {
         return XLAT_TO_SKY;
      }

      if skin_color = PT_BLEND25RED
      {
         return XLAT_TO_BLUE;
      }

      if Send(SYS,@IsTwoColorXLAT,#Xlat=skin_color)
      {
         return Send(SYS,@DecodeSecondaryColor,#Xlat=skin_color);
      }

      return XLAT_TO_SKIN1;
   }

   SetSkinTranslation(translation = $)
   {
      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_Skin_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_SKIN_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHairTranslation(translation = $)
   {
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_HAIR_MASK;
      piBody_translations2 = piBody_translations2 | (translation * PLAYER_TRANSLATION2_HAIR_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIllusion(what = $)
   "Stores <what> as the object to call back to get our animation and overlays."
   "Tells everyone we changed."
   {
      poIllusion_set = what;

      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetIllusionForm(what = $)
   "Returns what is setting our illusion, if anything is."
   {
      if poIllusion_set = $
      {
         return $;
      }

      return Send(poIllusion_set,@IllusionGetTemplate,#who=self);
   }

   ResetPlayerIllusion()
   "Restores default lighting and DrawFX."
   {
      poIllusion_set = $;

      % Recalculate the flicker flag.
      Send(self,@RecalcFlickerFlag);

      % Reset our drawFX. Also does the SomethingChanged bit if appropriate.
      Send(self,@ResetPlayerDrawFX);

      return;
   }

   DoAttackSwing()
   {
      piAnimation = PANM_WEAPON_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   GetIcon(trueicon=FALSE)
   {
      % trueicon is set to true anytime you want to know what
      % a person really looks like.  Good example: statues.

      if poIllusion_set <> $ AND NOT trueicon
      {
         return Send(poIllusion_set,@IllusionGetIcon,#who=self);
      }

      propagate;
   }

   SendAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendAnimation,#who=self,
               #animation=iAnimation);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,2, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,3, 2,4, 2,1);

         return;
      }

      if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,5, 2,5, 2,1);

         return;
      }

      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE,4, 150, 2,6, 2,22);

         return;
      }

      propagate;
   }

   SendMoveAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveAnimation,#who=self);

         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_DANCE
      {    
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,6, 2,22);

         return;
      }

      % use standing torso
      AddPacket(1, ANIMATE_NONE, 2,1);

      return;
   }

   SendMoveOverlays(iAnimation = $)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveOverlays,#who=self);

         return;
      }

      % Player has 7 standard overlays:
      % right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      % Which group of arm images do we use?
      iLeft_group = 1;
      iRight_group = 1;

      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            % Bend the arm if we have a shield, a bow, or a token.
            if hotspot = HS_LEFT_WEAPON 
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1,iOverlays);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      iArms_xlat = Send(self,@GetArmsTranslation);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iLeft_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iLeft_group); 
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iRight_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
         }
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }
      
      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_CYCLE, 4,100, 2,2, 2,5);
      }

      iSkin_xlat = Send(self,@GetSkinColor);

      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);

      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes,1, HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }

      if poHair_remove = $
      {  
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1); 
      }

      foreach i in plOverlays
      {
         % Moved all of this to the item kod, since items may now
         %  have more than one overlay.
         Send(i,@SendOverlayInformation,#iAnimation = $);
      }

      return;
   }

   SendOverlays(iAnimation=$)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $ and iAnimation <> $
      {
         Send(poIllusion_set,@IllusionSendOverlays,#who=self,
              #animation=iAnimation);

         return;
      }


      % Send overlay bitmap info to user.

      % Player has 7 standard overlays:
      %  right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;

      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      % Overlay info -- display correct group for animation & action

      iLeft_group = 1;
      iRight_group = 1;
      foreach i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays,#iAnimation=iAnimation);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1, iOverlays);
      iArms_xlat = Send(self,@GetArmsTranslation);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      if iArms_Xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,8, 2,8, 2,iLeft_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,5, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,9, 2,9, 2,iLeft_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,iLeft_group);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE,2,iLeft_group);
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }

      if iAnimation = PANM_NONE
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }
      else if iAnimation = PANM_WAVE
      {
         AddPacket(1,ANIMATE_ONCE, 4,100, 2,7, 2,10, 2,iRight_group);
      }
      else if iAnimation = PANM_POINT
      {
         AddPacket(1,ANIMATE_ONCE, 4,700, 2,12, 2,12, 2,iRight_group);
      }
      else if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,11, 2,11, 2,iRight_group);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,13, 2,14, 2,iRight_group);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,15, 2,16, 2,iRight_group);
      }
      else if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,17);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,900, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,6, 2,6, 2,1);
      }
      else if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,7, 2,7, 2,1);
      }
      else if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,1);
      }

      iSkin_xlat = Send(self,@GetSkinColor);
      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);
      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes, 1,HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }

      if poHair_remove = $
      {
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1);
      }

      foreach i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation=iAnimation);
      }

      return;
   }

   MsgPlayerHitResisted(what=$,resistance=$,target=$,color_rsc=player_hit_color_none)
   "Send a message to the player if the person hit has a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5)
      {
         if resistance > (3*MAX_RESISTANCE/5)
         {
            rMessage = player_hit_immunity;
         }
         else
         {
            rMessage = player_hit_resisted;
         }
      }

      if resistance <= (MIN_RESISTANCE/5)
      {
         if resistance <= (3*MIN_RESISTANCE/5)
         {
            rMessage = player_hit_anti_immunity;
         }
         else
         {
            rMessage = player_hit_anti_resisted;
         }
      }

      if rMessage <> $
      {
         Send(what,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc,
               #parm2=Send(target,@GetCapDef),#parm3=Send(target,@GetName));
      }

      return;
   }

   MsgPlayerResistsHit(what=$,resistance=$,color_rsc=player_hit_color_none)
   "Send a message to the player if they have a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5) 
      {
         if resistance > (2*MAX_RESISTANCE/3)
         {
            rMessage = player_immune_to_hit;
         }
         else
         {
            rMessage = player_resists_hit;
         }
      }

      if resistance < (MIN_RESISTANCE/5)
      {
         if resistance < (2*MIN_RESISTANCE/3)
         {
            rMessage = player_anti_immune_to_hit;
         }
         else
         {
            rMessage = player_anti_resists_hit;
         }
      }

      if rMessage <> $
      {
         Send(self,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc);
      }

      return;
   }

   PlayerWasHit(atype = 0, aspell = 0)
   "Select a message to Send the player when they are hit."
   {
      if aspell > 0 % do spell attacks first, so flaming swords use the special
      {
         if (aspell&ATCK_SPELL_FIRE) > 0 { return player_was_burned;}
         if (aspell&ATCK_SPELL_SHOCK) > 0 { return player_was_shocked;}
         if (aspell&ATCK_SPELL_COLD) > 0 { return player_was_frozen;}
         if (aspell&ATCK_SPELL_HOLY) > 0 { return player_was_holyhit;}
         if (aspell&ATCK_SPELL_UNHOLY) > 0 { return player_was_unholyhit;}
         if (aspell&ATCK_SPELL_QUAKE) > 0 { return player_was_quaked;}
      }

      if atype > 0   % do weapon attacks (odd ones first).
      {
         if (atype&ATCK_WEAP_BITE) > 0 { return player_was_bitten;}
         if (atype&ATCK_WEAP_CLAW) > 0 { return player_was_clawed;}
         if (atype&ATCK_WEAP_STING) > 0 { return player_was_stung;}
         if (atype&ATCK_WEAP_SLASH) > 0 { return player_was_slashed;}
         if (atype&ATCK_WEAP_BLUDGEON) > 0 { return player_was_bludgeoned;}
         if (atype&ATCK_WEAP_PIERCE) > 0 { return player_was_pierced;}
         if (atype&ATCK_WEAP_THRUST) > 0 { return player_was_thrusted;}

         % Put non-weapon strokes here.
         if (atype&ATCK_WEAP_PUNCH) > 0 {return player_was_punched;}
         if (atype&ATCK_WEAP_KICK) > 0 {return player_was_kicked;}
      }

      return player_was_hit;
   }

   AddPoison(strength = 0, bVigorLoss = TRUE)
   {
      if ptPoison = $
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      piPoisonStrength = piPoisonStrength + strength;

      if bVigorLoss
      {
         piVigor = piVigor - 20;
         Send(self,@NewVigor);
      }

      return;
   }

   RemovePoison(strength = 0)
   {
      piPoisonStrength = piPoisonStrength - strength;

      return;
   }

   PoisonTimer()
   {
      ptPoison = $;

      % For safety's sake
      if piPoisonStrength <= 0
      {
         piPoisonStrength = 0;

         return;
      }

      if poOwner <> $
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      if poOwner = $
      {
         return;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         return;
      }

      if NOT Send(poOwner,@SafePlayerAttack)
         OR Send(poOwner,@IsValidTarget,#who=self)
      {
         % Poison only hurts you in the arena if you are a combatant.
         piHealth = piHealth - piPoisonStrength / 10;
         if piHealth < 1
         {
            piHealth = 1;
         }

         Send(self,@NewHealth);
      }

      return;
   }

   AddMight(points = 0, bAbsolute = TRUE)
   "Returns signed change to might (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMight;

      iOrigMight = piMightMod;
      piMightMod = piMightMod + points;

      if NOT bAbsolute
      {
         piMightMod = bound(piMightMod,-piMight,(MAXIMUM_STAT-piMight));
      }

      Send(self,@DrawMight);
      Post(self,@DrawCapacity);

      return piMightMod - iOrigMight;
   }

   AddIntellect(points = 0, bAbsolute = TRUE)
   "Returns signed change to intellect (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellectMod;
      piIntellectMod = piIntellectMod + points;

      if NOT bAbsolute
      {
         piIntellectMod = bound(piIntellectMod,-piIntellect,(MAXIMUM_STAT-piIntellect));
      }

      Send(self,@DrawIntellect);

      return piIntellectMod - iOrigIntellect;
   }

   AddAim(points = 0, bAbsolute = TRUE)
   "Returns signed change to aim (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAim;

      iOrigAim = piAimMod;
      piAimMod = piAimMod + points;

      if NOT bAbsolute
      {
         piAimMod = bound(piAimMod,-piAim,(MAXIMUM_STAT-piAim));
      }

      Send(self,@DrawAim);
      Post(self,@DrawOffense);

      return piAimMod - iOrigAim;
   }

   AddStamina(points = 0, bAbsolute = TRUE)
   "Returns signed change to stamina (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigStamina;

      iOrigStamina = piStaminaMod;
      piStaminaMod = piStaminaMod + points;

      if NOT bAbsolute
      {
         piStaminaMod = bound(piStaminaMod,-piStamina,(MAXIMUM_STAT-piStamina));
      }

      Send(self,@DrawStamina);

      return piStaminaMod - iOrigStamina;
   }

   AddAgility(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAgility;

      iOrigAgility = piAgilityMod;
      piAgilityMod = piAgilityMod + points;

      if NOT bAbsolute
      {
         piAgilityMod = Bound(piAgilityMod,-piAgility,(MAXIMUM_STAT-piAgility));
      }

      Send(self,@DrawAgility);
      Post(self,@DrawDefense);

      return piAgilityMod - iOrigAgility;
   }

   AddMysticism(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticismMod;
      piMysticismMod = piMysticismMod + points;

      if NOT bAbsolute
      {
         piMysticismMod = Bound(piMysticismMod,-piMysticism,(MAXIMUM_STAT-piMysticism));
      }

      Send(self,@DrawMysticism);
      Send(self,@ComputeMaxMana);

      return piMysticismMod - iOrigMysticism;
   }

   StartResting()
   {
      if ptRest <> $
      {
         return;
      }

      Send(self,@BreakTrance,#event=EVENT_REST);
      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));
      Send(self,@ResetPlayerFlagList);

      return;
   }

   IsResting()
   "If there is no rest timer, the player is not resting."
   {
      if ptRest = $
      {
         return FALSE;
      }

      return TRUE;
   }

   GetRestTime()
   {
      local iTime, lRadiusState;

      iTime = 1000 + (30* (51-Send(self,@getStamina)));

      return iTime;
   }

   RestTimer()
   {
      ptRest = $;

      if piVigor < piVigor_rest_threshold
      {
         Send(self,@RestAddExertion,#amount=-10000);
      }

      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));

      return;
   }

   StopResting()
   {
      if ptRest <> $
      {
         DeleteTimer(ptRest);
         ptRest = $;
      }

      Send(self,@ResetPlayerFlagList);

      return;
   }

   IsCursedByItems()
   "Returns TRUE if player is using an item that's cursed, FALSE otherwise."
   {
      local i;

      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   RemoveCurseAllItems()
   "Returns TRUE if the player has a cursed item stripped away, FALSE if not."
   {
      local i, bFound;

      bFound = FALSE;
      foreach i in plUsing
      {
         if Send(i,@IsCursed)
         {
            Send(self,@UnuseItem,#what=i);
            bFound = TRUE;
         }
      }

      return bFound;
   }

   GetArmor()
   "If plUsing holds any armor, return that object."
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&Armor)
         {
            return i;
         }
      }

      return $;
   }

   IsDead()
   {
      return (piHealth <= 0);
   }

   SetTranceFlag()
   {
      piFlags = piFlags | PFLAG_TRANCE;

      return;
   }

   ClearTranceFlag()
   {
      piFlags = piFlags & (~PFLAG_TRANCE);

      return;
   }

   SetFlickerFlag()
   {
      piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

      return;
   }

   RecalcFlickerFlag()
   "Called by anything that sets the flag when it wants to unset it. "
   "Checks if we still have anything that still requires the flag."
   {
      local i;

      % Unset flag.
      piDrawEffectFlag = piDrawEffectFlag & (~OF_FLICKERING);

      % Check torches and glow enchantment.
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
            OR (IsClass(i,&Weapon)
               AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

            return;
         }
      }

      % Check radius enchantments.
      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
            AND NOT Send(First(i),@GetOldAreaEnchStyle)
         {
            piDrawEffectFlag = piDrawEffectFlag | OF_FLICKERING;

            return;
         }
      }

      return;
   }

   BreakTrance(event = 0, what = $)
   {
      local i, oEnch,state, bFound, oYellNum, oYellRoom;

      bFound = FALSE;
      foreach i in plEnchantments
      {
         oEnch = Nth(i,2);
         if IsClass(oEnch,&Spell) OR IsClass(oEnch,&Trance)
         {
            state = $;
            if Length(i) >= ENCHANTMENT_LIST_STATE
            {
               state = Nth(i,3);
            }

            Send(oEnch,@BreakTrance,#who=self,#state=state,
                  #event=event,#what=what);
            bFound = TRUE;
         }
      }

      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
         {
            Send(Nth(i,1),@BreakTrance,#who=Nth(i,3),#event=event);
         }
      }

      if event = EVENT_NEWOWNER
      {
         foreach oYellNum in Send(poOwner,@GetYellZone)
         {
            oYellRoom = Send(SYS,@FindRoomByNum,#num=oYellNum);
            if Send(oYellRoom,@BreakTrance,#who=self)
            {
               bFound = TRUE;

               break;
            }
         }
      }

      if Send(poOwner,@BreakTrance,#who=self,#event=event)
      {
         bFound = TRUE;
      }

      return bFound;
   }

   RecalcBulkAndWeight()
   {
      return;
   }

   RecalcLight()
   {
      local i, iLight, iState, oWeapon, oItemAtt;

      % TODO: Make this into a general check.

      % Default base value
      iLight = 5;

      % Torch, Amulet
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }

         if IsClass(i,&ShadowAmulet)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }
      }

      iState = Send(self,@GetEnchantedState,
                    #what=Send(SYS,@FindSpellByNum,#num=SID_NIGHTVISION));
      if iState <> $
      {
         iLight = iLight + iState;
      }

      % Glowing weapons?
      oWeapon = Send(self,@LookupPlayerWeapon);
      if oWeapon <> $
      {
         iState = Send(oWeapon,@GetAttributeData,#ItemAtt=WA_GLOWING);
         if iState <> $
         {
            iLight = iLight + Nth(iState,3);
         }
      }

      if piLight <> iLight
      {
         Debug("Player ",Send(self,@GetName)," had wrong light value ",piLight,
               ".  Setting it to ",iLight);
         piLight = iLight;
         Send(self,@NewLight);
      }

      return;
   }

   GetPlayerLightLevel()
   "Calls RecalcLight and returns the light level."
   {
      Send(self,@RecalcLight);

      % This should be accurate after calling RecalcLight.
      return piLight;
   }

   UnuseAllItems()
   {
      local i;

      foreach i in plUsing
      {
         Send(self,@UnuseItem,#what=i,#Recalibrate=TRUE);
      }

      if plUsing <> $
      {
         plUsing = $;
      }

      return Send(SYS,@GetSuccessRsc);
   }

   RecalibratePlayer()
   {
      local i, bSoldier, iAmount;

      bSoldier = FALSE;
      if Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         bSoldier = TRUE;
      }

      Send(self,@UnuseAllItems);
      Send(self,@RemoveAllEnchantments);
      Send(self,@RecalcBulkAndWeight);
      Send(self,@ResetPlayerFlagList);

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
         Send(self,@MsgSendUser,#message_rsc=second_wind_finished);
         Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSkillByNum,
               #num=SKID_SECOND_WIND),#type=ENCHANTMENT_PLAYER);
      }

      iAmount = 80 + ((Send(self,@GetSkillAbility,
                           #Skill_num=SKID_SECOND_WIND) + 1) / 5);
      Send(self,@SetVigorRestThreshold,#amount=iAmount);

      Send(self,@EndCrystalizeManaSurge);

      % All attack modifiers should be a room enchantment, a personal
      % enchantment or something they are wearing. If one still exists,
      % bug.  This is also true for defense modifiers and resistances.
      if plAttack_modifiers <> $
      {
         foreach i in plAttack_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had attmod",Send(i,@GetName));
         }

         plAttack_modifiers = $;
      }

      if plDefense_modifiers <> $
      {
         foreach i in plDefense_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had defmods",Send(i,@GetName));
         }
         
         plDefense_modifiers = $;
      }

      if plResistances <> $
      {
         foreach i in plResistances
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had resistance",first(i),Nth(i,2));
         }

         plResistances = $;
      }

      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();
      piKill_count_decay = Bound(piKill_count_decay,0,$);

      if plEnchantments <> $
      {
         foreach i in plEnchantments
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had enchantments",Send(Nth(i,2),@GetName));
         }

         plEnchantments = $;
      }

      if piLight <> 5
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "had bad light value",piLight,"after being stripped!");
         piLight = 5;
      }

      if piMax_health <> piBase_max_health
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "with max health",piMax_health,"did not match Base Max Health",
               piBase_max_health);
         piMax_health = piBase_max_health;
      }

      Send(self,@ComputeMaxMana);

      if piDrawfx <> 0
      {
         Debug("Recalibrating: Player",Send(self,@GetTrueName),
               "with piDrawFX was equal to",piDrawFX,"instead of 0.");
         piDrawFX = 0;
      }

      if poIllusion_set <> $
      {
         Debug("recalibrating: Player",Send(self,@GetTrueName),
               "with illusion_set not set to $!");
         poIllusion_set = $;
      }

      if poGuild <> $ AND NOT Send(poGuild,@IsMember,#who=self)
      {
         Debug("Player",Send(self,@GetTrueName),"points to guild",
               Send(poGuild,@GetName)," but guild doesn't point to player!");
      }
      
      % Reset our modifiers
      Send(self,@ZeroMods);

      if bSoldier
      {
         foreach i in plPassive
         {
            if IsClass(i,&SoldierShield)
            {
               Send(self,@TryUseItem,#what=i);
            }
         }
      }

      % Reset death costs to 0.
      piDeathCost = 0;

      poEvilTwin = $;

      return Send(SYS,@GetSuccessRsc);
   }

   GetBulkMax()
   {
      return viBulk_hold_max + (Send(self,@GetMight) * 20);
   }

   GetWeightMax()
   {
      return viWeight_hold_max + (Send(self,@GetMight) * 20);
   }

   CountKnownAtLevel(school=$,level=$)
   {
      local i, count, nSID, nObj;

      count = 0;
      foreach i in plSkills
      {
         nSID = Send(self,@DecodeSkillNum,#compound=i);
         nObj = Send(SYS,@FindSkillByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         % Is this in the same school?
         if Send(nObj,@GetSchool) = school
            AND Send(nobj,@GetLevel) = level
         {
            count = count + 1;
         }
      }
      foreach i in plSpells
      {
         nSID = Send(self,@DecodeSpellNum,#compound=i);
         nObj = Send(SYS,@FindSpellByNum,#num=nSID);

         if nObj = $
         {
            continue;
         }

         if IsClass(nObj,&UtilitySpell)
            OR IsClass(nObj,&Blink)
         {
            continue;
         }

         % Is this in the same school?
         if (Send(nObj,@GetSchool) = school)
            and (Send(nobj,@GetLevel)) = level
         {
            count = count + 1;
         }
      }

      return count;
   }

   PlayerCanLearn(spell_num=0,skill_num=0,scryer=$)
   "New routine as of 14 June 97. Intended to allow for more schools, "
   "odd numbers of spells at a spell level and easier understanding."
   "The proverbial trick is that players have to know WHY they aren't "
   "learning. For example, if a player can't learn because he has too "
   "many competing schools, he needs to know that."
   {
      local bSkill, obj, level, school, division, iHave, prev_level,
            iSamediv, iOtherdiv, aHigh, bHigh, cHigh, iBase, i, temp,
            nObj, nSID, index, iNeed, nSchool, nLevel, msg, bKnowOne,
            iWeapon, iKraanan, iShalille, iQor, iFaren, iRiija, iJala, iPoints;

      % Phase one. Assert our data. Be sure we have been fed a valid spell
      % and skill num for a spell item that actually exists.
      if spell_num = 0
      {
         if skill_num = 0
         {
            Debug("No data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            bSkill = TRUE;
            obj = Send(SYS,@FindSkillByNum,#num=skill_num);
         }
      }
      else
      {
         if skill_num <> 0
         {
            Debug("Too much data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }
         else
         {
            bSkill = FALSE;
            obj = Send(SYS,@FindSpellByNum,#num=spell_num);
         }
      }
      if obj = $
      {
         Debug("Fed a spell number for a spell that does not exist in the "
               "system.");

         return PLAYER_LEARN_ERROR;
      }

      if NOT Send(obj,@IsAccessible)
      {
         % Sacred Haven server.
         return PLAYER_LEARN_ERROR;
      }

      if IsClass(obj,&Spell) AND NOT Send(obj,@IsEnabled)
      {
         % Spell is temporarily disabled.
         return PLAYER_LEARN_ERROR;
      }

      % Phase two:  get the hard data.
      level = Send(obj,@GetLevel);
      school = Send(obj,@GetSchool);
      division = Send(obj,@GetDivision);

      % Phase three. We begin to find our need.  Start by finding out how many
      % spells exist at ALL at that level. While we are going through the spell
      % skill list, count the spells/skills that count towards our total. Note
      % that we only want the top three spells/skills at that school and level.

      bKnowOne = FALSE;

      % Check to see if they have any spells of the next level.
      %  If so, let them buy any spells they want.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level+1);
      if iHave > 0
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % See how many spells they have at this level.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level);
      if iHave > 0
      {
         % For level 3 or higher, they can learn if they have another spell
         % in that school and level. If they have two spells at a lower level,
         % they need 2 or more spells in that school or level. This prevents
         % people getting all level 2 spells fresh out of character creation.
         if level > 2
            OR iHave >= 2
         {
            return PLAYER_LEARN_SUCCESS;
         }

         % Flag it so we know that they already have a spell in that level.
         bKnowOne = TRUE;
      }

      if level > 1
      {
         prev_level = Send(SYS,@GetNumAtLevel,#school=school,#level=level-1);
      }
      else
      {
         prev_level = 0;
      }

      aHigh = 0; bHigh = 0; cHigh = 0;

      iWeapon = 0;
      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;

      foreach i in plSkills
      {
         nSID=Send(self,@DecodeSkillNum,#compound=i);
         nobj=Send(SYS,@FindSkillByNum,#num=nSID);

         if nobj = $
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         nLevel = Send(nobj,@GetLevel);

         % Is this in the same school at level N-1?
         if school=Send(nobj,@GetSchool) AND (level-1) = (nLevel)
         {
            index = Send(self,@DecodeSkillAbility,#compound=i);
            if index > aHigh
            {
               temp = aHigh;
               aHigh = index;
               index = temp;
            }

            if index > bHigh
            {
               temp = bHigh;
               bHigh = index;
               index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         if nLevel > iWeapon
         {
            iWeapon = nLevel;
         }
      }

      foreach i in plSpells
      {
         nSID=Send(self,@DecodeSpellNum,#compound=i);
         nobj=Send(SYS,@FindSpellByNum,#num=nSID);
         
         if nobj = $
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         nSchool = Send(nobj,@GetSchool);
         nLevel = Send(nobj,@GetLevel);

         if (NOT IsClass(nobj,&Spell)) OR (nLevel> 10)
         {
            continue;
         }

         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         if nSchool = SS_DM_COMMAND
         {
            continue;
         }

         % Is this in the same school at level N-1?
         if school = nSchool AND (level-1) = (nlevel)
         {
            index = Send(self,@DecodeSpellAbility,#compound=i);

            if index > aHigh
            {
               temp = aHigh; aHigh = index; index = temp;
            }

            if index > bHigh
            {
               temp = bHigh; bHigh = index; index = temp;
            }

            if index > cHigh
            {
               cHigh = index;
            }
         }

         if NOT IsClass(nobj,&Blink)  % DON'T COUNT BLINK!
            AND NOT IsClass(nobj,&UtilitySpell) % Don't count utility spells
         {
            if nSchool = SS_KRAANAN
               AND nLevel > iKraanan
            {
               iKraanan = nLevel;
            }

            if nSchool = SS_SHALILLE
               AND nLevel > iShalille
            {
               iShalille = nLevel;
            }

            if nSchool = SS_QOR
               AND nLevel > iQor
            {
               iQor = nLevel;
            }

            if nSchool = SS_FAREN
               AND nLevel > iFaren
            {
               iFaren = nLevel;
            }

            if nSchool = SS_RIIJA
               AND nLevel > iRiija
            {
               iRiija = nLevel;
            }

            if nSchool = SS_JALA
               AND nLevel > iJala
            {
               iJala = nLevel;
            }
         }
      }

      if level > 1
      {
         % Only top three matter in the math.
         iHave = aHigh + bHigh + cHigh;
      }
      else
      {
         % You always have the "max" for level 1
         iHave = (3 * 99);
      }

      % Do easy checks to prevent unnecessary math.
      % Keep these checks here so they are of lower precedence than
      % the 'you already have this spell' check.

      if NOT Send(obj,@KarmaCheck,#who=self)
      {
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noKarma,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }
         
         return PLAYER_LEARN_KARMA;
      }

      % Player can't learn level this because he knows nothing of
      %  previous level.
      if iHave = 0
      {
         return PLAYER_LEARN_NOBASE;
      }

      % We have done all the information gathering, so now, lets compute:

      iPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
               + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
               + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
               + Send(SYS,@GetLevelLearnPoints,#level=iQor)
               + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
               + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
               + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      % Okay, we're going into new territory if we don't already know one
      %  spell in the school, so we're increasing the level of our
      %  knowledge.  Add points.
      if not bKnowOne
      {
         iPoints = iPoints + Send(SYS,@GetLevelLearnPoints,#level=level)
                           - Send(SYS,@GetLevelLearnPoints,#level=(level-1));
      }

      % How this oddball equation works: You have a POINTS_SLOPE that determines
      %  how steep the advancement slope is.  A higher slope results in lower
      %  levels requiring less points, but each school level gained counts more
      %  against future learning.  You hit your max when you get to 297 points
      %  (3*99), so when your points equals max points, you've maxxed out.  
      %  Intellect gives you a bonus to learning, currently about 20 points
      %  for 50 Intellect (approximately mastering 2 extra schools)
      iNeed =   (iPoints * POINTS_SLOPE)
              + (297 - (Send(SETTINGS_OBJECT, @GetMaxLearnPoints) * POINTS_SLOPE))
              - ((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5);

      % NOTE: if you modify the above equation, also modify GivePlayerAllSkills
      %  and GivePlayerAllSpells as needed

      % Bound iNeed to a reasonable low level so people can't just rush in and
      %  get high level with very little work.
      iNeed = bound(iNeed,MIN_NEEDED_TO_ADVANCE,$);
      
      if scryer <> $
      {
         % nSchool will equal how much the intended school's points added.
         if bSkill
         {
            nSchool = iWeapon;
         }
         else
         {
            if school = SS_KRAANAN
            {
               nSchool = iKraanan;
            }

            if school = SS_SHALILLE
            {
               nSchool = iShalille;
            }

            if school = SS_QOR
            {
               nSchool = iQor;
            }

            if school = SS_FAREN
            {
               nSchool = iFaren;
            }

            if school = SS_RIIJA
            {
               nSchool = iRiija;
            }

            if school = SS_JALA
            {
               nSchool = iJala;
            }
         }

         % Bring the points back down to the original total, before learning.
         if NOT bKnowOne
         {
            iPoints = iPoints - Send(SYS,@GetLevelLearnPoints,#level=level)
                              + Send(SYS,@GetLevelLearnPoints,#level=(level-1));
         }

         Send(scryer,@MsgSendUser,#message_rsc=player_Debug_playercanlearn,
              #parm1=Send(self,@GetName),#parm2=Send(obj,@GetLevel),
              #parm3=Send(obj,@GetSchoolStr),#parm4=iPoints,#parm5=nSchool,
              #parm6=((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5),
              #parm7=iNeed,#parm8=iHave);
      }

      % If the previous level has fewer than three spells, help them out.
      if prev_level = 1
      {
         iNeed= iNeed / 3;
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                  #message_rsc=player_Debug_playercanlearn_scarcity,
                  #parm1=iNeed);
         }
      }

      if prev_level = 2
      {
         iNeed = (iNeed*2)/3;
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                  #message_rsc=player_Debug_playercanlearn_scarcity,
                  #parm1=iNeed);
         }
      }

      if iHave >= iNeed
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % Okay, at this point, we know that they didn't pass the test.  Now give
      % them a good reason why.  Essentially, if they know a lot of other
      % divisions and it's slowing them down, tell them that.  Otherwise,
      % be more generic.
      
      % Is it now impossible to actually learn this spell level?  This would
      % mean that the need is greater than 99% in three of the previous
      % level's spells, or 297 (most of the time).  Levels with fewer than
      % three spells are a special instance.
      if iNeed > (99*(bound(prev_level,1,3)))
      {
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noway,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }

         return PLAYER_LEARN_IMPOSSIBLE;
      }

      % Return info in this format (base 10):  xxxy, where xxx is the number
      % of spell or skill points they need, and y is the reason why they
      % failed.  Only condition is "not enough points".
      return ((10*(iNeed-iHave))+PLAYER_LEARN_BASE);
   }

   GetTotalLearnPoints(except = $)
   {
      local iSpell, iSID, oSpellObj, iSchool, iLevel, iKraanan, iShalille,
            iQor, iFaren, iRiija, iJala, iWeapon, iTotalLearnPoints;

      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iWeapon = 0;

      foreach iSpell in plSpells
      {
         iSID = Send(self,@DecodeSpellNum,#compound=iSpell);
         oSpellObj = Send(SYS,@FindSpellByNum,#num=iSID);

         iSchool = Send(oSpellObj,@GetSchool);
         iLevel = Send(oSpellObj,@GetLevel);

         if NOT IsClass(oSpellObj,&Blink)  % DON'T COUNT BLINK!
            AND NOT IsClass(oSpellObj,&UtilitySpell) % Don't count utility spells
            AND iSchool <> SS_DM_COMMAND
            AND except <> iSchool
         {
            if iSchool = SS_KRAANAN
               AND iLevel > iKraanan
            {
               iKraanan = iLevel;
            }

            if iSchool = SS_SHALILLE
               AND iLevel > iShalille
            {
               iShalille = iLevel;
            }

            if iSchool = SS_QOR
               AND iLevel > iQor
            {
               iQor = iLevel;
            }

            if iSchool = SS_FAREN
               AND iLevel > iFaren
            {
               iFaren = iLevel;
            }

            if iSchool = SS_RIIJA
               AND iLevel > iRiija
            {
               iRiija = iLevel;
            }

            if iSchool = SS_JALA
               AND iLevel > iJala
            {
               iJala = iLevel;
            }
         }
      }

      if except <> SKS_FENCING
      {
         foreach iSpell in plSkills
         {
            iSID = Send(self,@DecodeSkillNum,#compound=iSpell);
            oSpellObj = Send(SYS,@FindSkillByNum,#num=iSID);

            iLevel = Send(oSpellObj,@GetLevel);

            if iLevel > iWeapon
               AND iLevel < 50       % Catch DM only skills
            {
               iWeapon = iLevel;
            }
         }
      }

      iTotalLearnPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
                         + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
                         + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
                         + Send(SYS,@GetLevelLearnPoints,#level=iQor)
                         + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
                         + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
                         + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      return iTotalLearnPoints;
   }

   EvaluatePKStatus(dbug=FALSE)
   "This should always be run AFTER the player undergoes whatever changes "
   "(i.e. quits a guild or drops below 30 health).  Also, take steps to ensure "
   "it is not run immediately prior to death."
   {
      local i, ass_game;

      if (piFlags & PFLAG_PKILL_LOCK)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
      {
         if poGuild = $
            AND piBase_Max_health < Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            AND NOT (piFlags & PFLAG_MURDERER)
            AND NOT (piFlags & PFLAG_OUTLAW)
         {
            ass_game = Send(SYS,@GetAssassinGame);
            if Send(ass_game,@IsCombatant,#who=self)
            {
               Send(self,@MsgSendUser,#message_rsc=Player_dagger_shatters);
               Send(ass_game,@RemoveFromGame,
                     #who=self,#RemoveFromRecords=FALSE);
            }

            Send(self,@MsgSendUser,#message_rsc=player_regain_angel);
            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
            Send(self,@PlayerIsIntriguing);
         }
      }
      else
      {
         if poGuild <> $
            OR piBase_Max_health >= Send(SETTINGS_OBJECT,@GetPKillEnableHP)
            OR (piFlags & PFLAG_MURDERER)
            OR (piFlags & PFLAG_OUTLAW)
         {
            if Send(SYS,@IsPKAllowed)
            {
               % Happylanders don't get 'vulnerable' message.
               Send(self,@MsgSendUser,#message_rsc=player_no_angel);
            }

            % Once you've become killable, you no longer get tutorial messages
            % and bonuses.  You also lose your newbie string.
            Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
            Send(self,@RemoveHonorString,#string=player_newbie_honor_string);

            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);
            if dbug = TRUE
            {
               Debug("Someone with less than 30 health managed to guild or "
                     "outlaw",self);
            }
         }
      }

      return;
   }

   PKillEnable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      if Send(SYS,@IsPKAllowed)
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_angel);
      }

      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillDisable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   % Note: a player with PKILL_ENABLE set will have it reset at will if 
   % an event naturally causes it to.  If you want to not have this change,
   % then call PkillLock below.  This will ensure that the status of
   % PKILL_ENABLE will never change, with the exception of a suicide.

   PkillLock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=TRUE);

      return Send(SYS,@GetSuccessRsc);
   }

   PkillUnlock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   StartTempSafe()
   {
      local iTime;

      % First, check if we're in a guild hall. Players can exploit this
      % system by dying in a guild hall and using PoL or the UW node to
      % teleport back to their bodies with temp safe activated, which would
      % leave them unable to be killed and inside a hall. Teleport players
      % from the guild hall to their hometown.
      if poOwner <> $
         AND IsClass(poOwner,&GuildHall)
      {
         Send(self,@AdminGotoSafety);
      }

      % This returns minutes, so convert to milliseconds.
      iTime = Send(SETTINGS_OBJECT,@GetTempSafeTime);
      iTime = iTime * 60 * 1000;

      if ptTempSafe <> $
      {
         DeleteTimer(ptTempSafe);
      }
      ptTempSafe = CreateTimer(self,@EndTempSafe,iTime);
      piFlags = piFlags | PFLAG_TEMPSAFE;
      Send(self,@MsgSendUser,#message_rsc=player_temp_safe);

      return;
   }

   EndTempSafe()
   {
      piFlags = piFlags & ~PFLAG_TEMPSAFE;
      if poOwner <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_temp_safe_end);
         Send(poOwner,@SomethingChanged,#what=self);
      }

      ptTempSafe = $;

      return;
   }

   ResetFaction(faction = FACTION_NEUTRAL)
   {
      local oSoldierShield;

      if faction < FACTION_NEUTRAL OR faction > FACTION_MAX
      {
         return FALSE;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      if oSoldierShield <> $
         AND faction <> Send(oSoldierShield,@GetFaction)
      {
         Send(oSoldierShield,@LostFaction);
      }

      piFaction = faction;

      return TRUE;
   }

   GetFaction()
   {
      return piFaction;
   }

   % Need to be able to keep track of their service...
   % When players join, and subsequently log on, the
   % updated time gets set and the timer gets started.

   UpdateFactionService(full=False,middle=False,front=False,adjust=True)
   {
      local tyme, oSoldierShield;

      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      tyme = GetTime();

      % Don't require new service if the player has been an active soldier.
      if oSoldierShield = $
      {
         piFactionServiceUpdate = piFactionServiceUpdate + tyme - piFactionTimeUpdated;
      }
      else
      {
         % Get rid of warnings.
         if piFactionServiceUpdate > FACTION_WARN_TIME
         {
            piFactionServiceUpdate = FACTION_WARN_TIME;
         }
      }

      piFactionTimeUpdated = tyme;

      if NOT adjust
      {
         return;
      }

      if full
      {
         piFactionServiceUpdate = 0;
      }
      else if middle
      {
         piFactionServiceUpdate = piFactionServiceUpdate / 2;
      }
      else if front
      {
         piFactionServiceUpdate = 3* piFactionServiceUpdate / 4;
      }

      return;
   }

   FactionServiceTimer(renew=TRUE)
   {
      % Attempts to delete any existing timer, then passes to
      % FactionServiceRenew which creates a new timer if conditions are met.

      if ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer = $;
      }

      Send(Self,@FactionServiceRenew,#renew=renew);

      return;
   }

   FactionServiceRenew(renew=TRUE)
   {
      % This function now handles renewal of ptFactionTimer and should
      % only be accessed from FactionServiceTimer() after the $ check.

      local iHistory;
      
      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      Send(Self,@UpdateFactionService,#adjust=FALSE);
      if piFactionServiceUpdate > FACTION_RESIGN_TIME
      {
         % Add bNoTimer = TRUE so we don't try to delete a non-existent timer.
         Send(self,@ResignFaction,#bNoTimer=TRUE);

         return;
      }

      if piFactionServiceUpdate > FACTION_WARN_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=player_faction_time);
         % This should be unnecessary (since loyalty quests reschedule
         % themselves at completion), but is included nonetheless to 
         % ensure that if you've been warned, there's a quest waiting for you.

         if piFaction = FACTION_PRINCESS
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
            iHistory = First(Send(self,@GetQuestHistory,
                        #index=QST_ID_PRINCESS_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_PRINCESS_SERVICE);
            }
         }

         if piFaction = FACTION_DUKE
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_DUKE_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_DUKE_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_DUKE_SERVICE);
            }
         }

         if piFaction = FACTION_REBEL
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,
                  #index=QST_ID_REBEL_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,
                  #index=QST_ID_REBEL_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_REBEL_SERVICE);
            }
         }
      }

      if renew AND Send(SYS,@GetParliament) <> $
         AND (NOT Send(Send(SYS,@GetParliament),@IsShutdown))
      {
         ptFactionTimer = CreateTimer(self,@FactionServiceRenew,
                                             FACTION_UPDATE_TIME);
      }

      return;
   }

   PlayerIsIntriguing()
   "Evaluates player and sets the PFLAG_INTRIGUING"
   {
      local bIntrigue, wasint, i, oParl;

      bIntrigue=0;

      oParl=Send(SYS,@GetParliament);
      if oParl = $
      {
         return FALSE;
      }

      wasint = (piFlags & PFLAG_INTRIGUING);

      if wasint AND Send(oParl,@IsShutdown)
      {
         Send(self,@MsgSendUser,#message_rsc=player_intrigue_shut);
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=False);
         Send(oParl,@UpdateEffects,#who=self);
         if ptFactionTimer<>$
         {
            DeleteTimer(ptFactionTimer);
            ptFactionTimer=$;
         }

         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused,#what=self);

               break;
            }
         }
         return FALSE;
      }

      if Send(oParl,@IsShutdown)
      {
         return FALSE;
      }

      if (piFlags & PFLAG_PKILL_ENABLE)
         AND (Send(self,@PlayerIsHPIntrigue)
              OR Send(self,@PlayerIsAdept))
      {
         bIntrigue = PFLAG_INTRIGUING;
      }

      if wasint <> bIntrigue
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=bIntrigue);
      }

      if NOT wasint AND bIntrigue
      {
         if piFactionEffect <> 0
         {
            Debug("NonIntriguing Player",Send(self,@GetName),"had effects "
                  "set:",piFactionEffect);
            piFactionEffect=0;
         }

         piFaction = FACTION_NEUTRAL;
         Send(oParl,@UpdateEffects,#who=self);
         Send(oParl,@MovetoFaction,#who=self,#faction=FACTION_NEUTRAL);
         Send(self,@ReceiveNestedMail,#from=intrigue_ambassador,
              #dest_list=[self],#nest_list=[4,player_intrigue_mail]);
      }

      if wasint AND NOT bIntrigue
      {
         Send(self,@MsgSendUser,#message_rsc=player_lost_intriguing);
         Send(self,@ResignFaction);
         Send(oParl,@MovetoFaction,#who=self,#faction=(-1));
         foreach i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused);

               break;
            }
         }
      }

      return bIntrigue;
   }

   JoinFaction(new_faction=FACTION_NEUTRAL)
   "Returns true if the joining was a success"
   {
      local factliege, oParliament, oQuestEngine;

      if NOT Send(Self,@PlayerIsIntriguing)
      {
         return FALSE;
      }

      if new_faction <= FACTION_NEUTRAL OR new_faction > FACTION_MAX
      {
         return FALSE;
      }

      if piFaction <> FACTION_NEUTRAL
      {
         return FALSE;
      }

      piFaction = new_faction;
      % Increase the max number of loyalty quests by one, and schedule one.
      oQuestEngine = Send(SYS,@GetQuestEngine);
      
      if piFaction = FACTION_PRINCESS
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_PRINCESS_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_PRINCESS_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_DUKE_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_DUKE_SERVICE),
                                     QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_DUKE_SERVICE,#override=TRUE);
      }

      if piFaction = FACTION_REBEL
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_REBEL_SERVICE,
               #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                      #index=QST_ID_REBEL_SERVICE),
                                      QT_MAX_NUM_ACTIVE)));
         Send(oQuestEngine,@ScheduleQuest,
               #index=QST_ID_REBEL_SERVICE,#override=TRUE);
         Post(self,@DrawOffense);
      }

      piFactionTimeUpdated = GetTime();
      piFactionServiceUpdate = 0;
      oParliament = Send(SYS,@GetParliament);

      if piFaction <> FACTION_NEUTRAL
      {
         factliege = Send(oParliament,@GetLiege,#faction=piFaction);
      }

      ptFactionTimer = $;
      Send(Self,@FactionServiceTimer);
      Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
      Send(oParliament,@UpdateEffects,#who=self);
      Send(self,@MsgSendUser,#message_rsc=player_join_faction,
            #parm1=Send(factliege,@GetDef),#parm2=Send(factliege,@GetName));

      return TRUE;
   }

   ResignLoyaltyFailed()
   {
      % Don't boot the player unless they've been factioned longer
      % than 5400 seconds (90 minutes)

      if piFactionServiceUpdate < 5400
      {
         return;
      }

      Send(self,@ResignFaction);

      return;
   }

   ResignFaction(bNoTimer=FALSE)
   {
      local numMembers, oParliament, oQuestEngine, oQuest, oFlagPole;

      if poOwner <> $
      {
         oFlagPole = Send(poOwner,@FindHoldingActive,#Class=&Flagpole);
         if oFlagPole <> $ AND Send(oFlagPole,@IsClaimAttemptInProgress)
         {
            if Send(oFlagPole,@GetClaimer) = self
            {
               Send(oFlagPole,@ClaimFailed);
            }
         }
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      if (oQuestEngine = $)
      {
         return;
      }

      if Send(Self,@PlayerIsIntriguing)
         AND piFaction <> FACTION_NEUTRAL
      {
         Send(self,@MsgSendUser,#message_rsc=player_unfactioned);
      }

      % Decrease the max number of loyalty quests by one
      if piFaction = FACTION_PRINCESS
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_PRINCESS_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,
                 #index=QST_ID_PRINCESS_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Princess faction members!");
         }
         Post(self,@DrawDefense);
      }

      if piFaction = FACTION_DUKE
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_DUKE_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);

         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_DUKE_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Duke faction members!");
         }
      }

      if piFaction = FACTION_REBEL
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_REBEL_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_REBEL_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of Rebel faction members!");
         }
         Post(self,@DrawOffense);
      }

      Send(self,@ResetFaction,#faction=FACTION_NEUTRAL);

      if NOT bNoTimer
         AND ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
      }

      ptFactionTimer=$;
      piFactionTimeUpdated = 0;
      piFactionServiceUpdate = 0;

      oParliament = Send(SYS,@GetParliament);
      if oParliament <> $
      {
         if Send(self,@PlayerIsIntriguing)
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=piFaction);
         }
         else
         {
            Send(oParliament,@MoveToFaction,#who=self,#faction=(-1));
         }

         Send(oParliament,@UpdateEffects,#who=self);
      }

      return;
   }

   PlayerIsHPIntrigue()
   "If player has over 40hp base."
   {
      return (piBase_Max_health >= Send(SETTINGS_OBJECT,@GetIntrigueEnableHP));
   }

   PlayerIsAdept()
   "If player has 5th level spell over the enabling percent, then true"
   {
      local i, sid, oSpell;

      foreach i in plSpells
      {
         sid = abs(i/100);
         oSpell = Send(SYS,@FindSpellByNum,#num=sid);
         if IsClass(oSpell,&Spell) AND Send(oSpell,@GetLevel) = 5
            AND (i mod 100) >= INTRIGUE_ENABLE_SPELL
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   CheckTokenInNewRoom(what=$)
   "If we are carrying a token, lets drop it."
   {
      local i, bFound;

      if what = $
         OR poOwner = $
         OR Send(poOwner,@CanTokenEnterRoom)
      {
         return;
      }

      bFound = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Token)
         {
            bFound = TRUE;
            Send(i,@NewUnused,#where=what);
         }
      }

      if bFound
      {
         % Give a different message depending on the room.
         if IsClass(poOwner,&GuildHall)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_hall);

            return;
         }

         if Send(poOwner,@IsArena)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_arena);

            return;
         }

         if IsClass(poOwner,&SurvivalRoom)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token_survival);

            return;
         }

         Send(self,@MsgSendUser,#message_rsc=player_lost_token_generic);
      }

      return;
   }

   GetFactionService()
   {
      return piFactionServiceUpdate;
   }

   GetFactionEffect()
   {
      return piFactionEffect;
   }

   SetFactionEffect(effect=0)
   {
      piFactionEffect = effect;

      return;
   }

   TokenDeliveryReward(mob=$)
   {
      local tobj,classes;

      classes = Send(Send(SYS,@GetLibrary),@GetQuestRewardList);
      if classes = $
      {
         return;
      }

      if IsClass(mob,&Council)
         OR (IsClass(mob,&Factions) AND Send(mob,@GetFaction) = piFaction)
         OR (IsClass(mob,&ShalillePriestess) AND piFaction = FACTION_NEUTRAL)
      {
         tobj = Create(Nth(classes,Random(1,Length(classes))));
         if Send(self,@ReqNewHold,#what=tobj)
         {
            Send(self,@NewHold,#what=tobj);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
         else
         {
            Send(poOwner,@NewHold,#what=tobj,#new_row=piRow,#new_col=piCol,
                  #fine_row=piFine_row,#fine_col=piFine_col);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                  #string=player_token_reward_heavy,#parm1=Send(tobj,@GetDef),
                  #parm2=Send(tobj,@GetName));
         }
      }

      return;
   }

   GetInstrumentLevel()
   "Returns the power of the instrument we are holding."
   {
      local i, iPower;

      iPower = 0;

      % Search through for the instrument of the highest power.
      %  We could have a necklace and a lute.  Let the lute contribute
      %  its power, rather than the necklace.
      foreach i in plUsing
      {
         if IsClass(i,&Instrument)
         {
            iPower = iPower + Send(i,@GetInstrumentLevel);
         }
      }

      return iPower;
   }

   ZeroMods()
   "Should NOT be called before removing all potential stat-modifying things"
   {
      piMightMod = 0;
      piIntellectMod = 0;
      piMysticismMod = 0;
      piAgilityMod = 0;
      piStaminaMod = 0;
      piAimMod = 0;

      return;
   }

   CheckLog()
   {
      return (piFlags & PFLAG_LOG);
   }

   DecayPKillCount()
   {
      % 50% chance to reduce the kill count.  This is to eliminate
      % the people who attempt to exploit this system for gain.
      if Random(1,100) > 50
      {
         piKill_count_decay = piKill_count_decay - 1;
         piKill_count_decay = Bound(piKill_count_decay,0,$);
      }

      return;
   }

   GetUnjustifiedKills()
   {
      return piKill_count;
   }

   GetDecayedUnjustifiedKills()
   {
      return piKill_count_decay;
   }

   GetJustifiedKills()
   {
      return piJustified_kill_count;
   }

   UserReqNewOwner(RID=0)
   {
      local oRoom;

      if RID = 0
      {
         return;
      }

      oRoom = Send(SYS,@FindRoomByNum,#num=RID);
      if oRoom = $
      {
         Debug("Got an invalid room!");
         return FALSE;
      }

      if IsClass(oRoom,&GuildHall)
         AND (NOT (piFlags & PFLAG_PKILL_ENABLE)
            OR (piFlags & PFLAG_TEMPSAFE))
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_enter);

         return FALSE;
      }

      Send(self,@BreakTrance,#event=EVENT_REQNEWOWNER);

      return TRUE;
   }

   GivePlayerAllSpells(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
                              (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;
               
               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSpells)
      {
         if not IsClass(i,&Spell)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSpell,#num=Send(i,@GetSpellNum),
                     #iability=iAbility);
            }
         }
      }

      % Set Karma enough for them to cast their highest level spell.
      if school = SS_SHALILLE
      {
         % Need 10 Karma per spell level (+10 for fudge).
         piKarma = level * 1000;
      }

      if school = SS_QOR
      {
         % Need -10 Karma per spell level (-10 for fudge).
         piKarma = level * -1000;
      }

      return TRUE;
   }

   GivePlayerAllSkills(school=0,level=-1,upto=TRUE,iability=99,override=FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints,
            iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(SETTINGS_OBJECT, @GetMaxLearnPoints) +
            (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints +
                     Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;

               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      foreach i in Send(SYS,@GetSkills)
      {
         if not IsClass(i,&Skill)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSkill,#num=Send(i,@GetSkillNum),#iability=iAbility);
            }
         }
      }

      return TRUE;
   }

   % Designed this just like GetSpellSchoolLevels in case a skill school
   % is added later and this needs to be extended.
   GetSkillSchoolLevels()
   {
      local i, lSchoolLevels, oSkill, iLevel, weaponcraft_level;

      weaponcraft_level = 0;
      iLevel = 0;

      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                      #compound=i));
         iLevel = Send(oSkill,@GetLevel);

         if iLevel > weaponcraft_level
         {
            weaponcraft_level = iLevel;
         }
      }

      lSchoolLevels = [weaponcraft_level];

      return lSchoolLevels;
   }

   GetSpellSchoolLevels(include_cant_forget=FALSE)
   {
      local i, lSchoolLevels, oSpell, iSchool, iLevel, iCanForget,
            shalille_level, qor_level, kraanan_level, faren_level,
            riija_level, jala_level;

      shalille_level = 0;
      qor_level = 0;
      kraanan_level = 0;
      faren_level = 0;
      riija_level = 0;
      jala_level = 0;
      iCanForget = TRUE;

      % Get max level in each school. Yes, this is ugly but I'm trying for
      % the least number of comparisons possible per spell. Schools in order
      % of popularity, your results may vary. 10/25/2014 103 stats: 578 kran,
      % 228 faren, 284 shal, 160 riija, 216 qor, 151 jala
      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                      #compound=i));
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iCanForget) OR (NOT iCanForget AND include_cant_forget)
         {
            if (iSchool = SS_KRAANAN)
            {
               if (iLevel > kraanan_level)
               {
                  kraanan_level = iLevel;
               }
            }
            else if (iSchool = SS_SHALILLE)
            {
               if (iLevel > shalille_level)
               {
                  shalille_level = iLevel;
               }
            }
            else if (iSchool = SS_QOR)
            {
               if (iLevel > qor_level)
               {
                  qor_level = iLevel;
               }
            }
            else if (iSchool = SS_FAREN)
            {
               if (iLevel > faren_level)
               {
                  faren_level = iLevel;
               }
            }
            else if (iSchool = SS_RIIJA)
            {
               if (iLevel > riija_level)
               {
                  riija_level = iLevel;
               }
            }
            else if (iSchool = SS_JALA)
            {
               if (iLevel > jala_level)
               {
                  jala_level = iLevel;
               }
            }
         }
      }

      % Order matters here, they appear in the order listed in blakston.khd.
      lSchoolLevels = [shalille_level,qor_level,kraanan_level,
                       faren_level,riija_level,jala_level];

      return lSchoolLevels;
   }

   StripSpellsOfSchool(school = 0, All = FALSE)
   {
      local i, j, k;

      if (ALL)
      {
         j = 1;
         while (j < NUM_SCHOOLS)
         {
            k = 1;
            while (k < NUM_SPELL_LEVELS)
            {
               Send(self, @StripSpellsOfSchoolByLevel, #school=j, #level=k);
               ++k;
            }
            ++j;
         }
      }
      else
      {
         k=1;
         while (k < NUM_SPELL_LEVELS)
         {
            Send(self, @StripSpellsOfSchoolByLevel, #school=school, #level=k);
            ++k;
         }
      }

      return;
   }
   
   StripSpellsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSpell, iSchool, iLevel, iCanForget, iSpellNum;
   
      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iSchool = Send(oSpell,@GetSchool);
         iLevel = Send(oSpell,@GetLevel);
         iCanForget = Send(oSpell,@CanForget);

         if (iSchool = school) AND (iLevel = level) AND iCanForget
         {
            Send(self,@RemoveSpell,#num=iSpellNum);
         }
      }
      return;
   }

   StripSkillsOfSchoolByLevel(school = 0, level = 0)
   {
      local i, oSkill, iSchool, iLevel;
      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oSkill,@GetSchool);
         iLevel = Send(oSkill,@GetLevel);
         
         if (iSchool = school) AND (iLevel = level)
         {
            Send(self,@RemoveSkill,#num=Send(self,@DecodeSkillNum,#compound=i));
         }
      }
      return;
   }
   
   IsWizard()
   {
      if Length(plSpells) > 50
      {
         return TRUE;
      }

      return FALSE;
   }

   ClearSpellList()
   {
      plSpells = $;
      return;
   }

   GetMaster()
   {
      return $;
   }

   IsInvisible()
   {
      return (piFlags & PFLAG_INVISIBLE);
   }

   IsShadowForm()
   {
      return (piDrawFX & DRAWFX_BLACK);
   }

   IsMorphed()
   {
      return (piFlags & PFLAG_MORPHED);
   }

   %%% Get Color Routines

   GetSkinColor()
   {
      return (piBody_translations & PLAYER_TRANSLATION_Skin_MASK)
                  /PLAYER_TRANSLATION_Skin_MUL;
   }

   GetHairColor()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_HAIR_MASK)
                  /PLAYER_TRANSLATION2_HAIR_MUL;
   }

   GetLegsTranslation()
   {
      % This returns the whole translation, including skin color.
      return (piBody_translations & PLAYER_TRANSLATION_LEGS_MASK)
                  /PLAYER_TRANSLATION_LEGS_MUL;
   }

   GetArmsTranslation()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_ARMS_MASK)
                  /PLAYER_TRANSLATION2_ARMS_MUL;
   }

   GetBodyTranslation()
   {
      % This returns the armor/shirt torso (not arms) color.  note that skin is
      %  included in this, in the case of a low-cut dress, for example.
      return (piBody_translations & PLAYER_TRANSLATION_BODY_MASK)
               /PLAYER_TRANSLATION_BODY_MUL;
   }

   GetDefaultShirtTranslation()
   "This includes skin tones - important for the arms."
   {
      return ((piDefault_Clothes & SHIRT_MASK) / SHIRT_MUL);
   }

   GetDefaultShirtColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultShirtTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   GetCurrentShirtColor()
   {
      local i;

      foreach i in plUsing
      {
         if IsClass(i,&shirt)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return Send(self,@GetDefaultShirtTranslation);
   }

   GetDefaultPantsTranslation()
   "This includes skin tones."
   {
      return (((piDefault_Clothes & PANTS_MASK) / PANTS_MUL));
   }

   GetDefaultPantsColor()
   "This does not include skin tones."
   {
      local iXlat;

      iXlat = Send(self,@GetDefaultPantsTranslation);

      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   SetSkinColor(color = 1)
   {
      local iColor, i;

      % Arms (hands) and face are the only default things that need to
      % have skin colors associated with it.  Other items in use
      % may need to, though (low cut dress).

      Send(self,@SetSkinTranslation,#translation=color);
      iColor = Send(self,@GetDefaultShirtColor);
      Send(self,@SetDefaultClothes,#shirt_color = iColor);
      foreach i in plUsing
      {
         Send(i,@DoPlayerArt);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHead(head=$)
   {
      if head = $
      {
         return;
      }

      prHead = head;

      return;
   }

   SetEyes(eyes=$)
   {
      if eyes = $
      {
         return;
      }

      prEyes = eyes;

      return;
   }

   SetNose(Nose=$)
   {
      if Nose = $
      {
         return;
      }

      prNose = Nose;

      return;
   }

   SetMouth(Mouth=$)
   {
      if Mouth = $
      {
         return;
      }

      prMouth = Mouth;

      return;
   }

   GetHeadRsc()
   {
      return prHead;
   }

   GetEyesRsc()
   {
      return prEyes;
   }

   GetMouthRsc()
   {
      return prMouth;
   }

   GetNoseRsc()
   {
      return prNose;
   }

   GetHairRsc()
   {
      return prToupee;
   }

   GetLeftArmRsc()
   {
      return prLeft_arm;
   }

   GetRightArmRsc()
   {
      return prRight_arm;
   }

   GetLegsRsc()
   {
      return prLegs;
   }

   GetExpression()
   {
      return piAction;
   }

   GetShieldRsc()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlay);
         }
      }

      return $;
   }

   GetShieldOverlayHotspot()
   {
      local i;
      
      foreach i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlayHotspot);
         }
      }

      return $;
   }

   GetShieldTranslation()
   {
      local i;

      foreach i in plOverlays
      {
         if IsClass(i,&GuildShield)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }

      return 0;
   }

   IsLoggedOn()
   {
      return pbLogged_on;
   }

   ClearQuestHistory()
   "Stubbed here, since variable is defined in user - DOH!"
   "(real function is also in user.kod)"
   {
      return;
   }

   ResetMonsterChasers()
   {
      piMonsterChasers = 0;

      return;
   }

   AddToMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers + level;

      return;
   }

   SubtractFromMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers - level;

      return;
   }

   GetMonsterChasers()
   {
      return piMonsterChasers;
   }

   SomeoneSaid(what=$,type=$,string=$,parm1=$,parm2=$,
               parm3=$,parm4=$,parm5=$,parm6=$,parm7=$,parm8=$)
   {
      local oSnoop;

      if type = SAY_NORMAL AND IsClass(what,&Player)
      {
         % si: removed (and what <> self) to allow communication
         % between shrunken head and owner.
         oSnoop = Send(self,@FindHolding,#class=&ShrunkenHead);
         if oSnoop <> $
         {
            Send(oSnoop,@SomeoneOverheard,#from=what,#to=self,#string=string);
         }
      }

      propagate;
   }

   SomeoneOverheard(from=$,to=$,type=$,string=$)
   {
      return;
   }

   RemoveInaccessibleSpells()
   {
      local num, i, oSpell, iability;

      foreach i in plSpells
      {
         num = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=num);
         if NOT Send(oSpell,@IsAccessible)
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            Send(self,@RemoveSpell,#num=num);
         }
      }

      Send(self,@ToCliStats,#group=3);
      Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      return;
   }

   ResetPlayerView()
   {
      AddPacket(1,BP_RESET_VIEW);
      SendPacket(poSession);

      return;
   }

   SetPlayerView(what = $, iFlags = 0, iHeight = 0, iLight = 0)
   {
      if what = $
      {
         Send(self,@ResetPlayerView);
      }
      else
      {
         AddPacket(1,BP_SET_VIEW, 4,what, 4,iFlags, 4,iHeight, 1,iLight);

         SendPacket(poSession);
      }

      return;
   }

   % Removes the shirt.  Used by the WarEvent event.
   RemoveShirt()
   {
      local i;
      
      foreach i in plUsing
      {
         if IsClass(i,&Shirt)
            OR IsClass(i,&LightRobe)
            OR IsClass(i,&Robe)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }

   BondItem(what=$)
   {
      if what = $ OR NOT IsClass(what,&Item)
      {
         Debug("Tried to bond to invalid item.");
      }

      if Send(what,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         %  this should only be possible through Admin fiddling
         return Send(SYS,@GetFailureRsc);
      }

      if poBondedItem <> $
      {
         Send(self,@ClearBondedItem);
      }

      poBondedItem = what;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@AddtoItem,
           #oItem=poBondedItem,#oPlayer=self);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      return;
   }

   ClearBondedItem()
   {
      local oldBondedItem;

      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      if poBondedItem = $
      {
         return;
      }

      oldBondedItem = poBondedItem;
      poBondedItem = $;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@RemoveFromItem,
            #oItem=oldBondedItem);

      return;
   }

   BondedItemReport()
   {
      ptBondedItemReport = $;
      if poBondedItem = $
      {
         Debug("trying to report location with no bonded item!");

         return;
      }

      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),
           @BondedItemReport,#BondedItem=poBondedItem,#BondedPlayer=self);

      return;
   }

   IsUndead()
   {
      return Send(self,@IsUsingA,#class=&NecromancerAmulet);
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing "
   "server time."
   {
      local time;

      % Reset our attack timer, a traditional use of this function when attack
      %  time was a timestamp instead of a timer.

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      time = GetTime();

      piLastDeathTime = time;
      piGuildRejoinTimestamp = time;
      piLast_restart_time = time;
      piTimeLastStomachUpdate = time;
      piTimeAttackedPlayer = time;

      return;
   }

   SendLightingInformation()
   {
      local i, oLightObject, iColor, iIntensity;

      if poIllusion_set <> $
      {
         if NOT Send(poIllusion_set,@IllusionGetLightingInformation,#who=self)
         {
            % No lighting information
            propagate;
         }

         return;
      }

      % Bitflag check, don't need to check anything if not set.
      if NOT (piDrawEffectFlag & OF_FLICKERING)
      {
         propagate;
      }

      iIntensity = 0;
      iColor = 0;
      % Check each lighting effect, strongest one wins.
      % TODO: these should be additive, and the client should produce
      % a combined lighting effect. Also, if more lighting effects are added
      % this should probably query everything, just in case.

      % Check torches and glow enchantment only here, hardcoded color/intensity.
      foreach i in plUsing
      {
         if IsClass(i,&Torch)
            OR (IsClass(i,&Weapon)
               AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            iIntensity = 60;
            iColor = LIGHT_FIRE;

            break;
         }
      }

      foreach i in plRadiusEnchantments
      {
         if Nth(i,3) = self
         {
            oLightObject = First(i);
            if Send(oLightObject,@GetOldAreaEnchStyle)
            {
               continue;
            }

            if Send(oLightObject,@GetLightIntensity) >= iIntensity
            {
                iIntensity = Send(oLightObject,@GetLightIntensity);
                iColor = Send(oLightObject,@GetLightColor);
            }
         }
      }

      if iIntensity > 0
      {
         AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC),
                   1,iIntensity, 2,iColor);

         return;
      }

      propagate;
   }

   IsInSameRoom(what = $)
   "Determine if given object is in same room as we are."
   {
      local what_owner, found;

      if poOwner = $ OR what = $
      {
         return FALSE;
      }

      found = FALSE;
      what_owner = Send(what,@GetOwner);
      while what_owner <> $
      {
         if what_owner = poOwner
         {
            found = TRUE;
            break;
         }
         what_owner = Send(what_owner,@GetOwner);
      }

      return found;
   }

   AddDonationYear(year = $)
   "Add to the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      local y;

      % Already in the list?
      foreach y in plDonationYears
      {
         if y = year
         {
            return;
         }
      }

      plDonationYears = Cons(year, plDonationYears);

      return;
   }

   RemoveDonationYear(year = $)
   "Remove from the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      plDonationYears = DelListElem(plDonationYears, year);

      return;
   }

   SetLoadoutList(set_list = $)
   {
      plLoadout_list = set_list;

      return;
   }

   GetLoadoutList()
   {
      return plLoadout_list;
   }

   BindPlayerToCurrentLocation()
   "Saves the player's current location as a special teleport destination."
   {
      if poOwner = $
      {
         return;
      }

      piBound_Room = Send(poOwner,@GetRoomNum);
      piBound_row = piRow;
      piBound_col = piCol;
      piBound_fine_row = piFine_row;
      piBound_fine_col = piFine_col;
      piBound_angle = Send(self,@GetAngle);

      return;
   }

   SendPlayerToBoundLocation()
   "Sends the player to their saved teleport destination."
   {
      if poOwner = $
         OR piBound_Room = $
         OR NOT pbLogged_on
      {
         return;
      }

      Send(SYS,@UtilGoNearSquare,#what=self,
            #where=Send(SYS,@FindRoomByNum,#num=piBound_room),
            #new_row=piBound_row,#new_col=piBound_col,
            #fine_row=piBound_fine_row,#fine_col=piBound_fine_col,
            #new_angle=piBound_angle, #max_distance=3);
      
      return;
   }

   GetBoundLocationName()
   {
      if piBound_room <> $
      {
         return Send(Send(SYS,@FindRoomByNum,#num=piBound_room),@GetName);
      }

      return $;
   }

   GetBoundLocationRoomNum()
   {
      return piBound_room;
   }

   GetBoundLocationRow()
   {
      return piBound_row;
   }

   GetBoundLocationCol()
   {
      return piBound_col;
   }

   SetDeathRiftProtection(value=FALSE)
   {
      if value=TRUE
         AND poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
      {
         % Only allow Death Rift Protection for those already
         % logged on and in the Underworld
         pbDeath_rift = TRUE;

         return;
      }

      if value=FALSE
      {
         if ptDeathRiftTimer <> $
         {
            DeleteTimer(ptDeathRiftTimer);
            ptDeathRiftTimer = $;
         }
         pbDeath_rift = FALSE;
      }

      return;
   }

   GetDeathRiftProtection()
   {
      return pbDeath_rift;
   }

   StartDeathRiftTimer()
   {
      ptDeathRiftTimer = CreateTimer(self,@DeathRiftBoot,DEATH_RIFT_INTERVAL);

      return;
   }

   DeathRiftBoot()
   "Players that linger too long will find themselves cast "
   "out of the Underworld."
   {
      ptDeathRiftTimer = $;

      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         AND Send(self,@GetDeathRiftProtection) = TRUE
      {
         Send(self,@AdminGoToSafety);

         if pbLogged_on
         {
            Send(self,@MsgSendUser,#message_rsc=death_rift_stayed_too_long);
         }
      }

      return;
   }

   LeaveBuilderGroupTimer()
   {
      ptLeaveBuilderGroupTimer = $;

      Send(self,@LeaveBuilderGroup);

      return;
   }

   LeaveBuilderGroup()
   {
      local i, each_obj;

      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = $;
      }

      if poOwner <> $
      {
         Send(poOwner,@RemoveFromBuilderGroup,#who=self);
         Send(poOwner,@SomethingChanged,#what=self);

         % Let's see that we left the group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChanged,#what=each_obj);
            }
         }
      }

      return;
   }

   JoinBuilderGroup()
   {
      local i, each_obj;

      % Refresh an active group membership
      if ptLeaveBuilderGroupTimer <> $
      {
         DeleteTimer(ptLeaveBuilderGroupTimer);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         return;
      }

      if poOwner <> $
      {
         Send(poOwner,@AddToBuilderGroup,#who=self);
         Send(poOwner,@SomethingChanged,#what=self);
         ptLeaveBuilderGroupTimer = CreateTimer(self,@LeaveBuilderGroupTimer,
                                       Send(poOwner,@GetGroupTime));

         % Let's see our new group
         foreach i in Send(poOwner,@GetPlActive)
         {
            each_obj = Send(poOwner,@HolderExtractObject,#data=i);
            if IsClass(each_obj,&User)
               AND Send(poOwner,@AreGroupedHere,#who=self,#what=each_obj)
            {
               Send(self,@SomethingChanged,#what=each_obj);
            }
         }
      }

      return;
   }

   IsCrystalizeManaSurging()
   {
      return piCrystalizeManaSurging;
   }

   StartCrystalizeManaSurge(surge_time=1000)
   {
      if ptCrystalizeManaSurgeTimer = $
      {
         ptCrystalizeManaSurgeTimer =
               CreateTimer(self,@EndCrystalizeManaSurgeTimer,surge_time);
         piCrystalizeManaSurging = TRUE;
         Send(self,@ComputeMaxMana);
      }

      return;
   }

   EndCrystalizeManaSurgeTimer()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@EndCrystalizeManaSurge);

      return;
   }

   EndCrystalizeManaSurge()
   {
      if ptCrystalizeManaSurgeTimer <> $
      {
         DeleteTimer(ptCrystalizeManaSurgeTimer);
         ptCrystalizeManaSurgeTimer = $;
      }

      Send(self,@ShowRemoveEnchantment,#what=Send(SYS,@FindSpellByNum,
            #num=SID_CRYSTALIZE_MANA),#type=ENCHANTMENT_PLAYER);
      piCrystalizeManaSurging = FALSE;
      Send(self,@ComputeMaxMana);

      return;
   }

   GetManaSurgeTimer()
   {
      return ptCrystalizeManaSurgeTimer;
   }

   RechargeAllRods()
   {
      local i, bGainedCharges;

      bGainedCharges = FALSE;

      foreach i in plPassive
      {
         if IsClass(i,&Rod)
            AND Send(i,@FullyRecharge)
         {
            bGainedCharges = TRUE;
         }
      }

      if bGainedCharges
      {
         Send(self,@MsgSendUser,#message_rsc=rods_fully_recharged_by_safe_place_msg);
      }

      return;
   }

   % This section deals with minion code.
   CommandMinionAttack(oMaster=$,oTarget=$)
   {
      local oActive;

      % If we have minions, we only want them to attack Battlers,
      % not items or anything else that can damage us.
      if plControlledMinions = $
         OR oTarget = $
         OR NOT IsClass(oTarget,&Battler)
         OR IsClass(oTarget,&Revenant)
      {
         return;
      }

      % Lets not have the minions kill each other. Check if the target is
      % a minion under our control.
      if IsClass(oTarget,&Monster)
         AND Send(oTarget,@GetMaster) = self
      {
         return;
      }

      if Send(self,@AllowPlayerAttack,#victim=oTarget)
      {
         foreach oActive in plControlledMinions
         {
            if IsClass(oActive,&Monster)
               AND Send(oActive,@GetMaster) = self
               AND Send(oActive,@GetTarget) <> oTarget
            {
               Send(oActive,@SetBehaviorFlag,
                     #flag=AI_MOVE_FOLLOW_MASTER,#value=FALSE);
               Send(oActive,@TargetSwitch,#what=oTarget,
                     #iHatred=100);
               Send(oActive,@EnterStateChase,#target=oTarget,
                     #actnow=TRUE);
            }
         }
      }

      return;
   }

   SumDamageReduction()
   {
      local iArmor, d;

      iArmor = 0;

      foreach d in plDefense_modifiers
      {
         if IsClass(d,&DefenseModifier)
         {
            iArmor = iArmor + Send(d,@GetDamageReduction);
         }

         if IsClass(d,&ArmorOfGort)
         {
            iArmor = iArmor + (Send(self,@GetEnchantedState,#what=d) / 25);
         }
      }

      return iArmor;
   }

   CanEvilTwin()
   {
      return TRUE;
   }

   GetReagentBag()
   {
      return GetListElemByClass(plPassive,&ReagentBag);
   }

   GetReagentBagContents()
   {
      local oBag;

      oBag = GetListElemByClass(plPassive,&ReagentBag);
      if oBag <> $
      {
         return Send(oBag,@GetReagentBagContents);
      }

      return $;
   }

   StartPhaseTimer()
   {
      local i;

      if ptPhaseTimer = $
      {
         ptPhaseTimer = CreateTimer(self,@PhaseTimerEnd,piRemainingPhaseTime);

         % Stop any rescue attempts if the user phases out.
         if ptRescue <> $
         {
            Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue_phase);
            DeleteTimer(ptRescue);
            ptRescue = $;
         }

         % If this player has created any evil twins, delete them.
         if plEvilTwins <> $
         {
            foreach i in plEvilTwins
            {
               Send(i,@Delete);
            }
            plEvilTwins = $;
         }
      }

      if ptPhaseVisualEffectTimer = $
      {
         ptPhaseVisualEffectTimer = CreateTimer(self,@PhaseVisualEffectTimer,2000);
      }

      % Add phase time to piTimeAttackedPlayer if it is currently
      % preventing the player from casting escape spells.
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 + (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }
   
   PhaseVisualEffectTimer(timer = $)
   {
      ptPhaseVisualEffectTimer = $;
      Send(self,@PhaseVisualEffect);

      return;
   }

   PhaseVisualEffect()
   {
      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }

      Send(Send(SYS,@FindSpellByNum,#num=SID_PHASE),
            @AdjustVisualEffectBasedOnTimeRemaining,#who=self);

      if ptPhaseVisualEffectTimer = $
         AND (piFlags & PFLAG_PHASED)
      {
         ptPhaseVisualEffectTimer = CreateTimer(self,@PhaseVisualEffectTimer,2000);
      }

      return;
   }

   FreezePhaseTimer()
   {
      if ptPhaseTimer <> $
      {
         piRemainingPhaseTime = GetTimeRemaining(ptPhaseTimer);
         DeleteTimer(ptPhaseTimer);
         ptPhaseTimer = $;
         
         if ptPhaseVisualEffectTimer <> $
         {
            DeleteTimer(ptPhaseVisualEffectTimer);
            ptPhaseVisualEffectTimer = $;
         }
      }

      % If we added phase time to piTimeAttackedPlayer before,
      % remove what is remaining (restore to original time).
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 - (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   PhaseTimerEnd()
   {
      local oPhase;

      ptPhaseTimer = $;

      if ptPhaseVisualEffectTimer <> $
      {
         DeleteTimer(ptPhaseVisualEffectTimer);
         ptPhaseVisualEffectTimer = $;
      }
      
      oPhase = Send(SYS,@FindSpellByNum,#num=SID_PHASE);
      Send(self,@RemoveEnchantment,#what=oPhase);
      Send(oPhase,@NotifyRoomPenalty,#who=self);
      Send(oPhase,@InflictFlatPenalties,#who=self);

      Post(self,@AdminGoToLastSafeRoom);

      Send(self,@RefreshPhaseTimeToBase);

      return;
   }

   GetRemainingPhaseTime()
   {
      if ptPhaseTimer <> $
      {
         return GetTimeRemaining(ptPhaseTimer);
      }

      return piRemainingPhaseTime;
   }

   GetBasePhaseTime()
   {
      if (piFlags & PFLAG_MURDERER)
         OR (piFlags & PFLAG_OUTLAW)
      {
         return Send(SETTINGS_OBJECT,
               @GetOutlawMurdererLogoffPenaltyGhostTime);
      }

      return Send(SETTINGS_OBJECT,@GetLogoffPenaltyGhostTime);
   }

   RefreshPhaseTimeToBase()
   {
      if piRemainingPhaseTime <> Send(self,@GetBasePhaseTime)
      {
         piRemainingPhaseTime = Send(self,@GetBasePhaseTime);
      }

      return;
   }

   SetPhaseTimeEqualTo(amount=60000)
   "Used by logoff ghosts to sync up penalty times."
   {
      piRemainingPhaseTime = amount;

      % Logoff ghosts call this when the player returns, so we remove
      % the phase time remaining from piTimeAttackedPlayer here if we
      % added it when the user logged off.
      if piTimeAttackedPlayer
            + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
            > GetTime()
      {
         piTimeAttackedPlayer = piTimeAttackedPlayer
                                 - (Send(self,@GetRemainingPhaseTime) / 1000);
      }

      return;
   }

   CanPhaseAgain(time=$)
   {
      if ptCanPhaseTimer <> $
      {
         return FALSE;
      }

      if time > 0
      {
         ptCanPhaseTimer = CreateTimer(self,@CanPhaseTimer,time);
      }

      return TRUE;
   }

   CanPhaseTimer()
   {
      ptCanPhaseTimer = $;

      return;
   }

   GetLastPvpWarned()
   {
      return piTimeAttackedByPlayer;
   }
   
   DoPvpNotify()
   {
      % Don't gong if we are already in pvp
      if piTimeAttackedPlayer < GetTime() - PVP_NOTIFY_DECAY
      {
         if poOwner <> $
         {
            Send(poOwner,@SomethingWaveRoom,#what=self,
                  #wave_rsc=pvp_notify_wav);
            piTimeAttackedByPlayer = GetTime();
         }
      }

      return;
   }

   % Use this for when either phase or spectator do the same thing
   IsInCannotInteractMode()
   {
      if (piFlags & PFLAG_PHASED)
         OR (piFlags & PFLAG_SPECTATOR)
      {
         return TRUE;
      }

      return FALSE;
   }

   IsLikelyVictim()
   {
      if Send(self,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      propagate;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
