% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Player is Battler
   
% Don't instantiate this class--use things derived from it

constants:

   include blakston.khd
   include protocol.khd

   % Three minutes
   BOND_REPORT_INTERVAL = 1000 * 60 * 3   

   KARMA_TUNE_A_INVERSE = 20
   KARMA_TUNE_B_INVERSE = 5

   %%% COMBAT PACING PARAMETERS
   % These parameters control how often it is possible to have combat
   % assuming readily available opponents.   Xian 4/3/96
   %
   % Parameter: Base Regeneration Time (sec)
   % Meaning:   Time needed for a nearly-killed player of stamina 25 
   %             to rest fully or player of intelligence 25 to recover mana
   % Formula:   BASE_REGEN_TIME / 1000
   % Currently: 150 sec = 2.5 min
   % Note:      The fastest time scale
   %
   % Parameter: Vigor Recovery Time (sec)
   % Meaning:   Time needed to fully rest after complete vigor depletion
   % Formula:   REST_THRESHOLD * REST_TIME / 1000
   % Currently: 200 sec = 3.3 min
   % Note:      Should be slower than health and mana refresh
   % 
   % Parameter: Food Digestion Time (sec)
   % Meaning:   Time needed to completely empty a full stomach
   % Formula:   10000 / FOOD_USE_RATE
   % Currently: 833 sec = 13.9 min
   % Note:      Need empty stomach to get vigor boost from food
   BASE_REGEN_TIME = 150000

   % Rate at which stomach empties.
   FOOD_USE_RATE = 12

   % Smallest worthwhile change to vigor (X 10e-4)
   MIN_VIGOR_CHANGE = 20000

   % Effective vigor debit per attack (X 10e-4)
   ATTACK_EXERTION = 5000

   % Number of ms required to gain one vigor point
   REST_TIME = 2500          

   % Number of ms to lose one boosted health or mana point.
   BOOST_DECAY_TIME = 30000 

   % Currently: 10 improves every 15-22 minutes.
   ADVANCE_TIMER_MIN =   900000
   ADVANCE_TIMER_MAX =   1320000
   ADVANCEMENT_LIMIT =   10

   PKPOINTER_TIME = 10*60*1000

   PLAYER_TRANSLATION_LEGS_MASK = 0xff
   PLAYER_TRANSLATION_LEGS_MUL = 1
   PLAYER_TRANSLATION_BODY_MASK = 0xff00
   PLAYER_TRANSLATION_BODY_MUL = 0x100
   PLAYER_TRANSLATION_Skin_MASK = 0xff0000
   PLAYER_TRANSLATION_Skin_MUL = 0x10000

   PLAYER_TRANSLATION2_HAIR_MASK = 0xff
   PLAYER_TRANSLATION2_HAIR_MUL = 1
   PLAYER_TRANSLATION2_ARMS_MASK = 0xff00
   PLAYER_TRANSLATION2_ARMS_MUL = 0x100

   SHIRT_MASK = 0x00ff
   SHIRT_MUL  = 0x0001
   PANTS_MASK = 0xff00
   PANTS_MUL  = 0x0100
   
   BASE_NEED = 105

   % If vigor gets this low, see if second wind skill kicks in.
   SECONDWIND_THRESHOLD = 25
   
   % How steep is the curve for learning new levels of spells?
   %  A higher number means a greater slope (less points at low levels)
   POINTS_SLOPE = 7                 

   % Sets a reasonable lower level on the number of percents needed to
   %  advance to the next level of spells/skills.
   MIN_NEEDED_TO_ADVANCE = 75       
                                    
   % How many weapon swings until we get an improve check?
   SWINGS_PER_IMPROVE_CHECK = 75    

   % What's the length after having a player attacked before we let "mules" 
   %  cast on them again.  Currently set to 15 minutes.  Should be bigger 
   %  than logoff ghost time (currently 10 mins)
   ATTACKED_PLAYER_WAIT = 15 * 60

   % Damage is capped at piBase_Max_Health divided by this number.  Reduces
   %  newbie slaughter.
   MAX_HEALTH_DAMAGE_FRACTION = 3

   % Damage is overall capped to this number.  Gives a slight edge to people
   %  with higher hps.
   MAX_DAMAGE_PER_HIT = 30

   % What's the maximum stat we can have after modification?
   MAXIMUM_STAT = 70

resources:

   player_cant_broadcast = \
      "You can't broadcast a message--you don't have enough mana."
   player_squelched = "You are prevented from broadcasting messages for now."
   player_cant_send = \
      "You can't send this message--you don't have enough mana."
   player_silent_room = "Your telepathic abilities will not work here."

   player_use_broken = "You can't use %s%s--it's broken."
   player_cant_use = "You can't use that."
   player_using_already = "You are already using that."
   player_use_full = "You are using too many things like that already."
   player_use_full_hands = "Your hands are too full to use that."
   player_not_using = "You are not using that."
   player_not_holding = "You are not even holding %s%s."
   
   player_hit_color_red = "~r"
   player_hit_color_blue = "~b"
   player_hit_color_none = ""

   player_token_reward = \
      "Let me give you %s%s as payment for returning the token."
   player_token_reward_heavy = \
      "Feel free to take the %s%s by your feet as payment for returning the "
      "token."
   player_improve_maxhealth = "~I~BYou suddenly feel a little tougher."
   player_spits = "You spit on the corpse of your unworthy foe."
   player_regain_angel = \
      "Due to your weakness, your protective guardian angel returns."
   player_no_angel = "You suddenly feel more vulnerable."

   player_join_faction = \
      "~IYour name is entered on the roll of membership for %s%s's political "
      "faction."
   player_lost_token = \
      "The token refuses to enter the guild hall and writhes in your hands.  "
      "You cannot hold it."
   player_intrigue_shut = "~IThe Royal Court no longer needs your services."
   player_lost_intriguing = \
      "~IYou doubt you are still worthy of notice by the Royal Court."
   player_faction_time = \
      "~IYour liege is no longer convinced of your loyalty. You should visit "
      "your liege at court again."
   player_faction_attacked = \
      "~BYou have attacked a member of your own faction!"
   player_non_intriguing_attacked = \
      "~BYou have displeased your liege by attacking a potential future ally!"
   player_unfactioned = \
      "~IYour liege has no use for one such as you, lacking in prowess or "
      "devotion.  Your name has been stricken from the roll of membership.~n"

   player_cancel_rescue = \
      "~IYour aggression halts your attempt to escape from the current situation."

   player_improved = "~I~BYou have improved in the art of %s."
   player_improved_wav_rsc = imp.wav
   player_aggressor = "Shal'ille frowns upon your unprovoked attack."
   player_safety_caught = \
      "Hey!  You almost hit %s%s!  Good thing your safety was on!"

   player_safe_server = \
      "You are not allowed to attack other players in this world."
   player_no_enter = \
      "Your guardian angel holds you back and prevents you from entering here."
   player_assgame_soon = \
      "~kRoq tells you, \"~IA new Assassin's Circle shall be initiated "
      "shortly.\""

   player_tougher_wav_rsc = tougher.wav
   player_missed_something_wave_rsc = swordmis.wav
   player_killed_something = "You killed %s%s."
   player_killed_player = \
      "You have killed another player and have been branded a murderer."
   player_wanted_now = "You are now wanted for the murder of %s%s."
   player_haunted_on = "%s%s's violent death summons forth a revenant."
   player_haunted_off = "The revenant is satisfied."

   player_health_gain_maxed = "Your health cannot increase any further."
   
   player_cant_hit_newbie = \
      "You are not yet experienced enough to fight other players."
   player_guardian_angel = \
      "A guardian angel whispers to you, \"You may not attack %s%s.\""
   player_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot protect you here.\""
   player_angel_rejoins = "Your guardian angel rejoins you."
   player_lose_node = "You lose your connection to the mana node in %s."

   player_hit_immunity =  "%s%s%s laughs off your pitiful blow."
   player_hit_resisted = "%s%s%s shrugs off your attack."
   player_hit_anti_resisted = "%s%s%s staggers backwards from the blow."
   player_hit_anti_immunity = \
      "%s%s%s convulses and seems to be suffering badly."
   
   player_immune_to_hit = "%sMysteriously, you feel almost no pain!"
   player_resists_hit = "%sMuch of the pain fades away."
   player_anti_resists_hit = \
      "%sThe pain seems to resonate and grow inside you."
   player_anti_immune_to_hit = \
      "%sYour body is wracked with pain of incredible magnitude."
   
   player_was_missed = "%s%s%s misses you."
   player_was_hit = "%s%s%s hits you."
   player_was_slashed = "%s%s%s slashes your side, leaving a nasty cut."
   player_was_bludgeoned = "%s%s%s bludgeons you, causing a large bruise."
   player_was_pierced = "%s%s%s slyly pierces you while you were distracted."
   player_was_thrusted = "%s%s%s skewers you with a deft thrust.  Sluish!"
   player_was_burned = "%s%s%s's fire flares brightly, leaving you charred."
   player_was_shocked = "%s%s%s grins as a jolt of electricity hits you."
   player_was_frozen = "%s%s%s stings you with a jolt of cold."
   player_was_quaked = "%s%s%s's tremors shake you about."
   player_was_holyhit = "%s%s%s hits you with a jolt of purity."
   player_was_unholyhit = \
      "%s%s%s hits you, and you feel your soul has been invaded."
   player_was_stung = "%s%s%s dances away after having stung you badly."
   player_was_bitten = "%s%s%s bites you several times, leaving you bloody."
   player_was_clawed = "%s%s%s rends your flesh with razor sharp claws."
   player_was_punched = "%s%s%s hits you with a solid punch."
   player_was_kicked = "%s%s%s slams a foot into your gut."
   
   player_out_of_room = "%s%s is not here."
   player_not_supported = "Not supported yet"
   
   player_attack_out_of_range = "%s%s is too far away to hit with %s%s."
   player_attack_out_of_punch_range = "You can't reach %s%s with your %s."
   player_attack_out_of_spell_range = "%s%s is out of range."
   player_attack_not_in_view = "You can't see your selected target."

   player_no_target_self = "You cannot attack yourself."
   player_no_target_self_spell = "You cannot cast this spell on yourself."

   player_cant_apply = "You can't use %s%s on other things."
   
   player_wave_hit = hit.wav
   
   player_level_music = perc2.mid
   
   % These are now old resources..... here in case we want to de-hack...
   player_desc_guild = "%q of %s%q."
   player_no_guild = "No known guild affiliation."
   player_faction_duke = "A staunch servant of Duke Akardius."
   player_faction_princess = "Firmly loyal to Princess Kateriina."
   player_faction_rebel = "A freedom fighter supporting Jonas."
   player_faction_neutral = \
      "Not a court vassal, yet affected by the Meridian Council."
   player_not_intriguing = "Not yet concerned with affairs at the Royal Court."

   player_nl = "\n"
   player_sp = " "
   player_dot = "."
   player_citizen_barloque = " has been a Barloquan"
   player_citizen_tos = " has been a citizen of Tos"
   player_citizen_cornoth = " hailed from Cor Noth"
   player_citizen_jasper = " has called Jasper home"
   player_citizen_marion = " has been a Marionite"
   player_citizen_raza = " is of Raza"
   player_citizen_hazar = " is of Hazar"
   player_citizen_kocatan = " has lived in Ko'catan"
   player_citizen_unknown = " has wandered"
   player_of = " of "
   player_for = " for "
   player_years = " years."
   player_year = " year."
   player_under_one_year = " less than a year."

   player_is_justicar = "Elected Royal Justicar of the Meridian."

   player_is_holding = " is holding "

   player_known_for_mastery = "Known far and wide for mastery of "
   player_and = " and "
   player_magics = " magics"
   player_skills = "weaponcraft skills"

   % Here's the new extended resources....
   player_desc_guild_faction_neutral = \
      "%q of %s%q.  Not associated with any faction, yet concerned with the "
      "intrigue of the Royal Court."
   player_desc_guild_faction_duke = \
      "%q of %s%q.  A devoted servant of Duke Akardius."
   player_desc_guild_faction_princess = \
      "%q of %s%q.  Firmly loyal to Princess Kateriina."
   player_desc_guild_not_intriguing = \
      "%q of %s%q.  Not yet concerned with affairs at the Royal Court."

   player_no_guild_faction_neutral = \
      "No known guild affiliation. Not associated with any faction, yet "
      "concerned with the intrigue of the Royal Court."
   player_no_guild_faction_duke = \
      "No known guild affiliation. A devoted servant of Duke Akardius."
   player_no_guild_faction_princess = \
      "No known guild affiliation. Firmly loyal to Princess Kateriina."
   player_no_guild_not_intriguing = \
      "No known guild affiliation. Not yet concerned with affairs at the "
      "Royal Court."

   player_donation_title = "Noble benefactor of Meridian in "
   player_donation_separator = ", "

   player_dagger_shatters = "Your black dagger crumbles into dust."

   player_desc_enchanted_none = "%q"
   player_desc_enchanted = "%s has %s%s.\n\n%s"
   
   player_too_full = "You are too full to eat."
   player_too_full_drink = "You are too full to drink."

   player_to_hunters = "You detect that %s%s could be found somewhere around %s"

   player_dead_male_icona_rsc = playerXa.bgf
   player_dead_male_iconb_rsc = playerXb.bgf
   player_dead_female_icona_rsc = heraXa.bgf
   player_dead_female_iconb_rsc = heraXb.bgf
   
   player_dead_male_name_rsc = "dead male body"
   player_dead_female_name_rsc = "dead female body"
   
   playerm_death_wav = pdeath.wav
   playerf_death_wav = pdeathf.wav

   player_token_death = \
      "As you die, the token pulsates, and you feel an odd sensation..."

   player_dance = \
      "You swallow your pride and get down to the ditty in your head."
   player_cant_dance = \
      "You can't dance, all the stuff in your hands is cramping your style!"
   player_cant_dance_resting = \
      "You're sitting right now.  Let's not take this \'getting down\' stuff "
      "too literally, ok?"
   player_stop_dance = "\
      You lose your rhythm and settle out of your dancing frenzy." 

   player_wave = "You wave your hand."
   player_point = "You point."
   
   player_sword_overlay_icon_rsc = swordov.bgf
   player_mace_overlay_icon_rsc = maceov.bgf
   player_scimitar_overlay_icon_rsc = scimov.bgf
   player_short_sword_overlay_icon_rsc = shswdov.bgf
   player_hammer_overlay_icon_rsc = hamrov.bgf
   player_axe_overlay_icon_rsc = axeov.bgf
   
   player_window_overlay_hand = povhand.bgf
   player_window_overlay_glow = povglow.bgf

   player_male_icon_rsc = bta.bgf
   player_female_icon_rsc = btb.bgf  
   
   player_legs_a_rsc = bfa.bgf
   player_legs_b_rsc = bfb.bgf
   player_legs_c_rsc = bfc.bgf
   player_legs_d_rsc = bfd.bgf
  
   player_rightarm_a_rsc = bra.bgf
   player_rightarm_b_rsc = brb.bgf
   
   player_leftarm_a_rsc = bla.bgf
   player_leftarm_b_rsc = blb.bgf
   
   % hair for Rob
   player_toupee_q_rsc = ptq.bgf

   player_sound_learn_spell = splearn.wav

   player_angel = "Your guardian angel"
   intrigue_ambassador = "Baron Springer of Cor Noth Township"

   player_newbie_honor_string = "This soul is new to the lands of Meridian 59."

   player_newbie_commands = \
      "\n~BBasic Commands for Meridian 59:~B\n"
      "~IUse these mouse and keyboard commands to interact with the world.\n"
      "These are the default commands.  You can change the keyboard commands "
      "by going to the menu item~I ~wGame > Configuration.\n"
      "~rright-click on an object ~b- examines an object, letting you see "
      "more detail.  Right-click on the sign in this area to learn more.\n"
      "~rspace bar ~b- go through doors, like the blue door to the north.\n"
      "~rE key ~b- attack monsters.  You may want to wield a weapon first!\n"
      "~n~IType the following commands (red text) into the text bar below. "
      "You can press the RETURN key to move to the chat window.~I\n"
      "~rsay (message) ~b- send a message to everyone in the same room.\n"
      "~rtell (player name) (message) ~b- Send a message to a single player "
      "in private.\n"
      "~rbroadcast (message) ~b- send a message to everyone that is logged "
      "on.\n"
      "~rwho ~b- shows a list of all the people logged into the game right "
      "now.\n"
      "~rmail ~b- opens up your mail folder.  Read the messages from your "
      "guardian angel!\n"
      "~rhelp ~b- opens our web-based help pages.  It will take a few "
      "seconds to load.\n"

   player_safety_on_mail = \
      "Your safety is currently on, meaning you cannot cast hostile spells or "
      "attack innocent players."
   player_safety_off_mail = \
      "Your safety is currently off.  If you do not wish to attack innocent "
      "players, I heartily recommend that you turn it on."

   player_ready_to_kill = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword against other "
      "players if you so desire.  It is with a heavy heart that I take my "
      "leave of you, but I trust that you will do fine without me."
      "\n\n"
      "You also have many other rights and responsibilities available to "
      "you.  You can now join a guild with other friends.  Guilds are a good "
      "way to gain protection from those that would do you harm.  Joining a "
      "good guild will make the difference between merely surviving or "
      "thriving in the world.  Guilds can also get into wars with other "
      "guilds, so be careful that you don't make too many enemies."
      "\n\n"
      "You can also participate in the politics of Meridian.  In the royal "
      "city of Barloque there is a clerk named Caramo which handles the "
      "election of the position of Justicar.  The Justicar pardons those that "
      "have been flagged as outlaws and murderers.  Unless you wish to see "
      "such villians get pardons, it is important to be active in voting."
      "\n\n"
      "I must warn you that engaging in lethal combat against other players "
      "may soil your good name.  If you strike an innocent, or cast "
      "a spell which harms him, you may be branded an outlaw, an onus which "
      "only fades upon your death.  If you slay an innocent in cold blood, "
      "you will be blacklisted as a murderer, and this is a weight upon your "
      "soul which does not easily depart.  This puts you at risk:  since "
      "murderers and outlaws are not innocents, one may attack them without "
      "being named a murderer or an outlaw."
      "\n\n"
      "Also note that assisting an outlaw or murder by casting helpful spells "
      "upon them will brand you an outlaw in the eyes of society.  You must "
      "choose your friends and your enemies well!"
      "\n\n"
      "If you do not wish to engage in the unsavory practice of attacking "
      "innocents or assisting the unlawful, it is heartily recommended that "
      "you do not enable attacking innocents in your game preferences.  This "
      "is also called your \"safety\" since it keeps you safe from being "
      "outcast as an unlawful outlaw or murderer.  While your safety is on, "
      "you are not permitted to either attack innocents or cast spells that "
      "are hostile to them.  This can be crucial when one stray sword blow "
      "can make you an outlaw.  However, rest assured that you will always be "
      "permitted to strike outlaws and murderers, since it is crucial that "
      "you always have the option of defending yourself from their "
      "treacherous ways."
      "\n\n"
      "%s"
      "\n\n"
      "Finally, some last bits of advice as I depart.  Do not dispair if "
      "you are sent to the underworld by some monster or even another "
      "player.  Death is part of the cycle, and learning to recover from "
      "death is important.  Put some items away in the vault in Barloque for "
      "times when you find yourself killed and unable to get items from your "
      "corpse.  Also, ask politely for assistance and you will often find "
      "someone willing to lend a helping hand.  Make some friends and you "
      "will find that nothing is truly beyond your reach."
      "\n\n"
      "Have fun in Meridian!"
      "\n\n"
      "  -- Your guardian angel"

   player_ready_to_guild = "Subject: Congratulations!\n"
      "Your character has been deemed ready to take on the world without "
      "my protection, meaning that you may now raise your sword with fellow "
      "players and engage in guild politics.  It is with a heavy heart that I "
      "take my leave of you, but I trust that you will do fine without me.\n\n"
      "%s\n\n"
      "  -- Your guardian angel"

   player_tutorial_mail = "Subject: You're doing well for yourself.\n"
      "It's nice to see that you seem to be doing well.  "
      "I thought I might take this time to explain some finer points of "
      "the world of Meridian to you."
      "\n\n"
      "There are a variety of spells and skill schools that you can "
      "advance in.  However, learning from all spell and skill schools "
      "dilutes your focus, and slows down your learning.  The more you "
      "narrow your focus onto one or two particular spell schools, the "
      "quicker you will advance in that spell school, and the sooner you "
      "will be offered new spells in that school.  Stray from the path, "
      "however, and you will find that teachers may not offer you spells that "
      "they had previously offered you.  Thus, you must choose very early on "
      "whether or not you prefer the versatility of being able to pull from a "
      "multitude of low level spells and skills, or the power of excelling in "
      "one or two.  Therefore, be sure that you examine any potential ability "
      "before you acquire it!"
      "\n\n"
      "No advancement is more prized than increasing your endurance by "
      "gaining health points.  Note you that those who go toe to toe with "
      "monsters are more likely to advance in health than those who stay "
      "safely out of harm's way, slinging fireballs.  Also, attacking "
      "insignificant foes earns you no points for valor, and offers no hope "
      "of advancement."
      "\n\n"
      "Your vigor is crucial - it helps determine how fast your health and "
      "mana returns to you - a tired warrior will find these resources "
      "fleeting.  Vigor can be restored either through needed rest or a "
      "hearty meal."
      "\n\n"
      "I congratulate you on your recent success.  I know the bards will sing "
      "of your future exploits."
      "\n\n"
      "  -- Your guardian angel"

   player_first_mail = "Subject: Welcome!\n"
      "Welcome to Meridian 59!  I hope you enjoy the exciting world waiting "
      "for you!"
      "\n\n"
      "You have entered an on-line community, meaning that you may well be "
      "playing with several other players at a time.  Making allies and "
      "dealing with potential enemy players is as much a part of Meridian 59 "
      "as killing monsters.  We hope you feel at home in your new online "
      "community."
      "\n\n"
      "I am your guardian angel, and thus I shall protect you from the spells "
      "and swords of other players for a short time.  Use this time to "
      "acquaint yourself with the world, and to gather your resources.  Know "
      "you that the shops of the land are always safe zones, and the inns are "
      "good places to rest and recover your strength."
      "\n\n"
      "Spells and skills will almost certainly be crucial to your success.  "
      "Note that a young warrior's skills are stronger than a inexperienced "
      "wizard's spells, but at the higher end, the sorcerer is far more "
      "formidable to deal with given his variety of options.  The apprentice "
      "will almost always need the steady sword of the mercenary by his side "
      "to get that far, so find comrades who complement your abilities."
      "\n\n"
      "You can learn a lot by talking to the little people: the shopkeepers, "
      "the bankers, the innkeepers.  Ask them for help.  Sometimes, they "
      "may even wish for you to run an errand for them if you ask."
      "\n\n"
      "For your first quest, you may wish to research which hometown you were "
      "born in.  You can ask any of the towns' people you meet for their "
      "opinions about the different towns.  To permanently select a hometown, "
      "you need to adventure to the Hall of Genealogy in the town of Cor Noth "
      "and look through the books there.  Take your time selecting your "
      "hometown, as it may determine how other people interact with you."
      "\n\n"
      "Death is unkind to you - avoid it!  A death can make you weaker, and "
      "all of your possessions are left where you met your demise, where any "
      "scavenger, human or otherwise, may take it as they please.  Best that "
      "you join an ally on your travels that they may gather your valuables "
      "should you meet such an unfortunate fate."
      "\n\n"
      "Lastly, if you wish to leave this land for a bit, merely log off.  "
      "When you log on, you will reappear where you left.  However for "
      "reasons of saftey, it is highly recommended that you do so in a safe "
      "place, such as an inn.  If you log off outside an inn, you may take "
      "losses similar to death as your soul did not leave the land "
      "completely when you logged off."
      "\n\n"
      "We hope that you enjoy your stay in our land."
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail = "Subject: Death\n"
      "It saddens me that you fell in combat and into the underworld.  It is "
      "a dangerous life as an adventurer, as you have undoubtedly learned."
      "\n\n"
      "Since you are so young, I have pleaded to the gods that you should be "
      "spared some of the penalty for death.  Normally, the shock of leaving "
      "the underworld would reduce your maximum health and penalize you a "
      "small part of the spells and skills you have learned so far.  I will "
      "spare you the cost of your health, and only a few of your spells and "
      "skill will be reduced after you leave the underworld."
      "\n\n"
      "You will also notice that your possessions are gone.  They were left "
      "behind at your corpse where you died.  The items will only remain "
      "there a limited amount of time, so you must act quickly."
      "\n\n"
      "If you don't know where you died, then you should broadcast for help.  "
      "Type \"broadcast Can someone help me find my items?\" right now and "
      "watch for someone to respond to you.  Tell that person what you can "
      "remember about where you were fighting.  Often you will find someone "
      "kind to help you, or they might even help you get better equipment "
      "than you had before.  There are many kind souls in this land"
      "\n\n"
      "If you know where you died, the portal archways in the underworld will "
      "take you directly to the inns of the cities of the mainland.  The "
      "large rip in space in the western side of the underworld is often the "
      "quickest way back.  It randomly switches between the different inns.  "
      "Look (right-click by default) the portal to see where it leads.  If it "
      "leads to the place you want to go, enter it quickly!  It will not lead "
      "there for very long."
      "\n\n"
      "Do not be discouraged!  Many powerful warriors have stumbled into the "
      "fires of the underworld.  What makes them powerful is that they "
      "decided to fight on, gaining power and ability to vanquish the "
      "terrible monsters that felled them before!"
      "\n\n"
      "  -- Your guardian angel"

   player_death_mail_notice = \
      "Your guardian angel has sent you a special game mail on how to cope "
      "with death.  Type ~Imail~I and read the last game mail from your "
      "guardian angel."

   player_intrigue_mail = "Subject: Invitation to visit the Royal Court\n"
      "Oh, most worthy adventurer.  Tales of your exploits have been oft told "
      "here at the Court, and recently, the Meridian Council itself declared "
      "you to possess considerable promise. Perhaps someday you will be "
      "given the honor of studying and guarding one of the Five Tokens."
      "\n\n"
      "The Council serves our fair land by using their acquired knowledge to "
      "benefit daily life. For the most part, they are honest and impartial "
      "in their decisions - guided by the Priestess of Shal'ille. However, "
      "Duke Akardius and Princess Kateriina and their factions of followers "
      "try to sway the Council down differing paths:"
      "\n\n"
      "Duke Akardius wishes for more of the Council's energies to be used for "
      "the benefit of commerce and the study of lore, while the Princess "
      "seeks their aid in advancing knowledge of magic. Both believe their "
      "path is the way to reduce the plague of monsters which terrify the "
      "land these days."
      "\n\n"
      "There are also boorish tales of a third faction of rebels.  They "
      "are dissatisfied with the current political climate and seek to "
      "bring their leader to rule our lands.  I do not know much about "
      "these rebels, nor do I care to learn anything.  You are on your own "
      "if you wish to learn about them."
      "\n\n"
      "Should you desire to join any of these factions, seek the Liege. "
      "As a faction member, you can help to influence the Council yourself, "
      "and share in the benefits of belonging to the party in power. You will "
      "need to demonstrate fealty to your Liege on a regular basis to "
      "keep your name on the rolls. Even if you join neither faction, you "
      "will still be influenced by the Council's decisions - as are all."
      "\n\n"
      "Fair partings, and perhaps we will someday meet at the court."
      "\n\n"
      "----Baron of Cor Noth Township, Gerah Springer."

   player_Debug_playercanlearn = \
      "Do the math for %s to learn a %i level spell from the %s school.  "
      "%i points from spells already known (%i from this school).  Intellect "
      "reduces the needed by %i for a total of %i percent needed.  Currently "
      "possesses %i percent to compensate for the need."

   player_Debug_playercanlearn_scarcity = \
      "Due to the scarcity of spells at that level in that school, "
      "the need has been reduced to %i more points."
   
   player_Debug_nokarma = "%s cannot learn %s due to karma restrictions."
   player_Debug_noway = "It is impossible for %s to ever get the %s spell."

   player_sound_sword1 = sword1.wav
   player_sound_sword2 = sword2.wav
   player_sound_sword3 = sword3.wav

   player_sound_metal1 = swrdmtl1.wav
   player_sound_metal2 = swrdmtl2.wav
   player_sound_metal3 = swrdmtl3.wav

   player_sound_hit_monster_flesh1 = fhit1b.wav
   player_sound_hit_monster_flesh2 = fhit2b.wav
   player_sound_hit_monster_flesh3 = fhit3b.wav

   player_sound_hit_monster_leather1 = lhit1b.wav
   player_sound_hit_monster_leather2 = lhit2b.wav
   player_sound_hit_monster_leather3 = lhit3b.wav

   player_sound_hit_monster_metal1 = mhit1b.wav
   player_sound_hit_monster_metal2 = mhit2b.wav
   player_sound_hit_monster_metal3 = mhit3b.wav

   % in increasing order of agony
   player_sound_male_ouch1 = ouchm1.wav	  
   player_sound_male_ouch2 = ouchm2.wav
   player_sound_male_ouch3 = ouchm3.wav
   player_sound_male_ouch4 = ouchm4.wav

   player_sound_female_ouch1 = ouchf1.wav
   player_sound_female_ouch2 = ouchf2.wav
   player_sound_female_ouch3 = ouchf3.wav
   player_sound_female_ouch4 = ouchf4.wav

   player_eavesdrop_login_str = "~B~g[~n%s has logged in.~B~g]"
   player_eavesdrop_str = "~B~g[~n%s tells %s, \"%q~n\"~B~g]"
   player_eavesdrop_logout_str = "~B~g[~n%s has disconnected.~B~g]"

   player_admin_added_spell = "Spell added."
   player_admin_modified_spell = "Spell modified."
   player_admin_removed_spell = "Spell removed."
   player_admin_added_skill = "Skill added."
   player_admin_modified_skill = "Skill modified."
   player_admin_removed_skill = "Skill removed."

   player_logged_on_wav_rsc = player_login_or_out.wav
   player_logged_off_wav_rsc = player_logout2.wav

classvars:

   viHand_space = 2
   viBody_space = 1

   viQuiver_space = 1
   viNeck_space = 1
   viHead_space = 1
   viLeg_space = 1

   viFinger_space = 2
   viGauntlet_space = 1

   % Our actual max is this plus a bonus for might.
   viBulk_hold_max = 1700
   viWeight_hold_max = 1700

   viMax_vigor = 200

properties:

   vrIcon = player_male_icon_rsc

   poSession
   pbLogged_on = FALSE

   % This is used to determine raises in hit points only.
   poKill_target = $
   piGain_chance = 0

   % Flags for various character attributes.
   piFlags = 0
   piFlags2 = 0

   % A generic modifier.  Setting this value can help or hinder a character.
   %  Intended for use to curb overagressive players or to give a boost to
   %  nicer players. Named something unusual to deter experimentation.
   piFlags3 = 0

   % player starts unguilded--doesn't do much yet
   poGuild = $
   piGuildRejoinTimestamp = 0

   % list of spells we know, in the form of a 3-part compound
   plSpells = $

   % list of skills we know, in the form of a 3-part compound
   plSkills = $

   % A list of the total percentage points the player has in the various
   %  spell and skill schools.
   plSchools = $

   % A list of the weighted casts the player has made in various schools.
   %  Weighted because higher level spells will contribute more points to
   %  the total.  Used to give bonuses to improving spells.
   %  See spell.kod for details.
   plSchoolCasts = $

   % The number of swings with the current weapon
   piWeaponSwings = 0

   % A compound of if the player can advance and the WC proficiency needed
   %  to use the weapon.  The proficiency number is the number / 1000, while
   %  the bonus to advance is the number mod 1000.
   piWeaponInfo = 0

   % converted guild commands list to a bitvector.
   piGuild_commands = 0

   piLast_restart_time = 0

   % Permanent character base stats.
   piMight = 0
   piIntellect = 0
   piStamina = 0
   piAgility = 0
   piMysticism = 0
   piAim = 0

   % Modifiers to those base stats.
   piMightMod = 0
   piIntellectMod = 0
   piStaminaMod = 0
   piAgilityMod = 0
   piMysticismMod = 0
   piAimMod = 0

   %%% Variable character values.

   % The player sees piMax_Health in their client.
   % piBase_Max_Health is their base without any modifiers
   piHealth = 20
   piMax_Health = 20
   piBase_Max_Health = 20

   piMax_Mana = 20
   piMana = 20

   % piKarma is measured in hundreths of karma units
   piKarma = 0

   % Percent stomach is full.
   piStomach = 0

   % Governs health and mana replacement rates
   piVigor = 100
   % Accumulates small vigor debits from attacks, etc.
   piExertion = 0

   % This replaces a timer
   piTimeLastStomachUpdate = 0

   % stuff in use
   plUsing = $

   % Timers 
   ptHealth = $
   ptMana = $
   ptAdvancement = $
   ptRest = $

   % Poison info
   ptPoison = $
   piPoisonStrength = 0

   % List of objects adding overlays to us.
   plOverlays = $

   % List of objects with window overlays.
   plWindow_overlays = $
   
   % Object that set our icon (usually armor)
   poIcon_set = $

   % Object that ditched our hair (usually helmets)
   poHair_remove = $

   % object that set our legs (usually pants)
   poLegs_set = $
   poArms_set = $

   % Object that sets our entire look (overrides any part changes)
   poIllusion_set = $

   piBody_translations = 0
   piBody_translations2 = 0

   % Default: green shirt, brown pants.
   piDefault_Clothes = 143 | (121 * PANTS_MUL)

   % Light source at player.
   % Default strength of light source at player is 5
   piLight = 5       

   % List of enchantments.
   % Each element is [ timer, object of spell, [optional state] ].
   plEnchantments = $

   % Attack modifiers to attack roll & damage (includes items & spells)
   plAttack_modifiers = $
   
   % Defense modifiers to defense roll & damage (includes items & spells)
   plDefense_modifiers = $
   
   piGender = GENDER_MALE

   piVigor_rest_threshold = 80

   % The user's string description, typed when created (and editable in game).
   psPlayerDescription = $

   % Draw effects flags
   piDrawFX = 0

   % graphics stuff

   prLegs = player_legs_a_rsc
   prRight_arm = player_rightarm_a_rsc
   prLeft_arm = player_leftarm_a_rsc

   prHead = $
   prEyes = $
   prMouth = $
   prNose = $
   prToupee = $

   % Animation type.  If none, then use piAction
   % piAnimation should be PANM_NONE in between KOD calls.
   piAnimation = PANM_NONE 

   % Action, such as "smiling", that player is currently doing
   piAction = 1

   piAdvancement_points = 0

   % piNodeList is a bitvector of all of the mana nodes that the player has
   %  successfully melded with.  List of available nodelists in the
   %  blakston.khd constants file.
   piNodeList = 0

   piBorn_year = 0

   % Faction stuff.
   piFactionEffect = 0
   piFaction = FACTION_NEUTRAL
   piFactionServiceUpdate = 0
   piFactionTimeUpdated = 0
   ptFactionTimer = $

   piKill_count = 0
   piKill_count_decay = 0
   piJustified_kill_count = 0

   ptAttackTimer = $

   psHonor = $

   piMonsterChasers = 0

   piView = $

   poBondedItem = $
   ptBondedItemReport = $

   piLastDeathTime = 0

   % This keeps the duration of our Second Wind skill's "downtime"
   ptSecondWind = $

   % Measures how long we have to wait before we're rescued.
   ptRescue = $

   % piTimeAttackedPlayer records the last time we attacked a player.
   %  This is used in conjunction with the constant ATTACKED_PLAYER_WAIT
   %  to disallow casting by angeled "mules".
   piTimeAttackedPlayer = 0 

   % piDeathcost is used to tell the underworld what percent of normal
   %  penalties to apply when the players leaves.  FALSE means no penalties.
   piDeathCost = 100

   % List of integer years in which the player has donated money to the game.
   % Used to construct a string for their description.
   plDonationYears = $

messages:

   Constructor()
   {
      % Let the poor bastards eat something.
      piTimeLastStomachUpdate = GetTime();
      
      propagate;
   }

   Delete()
   {
      local i;

      Send(self,@QuitGuild);
      for i in Send(SYS,@GetGuilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth = $;
      }
      
      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptPoison <> $
      {
         DeleteTimer(ptPoison);
         ptPoison = $;
      }
      
      if ptAdvancement <> $
      {
         DeleteTimer(ptAdvancement);
         ptAdvancement = $;
      }
      
      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
      }

      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      Send(self,@RemoveAllEnchantments,#report=FALSE);

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp = self);
      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      
      Send(Send(SYS,@GetAssassinGame),@RemoveFromGame,#who=self);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);
      plSchools = $;
      
      propagate;
   }

   %%% Player flags

   SetPlayerFlag(flag=0,value=FALSE,flagset=1)
   "This always requires the POSITIVE flag name."
   {
      local ccond;
      
      if flagset = 1 AND (flag & PFLAG_PKILL_ENABLE) AND value
      {
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
         {
            return;
         }
         else
         {
            ccond = player_safety_off_mail;
            if Send(self,@CheckPlayerFlag,#flag=PFLAG_SAFETY)
            {
               ccond = player_safety_on_mail;
            }

            if Send(SYS,@IsPKAllowed)
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                    #dest_list=[self],#nest_list=[4,player_ready_to_kill,4,ccond]);
            }
            else
            {
               Send(self,@ReceiveNestedMail,#from=player_angel,
                    #dest_list=[self],#nest_list=[4,player_ready_to_guild,4,ccond]);
            }
         }
      }

      if flagset = 1
      {
         if NOT Value
         {
            piFlags=piFlags & ~flag ;
         }
         else
         {
            piFlags=piFlags | flag ;
         }
      }
      
      if flagset=2
      {
         if NOT Value
         {
            piFlags2=piFlags2 & ~flag ;
         }
         else
         {
            piFlags2=piFlags2 | flag ;
         }
      }
      
      if (poOwner <> $)
         AND (flagset = 1)
         AND (flag & (PFLAG_MURDERER | PFLAG_OUTLAW | PFLAG_INVISIBLE))
      {
         % Tell room about change in case there are ramifications.
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   CheckPlayerFlag(flag=0,flagset=1)
   "This always checks to be sure that the flag exists."
   {
      if flagset = 1
      {
         if (flag = PFLAG_SAFETY) AND NOT Send(SYS,@IsPKAllowed)
         {
            return TRUE;
         }
         else
         {
            return (piFlags & flag);
         }
      }
      
      if flagset = 2
      {
         return (piFlags2 & flag);
      }

      if flagset = 3
      {
         return piFlags3;
      }
      
      return FALSE;
   }

   ResetPlayerFlagList()
   {
      local i;
	  
      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=FALSE);
      
      piFlags = (piFlags & PFLAG_MASK);
      piFlags2 = (piFlags2 & PFLAG2_MASK);
      if Send(self,@IsResting)
      {
         piFlags = piFlags | PFLAG_NO_MOVE;
         piFlags = piFlags | PFLAG_NO_FIGHT;
         piFlags = piFlags | PFLAG_NO_MAGIC;
      }
	  
      for i in plEnchantments
      {
         Send(Nth(i,2),@SetSpellPlayerFlag,#who=self);
      }

      for i in plUsing
      {
         Send(i,@SetItemPlayerFlag,#who=self);
      }
      
      if poOwner <> $
      {
         for i in Send(poOwner,@GetEnchantmentList)
         {
            Send(Nth(i,2),@SetSpellPlayerFlag,#who=self,#state=Nth(i,3));
         }
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
	  
      return;
   }
   
   
   GetGameSecurityFlag(flag = 0)
   {
      return 0;
   }

   GetLastRestartTime()
   {
      return piLast_restart_time;
   }

   SetLastRestartTime(time = 0)
   {
      piLast_restart_time = time;
      return piLast_restart_time;
   }

   %%% Vigor

   NewVigor()
   "Ensures vigor stays in bounds.  Also checks for second wind skill"
   "NOTE: Do not modify vigor below SECONDWIND_THRESHOLD if you do not want the skill to kick in."
   "Vigor display will be driven from here."
   {
      if piVigor < SECONDWIND_THRESHOLD
         AND ptSecondWind = $
         AND Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) > 0
         AND Send(Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND),@DoSkill,#who=self)
      {
         Send(self,@StartSecondWind);
      }
      
      piVigor = bound(piVigor,1,viMax_vigor);
      Send(self,@DrawVigor);

      return;
   }

   StartSecondWind()
   {
      local oWind, iTime;

      if Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) = 0
      {
         return FALSE;
      }

      oWind = Send(SYS,@FindSkillByNum,#num=SKID_SECOND_WIND);
      iTime = Send(oWind,@GetWaitTime,#who=self);
      ptSecondWind = CreateTimer(self,@EndSecondWindTimer,iTime);
      Send(self,@SetVigorRestThreshold,#amount=10);
      
      return TRUE;
   }

   EndSecondWindTimer()
   {
      ptSecondWind = $;
      Send(self,@EndSecondWind);
      
      return;
   }

   EndSecondWind()
   {
      local iAmount;

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
      }
      
      % This prevents repeated triggering of the second wind skill.
      if piVigor < SECONDWIND_THRESHOLD
      {
         piVigor = SECONDWIND_THRESHOLD;
      }

      iAmount = 80 + ((Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) + 1) / 5);
      Send(self,@SetVigorRestThreshold,#amount=iAmount);
      Send(self,@NewVigor);
      
      return;
   }

   GetVigorRestThreshold()
   {
      return piVigor_rest_threshold;
   }

   SetVigorRestThreshold(amount = 0)
   {
      piVigor_rest_threshold = amount;

      % Don't go above rest threshold if we're still waiting for Second Wind.
      if ptSecondWind <> $
      {
         piVigor_rest_threshold = 10;
      }
      
      piVigor_rest_threshold = Bound(piVigor_rest_threshold,10,100);

      Send(self,@DrawVigor);

      return;
   }

   AddExertion(amount = 0, SetToThreshold = FALSE)
   {
      local iExertionAdded, iPercentReduced, iVigorLost;
      
      % If we cannot gain vigor due to Second Wind, return out if trying
      %  to take away exertion
      if ptSecondWind <> $ AND amount < 0
      {
         return;
      }

      iExertionAdded = amount;

      if iExertionAdded > 0
      {
         % Parliament adjustment for exertion reduction.  Remove a % from the amount added.
         iPercentReduced = Send(Send(SYS,@GetParliament),@GetFactionVigorBonus,#who=self);
         iExertionAdded = (iExertionAdded * (100 - iPercentReduced))/100;
      }

      piExertion = piExertion + iExertionAdded;

      if abs(piExertion) > MIN_VIGOR_CHANGE OR SetToThreshold
      {
         if SetToThreshold AND piVigor < piVigor_rest_threshold
         {
            piVigor = piVigor_Rest_threshold;
            piExertion = 0;
         }
         else
         {
            iVigorLost = piExertion / 10000;
            piVigor = piVigor - iVigorLost;
            piExertion = piExertion - (iVigorLost * 10000);
         }

         Send(self,@NewVigor);
      }
      
      return;
   }

   RestAddExertion(amount = 0)
   "Gives inns a bonus as resting places."
   {        
      local iAmount;

      % If we cannot gain vigor (probably due to Second Wind), return out if trying to take away exertion
      if (ptSecondWind <> $) AND (amount < 0)
      {
         return;
      }

      if piVigor > piVigor_rest_threshold
      {
         return;
      }
      
      iAmount = Amount;
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY) AND amount < 0
      {
         iAmount = 2 * Amount;
      }
      
      if Send(poOwner,@CheckRoomFlag,#flag=ROOM_TRIPLE_HEAL) AND amount < 0
      {
         iAmount = 3 * Amount;
      }    
            
      piExertion = piExertion + iAmount;
      if abs(piExertion) > MIN_VIGOR_CHANGE
      {    
         piVigor = piVigor - piExertion / 10000;
         if piVigor > piVigor_rest_threshold
         {
            piVigor = piVigor_rest_threshold;
         }
         
         piExertion = 0;
         Send(self,@NewVigor);
      }
      
      return;
   }
      
   UpdateStomach()
   "Removes consumed food from stomach"
   {
      local now;

      now = GetTime();
      piStomach = piStomach - (now - piTimeLastStomachUpdate) * FOOD_USE_RATE / 100;
      piStomach = bound(piStomach,1,100);
      piTimeLastStomachUpdate = now;
      
      return;
   }

   HasVigor(amount = $)
   {
      if piVigor > amount
      {
         return TRUE;
      }

      return FALSE;
   }

   StartRescueTimer(time=5000)
   "Starts a timer which will rescue the player after time ms."
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      ptRescue = CreateTimer(self,@EndRescueTimer,time);

      return TRUE;
   }

   EndRescueTimer()
   {
      ptRescue = $;
      Send(self,@EndRescue);

      return;
   }

   EndRescue()
   "Deletes rescue timer if it exists and does the rescue operation."
   {
      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      
      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
      {
         Send(Send(SYS,@FindSpellByNum,#num=SID_RESCUE),@DoRescue,#who=self);
      }

      return;
   }

   CanRescue()
   {
      if ptRescue <> $
      {
         return FALSE;
      }

      return TRUE;
   }

   TryDeflect(what = $,caster=$)
   {
      local oDeflect;
      
      oDeflect = Send(SYS,@FindSpellByNum,#Num=SID_DEFLECT);
      if Send(self,@IsEnchanted,#what=oDeflect)
      {
         return Send(oDeflect,@TryDeflect,#caster=caster,#victim=self,
                     #oSpell=what);
      }
      
      return FALSE;
   }

   NewOwner(what = $)
   {
      Send(self,@ResetGainFlags);
      
      % Are we moving somewhere "safe" or in a frenzy??
      if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SANCTUARY)
         AND NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         AND NOT Send(SYS,@GetChaosNight)
      {
         % Don't set the "haven't moved" flag if we're in a safe area.
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

         % Don't create the revenant if we're in a safe location.
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_HAUNTED)
         {
            Create(&Revenant,#target=self,#location=poOwner,
                   #level=(((piBase_Max_health*150)/100)+(5*piKill_Count_decay)),
                   #diff=bound(piBase_Max_health/10,4,10),
                   #karmic=-piKarma/100);
         }
      }
      
      Send(self,@BreakTrance,#event=EVENT_NEWOWNER);
     
      if (piFlags2 & PFLAG2_HUNTED)
      {
         Send(self,@InformHunters);
      }

      % Player moved to a new location, give them a break on the botting imp cap.
      piAdvancement_points = bound((piAdvancement_points - 2),0,$);
      
      return;
   }

   InformHunters()
   {
      local i, j, oSpell, state, oSpellCloak, rLocation, lRoomlist, oRoom;

      oSpell = Send(SYS,@FindSpellByNum,#Num=SID_HUNT);
      oSpellCloak = Send(SYS,@FindSpellByNum,#Num=SID_CLOAK);
      rLocation = Send(poOwner,@GetName);

      if Send(self,@IsEnchanted,#what=oSpellCloak)
         AND (Random(1,100) < Send(self,@GetEnchantedState,#what=oSpellCloak))
      {
         % Will mislead hunters with random room if Cloak is on and passes state check.
         oRoom = Send(oSpellCloak,@GetWrongRoom);
         rLocation = Send(oRoom,@GetName);
      }
      
      for i in plEnchantments
      {
         if Nth(i,2) = oSpell
         {
            state = Nth(i,3);
            if not IsClass(first(state),&Prism)
            {
               for j in state
               {
                  Send(j,@MsgSendUser,#message_rsc=player_to_hunters,
                     #parm1=Send(self,@GetDef),
                     #parm2=Send(self,@GetTrueName),
                     #parm3=rLocation);
               }
            }
         }
      }
      
      return $;
   }

   ShowDesc()
   {
      local i,oEnchanter, rank, HitPoint_Percent;

      if Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         HitPoint_Percent = piHealth * 100 / piMax_Health;
         Send(poIllusion_set,@IllusionShowDesc,#who=self,
              #iHitPoint_Percent=HitPoint_Percent);

         return;
      }

      if psPlayerDescription <> $
      {
         AddPacket(4,player_desc_enchanted_none);
         AddPacket(0,psPlayerDescription);

         return;
      }
      
      propagate;
   }

   GetAge()
   {
      local age;

      age = Send(SYS,@GetYear) - Send(self,@GetBirthYear);

      % No more tutorial messages and bonuses if you've been around for about 2 months.
      % Clear the newbie string, too.
      % Do a bit flag check instead of a function call since this is called EVERY time
      %  someone gets looked at.
      if age >= 2
         AND NOT (piFlags & PFLAG_TUTORIAL)
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
         if StringEqual(psHonor,player_newbie_honor_string)
         {
            Send(self,@SetHonorString);
         }
      }      

      return age;
   }

   SetAge(age = 0)
   "Admin supported."
   {
      age = bound(age, 0, Send(SYS,@GetYear));
      piBorn_year = Send(SYS,@GetYear) - age;
      
      return age;
   }

   SetHonorString(string = $)
   "Admin supported."
   {
      if (string = GetTempString())
      {
         psHonor = CreateString();
         SetString(psHonor, string);
      }
      else
      {
         psHonor = string;
      }
      
      return psHonor;
   }

   GetHonorString()
   {
      return psHonor;
   }

   ShowExtraInfo()
   {
      local i, j, obj, year;

      ClearTempString();

      if NOT IsClass(self,&DM)
      {
         % (example) She has called Jasper home for eight years.

         AppendTempString(Send(self,@GetHeShe,#cap=TRUE));
         i = Send(self,@GetHomeRoom);
         j = player_citizen_unknown;

         if (i = RID_NEWB1)
         {
            j = player_citizen_raza;
         }
         
         if (i = RID_GUEST1)
         {
            j = player_citizen_hazar;
         }
         
         if (i = RID_BAR_INN)
         {
            j = player_citizen_barloque;
         }
         
         if (i = RID_COR_INN)
         {
            j = player_citizen_cornoth;
         }
         
         if (i = RID_MAR_INN)
         {
            j = player_citizen_marion;
         }
         
         if (i = RID_JAS_INN)
         {
            j = player_citizen_jasper;
         }
         
         if (i = RID_TOS_INN)
         {
            j = player_citizen_tos;
         }
         
         if (i = RID_KOC_INN)
         {
            j = player_citizen_kocatan;
         }
         
         AppendTempString(j);

         i = Send(self,@GetAge);
         if (i < 1)
         {
            AppendTempString(player_under_one_year);
         }
         else
         {
            AppendTempString(player_for);
            Send(SYS,@AppendCardinalToTempString,#number=i);
            if i = 1
            {
               AppendTempString(player_year);
            }
            else
            {
               AppendTempString(player_years);
            }
         }
         AppendTempString(player_nl);
      }
      else
      {
         % For DMs
         i = Send(self,@GetRankRsc);
         if i <> $
         {
            AppendTempString(i);
            AppendTempString(player_nl);
         }
      }

      if poGuild <> $ AND NOT Send(poGuild,@isSecret)
      {
         % (example) Squire of the BootLickers.
         i = Send(poGuild,@GetRank,#who=self);
         AppendTempString(Send(poGuild,@GetRankName,#rank=i,#sex=piGender));
         AppendTempString(player_of);
         AppendTempString(Send(poGuild,@GetDef));
         AppendTempString(Send(poGuild,@GetName));
         AppendTempString(player_dot);
         AppendTempString(player_nl);
      }

      i = Send(self,@GetFaction);
      if (i <> FACTION_NEUTRAL)
      {
         % (example) A staunch servant of Duke Akardius.
         if (i = FACTION_DUKE)
         {
            AppendTempString(player_faction_duke);
         }
         
         if (i = FACTION_PRINCESS)
         {
            AppendTempString(player_faction_princess);
         }
         
         if (i = FACTION_REBEL)
         {
            AppendTempString(player_faction_rebel);
         }
         
         AppendTempString(player_nl);
      }

      obj = Send(SYS,@GetCaramo);
      if obj <> $ and Send(obj,@GetJusticar) = self
      {
         AppendTempString(player_is_justicar);
         AppendTempString(player_nl);
      }

      j = Send(SYS,@GetVisibleCargoTypes);
      for i in j
      {
         % (example) He is holding a purple pickle princess figurine.

         obj = Send(self,@FindHolding,#class=i);
         if obj <> $
         {
            AppendTempString(Send(self,@GetHeShe,#cap=True));
            AppendTempString(player_is_holding);
            AppendTempString(Send(obj,@GetIndef));
            AppendTempString(Send(obj,@GetName));
            AppendTempString(player_dot);
            AppendTempString(player_nl);
         }
      }

%%% option turned off for review
%      if not Send(self,@PlayerIsImmortal) 
%      {
%         % (example) Known far and wide for mastery of Jala and Kraanan magics and weaponcraft skills.
%
%         j = FALSE;
%
%         % magic school masteries first
%         obj = Send(SYS,@FindSpellByNum,#num=SID_BONK); % any real spell will do
%         for i in [SS_JALA,SS_RIIJA,SS_QOR,SS_SHALILLE,SS_KRAANAN,SS_FAREN]
%         {
%            if Send(self,@CountKnownAtLevel,#school=i,#level=6) >= 1
%            {
%               if not j
%               {
%                  AppendTempString(player_known_for_mastery);
%                  j = TRUE;
%               }
%               else
%               {
%                  AppendTempString(player_and);
%               }
%               AppendTempString(Send(obj,@GetSchoolStr,#ischool=i));
%            }
%         }
%         
%         if j
%         {
%            AppendTempString(player_magics);
%         }
%
%         % weaponcraft
%         if Send(self,@CountKnownAtLevel,#school=SKS_FENCING,#level=5) >= 1
%         {
%            if not j
%            {
%               AppendTempString(player_known_for_mastery);
%               j = TRUE;
%            }
%            else
%            {
%               AppendTempString(player_and);
%            }
%            AppendTempString(player_skills);
%         }
%
%         AppendTempString(player_dot);
%         AppendTempString(player_nl);
%      }

      if psHonor <> $
      {
         if psHonor <> GetTempString()
         {
            AppendTempString(psHonor);
         }
         else
         {
            psHonor = $;
         }
      }

      if plDonationYears <> $
      {
         % Example: Benefactor of Meridian in 2010, 2011
	      AppendTempString(player_donation_title);
	      i = 0;
         for year in plDonationYears
         {
	         if i <> 0
 	         {
	            AppendTempString(player_donation_separator);
            }
	         AppendTempString(year);
	         i = i + 1;
         }
	      AppendTempString(player_dot);
      }

      AddPacket(0,GetTempString());

      return;
   }

   UserLogonHook()
   {
      local i, oGame, oCaramo, oSnoop, oRoom;
      
      for i in plPassive
      {
         Send(i,@UserLogon);
      }

      for i in plActive
      {
         Send(i,@UserLogon);
      }

      % Restart Health and Mana timers
      Send(self,@NewHealth);
      Send(self,@NewMana);
      
      Send(self,@SendUserAllWindowOverlays);

      if Send(SYS,@GetParliament)<>$
      {
         if piFaction <> FACTION_NEUTRAL 
            AND (not Send(Send(SYS,@GetParliament),@IsShutdown))
         {
            piFactionTimeUpdated=GetTime();
            Send(self,@FactionServiceTimer);
         }

         if Send(self,@PlayerIsIntriguing)
         {
            Send(Send(SYS,@GetParliament),@UpdateEffects,#who=self); 
         }
      }

      oGame = Send(SYS,@GetAssassinGame);
      if oGame <> $
         AND Send(oGame,@InAcceptMode)
         AND (NOT Send(oGame,@IsCombatant,#who=self))
         AND Send(oGame,@IsAdvertised,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=player_assgame_soon);
      }

      oCaramo = Send(SYS,@GetCaramo);
      if oCaramo <> $
      {
         Send(oCaramo,@UserLogon,#who=self);
      }

      if piPoisonStrength > 0
      {
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }

      % Send(self,@RefigureSchoolsLists,#informlore=TRUE);

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop <> $
         AND Send(oSnoop,@IsLoggedOn)
         AND Send(SYS,@IsSuspect,#who=self)
      {
         Send(oSnoop,@MsgSendUser,#message_rsc=player_eavesdrop_login_str,#parm1=vrName);
      }
      
      Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=FALSE);

      % If we log into the Raza/Hazar inn and aren't past the tutorial,
      %   then give us a commands list.
      if IsClass(poOwner,&Guest1)
         OR (IsClass(poOwner,&Newb1)
             AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_TUTORIAL))
      {
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Max mana could have changed while offline (e.g. mana node changes).
      % We used to do this when the mana nodes changed, but iterating
      % over all players became far too expensive.
      Send(self,@ComputeMaxMana);

      % Tell others that we're here
      oRoom = Send(self, @GetOwner);
      if oRoom <> $ AND NOT IsClass(self, &DM) 
      {
         Send(oRoom, @SomethingWaveRoom, #what=self, 
              #wave_rsc=player_logged_on_wav_rsc);
      }

      return;
   }

   UserLogoffHook()
   {
      local i, oSnoop, oRoom;
   
      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop <> $
         AND Send(oSnoop,@IsLoggedOn)
         AND Send(SYS,@IsSuspect,#who=self)
      {
         Send(oSnoop,@MsgSendUser,#message_rsc=player_eavesdrop_logout_str,#parm1=vrName);
      }

      for i in plPassive
      {
         Send(i,@UserLogoff);
      }

      for i in plActive
      {
         Send(i,@UserLogoff);
      }

      % client assumes not resting upon login
      Send(self,@StopResting); 

      if piFaction <> FACTION_NEUTRAL
      {
         Send(self,@factionServiceRoutine,#renew=FALSE);
      }

      % Stop health and mana timers.
      if ptHealth <> $
      {
         DeleteTimer(ptHealth);
         ptHealth=$;
      }
      
      if ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }

      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      % Tell others that we're leaving
      oRoom = Send(self, @GetOwner);
      if oRoom <> $ AND NOT IsClass(self, &DM) 
      {
         Send(oRoom, @SomethingWaveRoom, #what=self, 
              #wave_rsc=player_logged_off_wav_rsc);
      }
      
      return;
   }

   SendUserAllWindowOverlays()
   "Send the user any overlays that they might have.  Called when they logon "
   "or when garbage collected."
   {
      local i;

      for i in plWindow_overlays
      {
         Send(self,@SetWindowOverlay,#what=i);
      }

      return;
   }

   RestrictToResourceList(res = $, res_list = $)
   "If res is in res_list, return it.  Otherwise return the first element "
   "of res_list."
   {
      if FindListElem(res_list, res)
      {
         return res;
      }
      return Nth(res_list, 1);
   }

   PlayerNewCharInfo(desc = $,charinfo = $,gender = $)
   "This message is received when the user (re)started a character.\n"
   "<desc> contains a string with the description, charinfo is a list "
   "of values selected.  See system.kod, SendCharInfo(), for what these "
   "values mean."
   {
      local i,lFaceparts,lStats,lSpells,lSkills,iPoints,iLevel,iHair_translation,
            iSkin_translation, bQor, bShalille, oSpell, oSkill;
     
      bQor = FALSE;
      bShalille = FALSE;

      psPlayerDescription = desc;

      if Length(charinfo) <> 6
      {
         Debug("Bad charinfo message, length ",Length(charinfo));

         return;
      }

      % charinfo is a list of 4 elements:
      % list of face part resources
      % list of stats (might, intellect, etc.)
      % list of initial spells
      % list of initial skills

      lFaceparts = Nth(charinfo,1);
      if (Length(lFaceparts) <> 5)
      {
         % Hacking the protocol -> default char
         gender = GENDER_MALE;
         lFaceparts = [charinfo_head_ax_icon, charinfo_hair_ac_icon, charinfo_eyes_ax_icon, 
                       charinfo_nose_ax_icon, charinfo_mouth_ax_icon];
      }

      % Validate that all face parts were in the list of choices
      prHead = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,1), 
          #res_list = Send(SYS, @GetAllowedHeadIcons, #iGender = gender));

      prToupee = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,2), 
          #res_list = Send(SYS, @GetAllowedHairIcons, #iGender = gender));

      prEyes = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,3), 
          #res_list = Send(SYS, @GetAllowedEyeIcons, #iGender = gender));

      prNose = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,4), 
          #res_list = Send(SYS, @GetAllowedNoseIcons, #iGender = gender));

      prMouth = Send(self, @RestrictToResourceList, #res = Nth(lFaceparts,5), 
          #res_list = Send(SYS, @GetAllowedMouthIcons, #iGender = gender));

      iHair_translation = Nth(charinfo,2);
      iSkin_translation = Nth(charinfo,3);

      if iHair_translation <> 0
         AND iHair_translation <> PT_GRAY_TO_ORANGE
         AND iHair_translation <> PT_GRAY_TO_RED
         AND iHair_translation <> PT_GRAY_TO_SKIN1
         AND iHair_translation <> PT_GRAY_TO_SKIN2
         AND iHair_translation <> PT_GRAY_TO_SKIN3
         AND iHair_translation <> PT_GRAY_TO_SKIN4
         AND iHair_translation <> PT_GRAY_TO_SKIN5
         AND iHair_translation <> PT_GRAY_TO_PLATBLOND
         AND iHair_translation <> PT_GRAY_TO_KORANGE
         AND iHair_translation <> PT_GRAY_TO_KRED
         AND iHair_translation <> PT_GRAY_TO_KGRAY
         AND iHair_translation <> PT_GRAY_TO_BLACK
         AND iHair_translation <> PT_GRAY_TO_BLOND
         AND iHair_translation <> PT_GRAY_TO_LSKY
      {
         % if they hacked char.dll...
         iHair_translation = PT_GRAY_TO_BLOND;
      }
      
      Send(self,@SetHairTranslation,#translation=iHair_translation);

      if iSkin_translation <> PT_BLUE_TO_SKIN1
         AND iSkin_translation <> PT_BLUE_TO_SKIN2
         AND iSkin_translation <> PT_BLUE_TO_SKIN3
         AND iSkin_translation <> PT_BLUE_TO_SKIN4
      {
         % if they hacked char.dll...
         iSkin_translation = PT_BLUE_TO_SKIN3;
      }

      Send(self,@SetSkinTranslation,#translation=iSkin_translation);
      Send(self,@SetDefaultClothes,#rand=TRUE);
      Send(self,@ResetPlayerIcon);
      Send(self,@ResetPlayerArms);
      Send(self,@ResetPlayerLegs);

      lStats = Nth(charinfo,4);
      if (Length(lStats) <> 6)
      {
         % Hacking the protocol -> junk char for you
         lStats = [1, 1, 1, 1, 1, 1];
      }

      iPoints = Nth(lStats,1) + Nth(lStats,2) + Nth(lStats,3);
      iPoints = iPoints + Nth(lStats,4) + Nth(lStats,5) + Nth(lStats,6);

      if Nth(lStats,1) < 1 OR Nth(lStats,1) > 50
         OR Nth(lStats,2) < 1 OR Nth(lStats,2) > 50
         OR Nth(lStats,3) < 1 OR Nth(lStats,3) > 50
         OR Nth(lStats,4) < 1 OR Nth(lStats,4) > 50
         OR Nth(lStats,5) < 1 OR Nth(lStats,5) > 50
         OR Nth(lStats,6) < 1 OR Nth(lStats,6) > 50
         OR iPoints > 200
      {
         % they hacked their char.dll
         piMight = 3;
         piIntellect = 1;
         piStamina = 4;
         piAgility = 1;
         piMysticism = 5;
         piAim = 9;
      }
      else
      {
         piMight = Nth(lStats,1);
         piIntellect = Nth(lStats,2);
         piStamina = Nth(lStats,3);
         piAgility = Nth(lStats,4);
         piMysticism = Nth(lStats,5);
         piAim = Nth(lStats,6);
      }

      % set some other stats based on these

      piHealth = 20;
      Send(self,@NewHealth);
      piBase_Max_Health = 20;
      piMax_health = piBase_max_health;
      Send(self,@GainBaseMaxHealth);
      
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," restarted character: ",piMax_health,
               pibase_max_health);
      }

      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;
      
      % need to determine male/female
      if gender = GENDER_MALE
      {
         piGender = GENDER_MALE;
         vrIcon = player_male_icon_rsc; 
         prLegs = player_legs_a_rsc;
         prRight_arm = player_rightarm_a_rsc;
         prLeft_arm = player_leftarm_a_rsc;
      }
      else
      { 
         piGender = GENDER_FEMALE;
         vrIcon = player_female_icon_rsc; 
         prLegs = player_legs_b_rsc;
         prRight_arm = player_rightarm_b_rsc;
         prLeft_arm = player_leftarm_b_rsc;
      }

      Send(self,@ResetCharacter);

      % setup default stuff

      Send(self,@AddDefaultSpells);
      Send(self,@AddDefaultSkills);

      lSpells = Nth(charinfo,5);
      lSkills = Nth(charinfo,6);

      iPoints = 0;
      for i in lSpells
      {
         iLevel = Send(Send(SYS,@FindSpellByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }
      
      for i in lSkills
      {
         iLevel = Send(Send(SYS,@FindSkillByNum,#num=i),@GetLevel);

         if iLevel >= 2
         {
            iPoints = iPoints + 25;
         }
         else
         {
            iPoints = iPoints + 10;
         }
      }

      if iPoints > 45
      {
         % they hacked their char.dll
      }
      else
      {        
         if not IsClass(self,&Guest)
         {
            for i in lSpells
            {
               oSpell = Send(SYS, @FindSpellByNum, #num=i);
               % Not offered to new characters -> cheating, skip spell
               if (oSpell <> $ AND Send(oSpell, @OfferToNewCharacters)) 
               {
                  iLevel = Send(oSpell,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSpell,#num=i,#initial=TRUE);
                  }
                  if (Send(oSpell,@GetSchool) = SS_QOR)
                  {
                     bQor = TRUE;
                  }
                  if (Send(oSpell,@GetSchool) = SS_SHALILLE)
                  {
                     bShalille = TRUE;
                  }
               }
            }
            
            for i in lSkills
            {
               oSkill = Send(SYS,@FindSkillByNum,#num=i);
               if (oSkill <> $)
               {
                  iLevel = Send(oSkill,@GetLevel);
                  if (iLevel <= 2)
                  {
                     Send(self,@AddSkill,#num=i,#initial=TRUE);
                  }
               }
            }
         }
         
         Send(self,@RefigureSchoolsLists);
      }

      % Do this after we add spells so that we can give reagents if appropriate.
      Send(self,@AddDefaultObjects);

      % If the player chose either a Qor spell or a Shalille spell to start, 
      %  give him a favorable karma to start from.  However, if he chose both, 
      %  or if he chose neither, do nothing. 
      
      piKarma = 0;
      if bQor AND NOT bShalille
      {
         piKarma = -2000;
      }
      
      if bShalille AND NOT bQor
      {
         piKarma = 2000;
      }
      
      Send(self,@SetInitialHomeroom);
      Send(self,@TeleportToInitialLocation);

      piBorn_year = Send(SYS,@GetYear);

      % Send first mail the first time player plays.
      % Set their honor strong if this is a truly new character (max 1 reroll)
      if NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_TUTORIAL) 
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
              #dest_list=[self],#nest_list=[4,player_first_mail]);
         Send(self,@SetHonorString,#string=player_newbie_honor_string);
         Post(self,@MsgSendUser,#message_rsc=player_newbie_commands);
      }

      % Give them a new start on life, so that their newbie friends can buff and heal them.
      piTimeAttackedPlayer = 0;
      
      return;
   }

   GetBirthYear()
   {
      return piBorn_year;
   }

   ResetCharacter()
   "Setup default stuff"
   {
      local i;

      % first, kill all their items

      for i in plActive
      {
         Send(i,@Delete);
      }
      
      for i in plPassive
      {
         Send(i,@Delete);
      }

      Send(&SwordShard,@ForgetQuester,#quester=self);
      Send(&RiijaSword,@ForgetQuester,#quester=self);
      Send(self,@ClearBondedItem);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }

      plSpells = $;
      plSkills = $;

      if Send(self,@CheckLog)
      {
         Debug("LOG: ",vrName," restarted character, spells & skills are nil");
      }

      % setup some stats
      piBase_max_health = 20;
      piMax_health = piBase_max_health;
      piMax_mana = Send(self, @GetInitialMaxMana);
      piMana = piMax_mana;

      poKill_target = $;
      piKarma = 0;

      piVigor = 100;
      piVigor_rest_threshold = 80;
      piExertion = 0;
      % percent stomach is full
      piStomach = 0;
      piTimeLastStomachUpdate = 0;

      piAdvancement_points = 0;

      piKill_count = 0;
      piKill_count_decay = 0;
      piJustified_kill_count = 0;

      Send(self,@ZeroMods);

      Send(self,@PlayerIsIntriguing);

      Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=FALSE);

      Send(SYS,@SystemRemoveFromChampionLists,#oldchamp=self);

      % quit the guild, then be sure any guild commands are set to nil
      % important, keep this after the player flags part above.
      Send(self,@QuitGuild);
      piGuild_commands = 0;

      Send(Send(sys,@GetAssassinGame),@RemoveFromGame,#who=self);
      % Remove the guy from the Assassin's game.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      piLight = 5;

      % be sure they aren't declared a 'former member' by any existing guilds.
      for i in Send(SYS,@getguilds)
      {
         Send(i,@RemoveFromFormerMemberList,#who=self);
      }

      piNodelist = 0;

      Send(Send(SYS,@GetLibrary),@DeleteCompletedQuest,#who=self,#id=-1);
      Send(&QuestX,@CancelQuester,#quester=self);
      Send(self,@ClearQuestHistory);
      Send(Send(SYS,@GetLore),@PlayerSuicides,#who=self);
      
      if Send(SYS,@GetLastMurderer) = self
      {
         Send(SYS,@ClearLastMurderer);
      }

      return;
   }

   AddDefaultSpells()
   "Add the spells a player is given when creating a character"
   {
      Send(self,@AddSpell,#num=SID_BLINK,#initial=TRUE);
      
      return;
   }

   AddDefaultSkills()
   "Add the skills that all players have."
   {
      return;
   }

   AddDefaultObjects()
   "Add the objects a player is given when creating a character in newbie zone"
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      % Give the poor newbie an weapon and a bit of cash.
      Send(self,@NewHold,#what=Create(&Mace));
      Send(self,@NewHold,#what=Create(&Money,#number=500));

      % If player hasn't suicided in last 5 hours, give them cash and prizes!
      if (GetTime() - piLast_restart_time) > (5*60*60)   
      {
         Send(self,@NewHold,#what=Create(&Money,#number=2000));
         Send(self,@AddReagentsForSpells);
      }

      return;
   }

   StripInventory()
   {
      local lItems,oItem;

      % Delete the old stuff.
      for lItems in [plActive,plPassive]
      {
         for oItem in lItems
         {
            Send(oItem,@Delete);
         }
      }

      return;
   }

   AddRealWorldObjects()
   "Add the objects a player is given when character leaves the newbie zone"
   {
      local lItems,oItem,iSchool;

      % If player hasn't suicided in last 5 hours, give them cash and prizes!
      if (GetTime() - piLast_restart_time) > (5*60*60)   
      {
         Send(self,@NewHold,#what=Create(&Money,#number=1000));
         Send(self,@AddReagentsForSpells);
      }

      if Send(Send(SYS,@GetLore),@BetaPotionsEnabled) 
         AND Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
      {
         Send(self,@NewHold,#what=create(&MysticSword));
         Send(self,@NewHold,#what=create(&MysticSword));
         Send(self,@NewHold,#what=create(&InkyCap,#number=20));
         Send(self,@NewHold,#what=create(&SimpleHelm));
         Send(self,@NewHold,#what=create(&ScaleArmor));
         Send(self,@NewHold,#what=create(&Gauntlet));
         Send(self,@AddReagentsForSpells,#iNumCasts=20);
      }

      Send(self,@NewHold,#what=Create(&Mace));
      Send(self,@NewHold,#what=Create(&Apple,#number=5));

      return;
   }

   AddReagentsForSpells(iNumCasts=5)
   "Add reagents to the player for the spells they have.  Enough reagents for iNumCasts casts."
   {
      local iInfo, oSpell, lReagents, lItems, cReagent, iNumber;

      for iInfo in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=iInfo));
         lReagents = Send(oSpell,@GetReagents);

         for lItems in lReagents
         {
            cReagent = first(lItems);
            iNumber = Nth(lItems,2);

            Send(self,@NewHOld,#what=Create(cReagent,#number=(iNumber*iNumCasts)));
         }
      }

      return;
   }

   GetNumItemsInInventory()
   {
      return (length(plActive) + length(plPassive));
   }

   DropItem(droppedItem=$, targetGhost=$, dropRoom=$, dropRow=0, dropCol=0,
            index=$, merge=TRUE)
   {
      local oItem, oDropRoom, iDropRow, iDropCol, oItemAtt;
      
      if droppedItem <> $
      {
         oItem = droppedItem;
      }
      else
      {
         if index = $
         {
            return FALSE;
         }
         
         oItem = Send(self,@FindItemByIndex,#index=index);
      }

      if targetGhost = $
      {
         if dropRoom = $
         {
            oDropRoom = poOwner;
            iDropRow = piRow;
            iDropCol = piCol;
         }
         else
         {
            oDropRoom = dropRoom;
            iDropRow = dropRow;
            iDropCol = dropCol;
         }
      }
      else
      {
         % This is the result of a logoff ghost penalty.
         oDropRoom = Send(targetGhost,@GetOwner);
         iDropRow = Send(targetGhost,@GetRow);
         iDropCol = Send(targetGhost,@GetCol);
      }

      if Send(oItem,@ReqNewOwner,#what=oDropRoom)
         AND Send(oDropRoom,@ReqNewHold,#what=oItem,#new_row=iDropRow,#new_col=iDropCol)
      {
         if Send(oDropRoom,@ReqSomethingMoved,#what=oItem,#new_row=iDropRow,#new_col=iDropCol)
         {
            if Send(oItem,@DropOnDeath)
            {
               if targetGhost <> $
               {
                  % Put the PK pointer attribute on the item to prevent mules from
                  %  grabbing penalty drops from ghosts.
                  oItemAtt = Send(sys,@FindItemAttByNum,#num=IA_PKPOINTER);
                  Send(oItemAtt,@AddToItem,#oItem=oItem,#timer_duration=PKPOINTER_TIME,
                       #state1=self);
               }

               Send(oDropRoom,@NewHold,#what=oItem,#new_row=iDropRow,#new_col=iDropCol,#merge=merge);

               return TRUE;
            }
         }
      }
      
      return FALSE;
   }

   FindItemByIndex(index = $)
   {
      local lInv;
      if index = $
      {
         return;
      }

      if index <= length(plActive)
      {
         lInv = plActive;
      }
      else
      {
         lInv = plPassive;
         index = index - length(plActive);
      }

      return Nth(lInv,index);
   }

   GetGuild()
   {
      return poGuild;
   }

   GetGuildHall()
   "Return this player's guild hall, or NIL if none"
   {
      local oGuild;
      oGuild = Send(self, @GetGuild);
      
      if oGuild = $
      {
         return $;
      }
      return Send(oGuild, @GetGuildHall);
   }
      

   HasLeftAGuildTooRecently()
   {
      return (GetTime() < piGuildRejoinTimestamp);
   }
   
   SetGuildRejoinTime(delayMinutes=0)
   {
      piGuildRejoinTimestamp = GetTime() + (delayMinutes*60);

      return;
   }

   GetAnimation()
   {
      return piAnimation;
   }

   GetGender()
   {
      return piGender;
   }

   GetMaxHealth()
   {
      return piMax_health;
   }

   GetBaseMaxHealth()
   {
      return piBase_max_health;
   }

   GetLevel()
   {
      return Send(self,@GetBaseMaxHealth);
   }
   
   GetMaxMana()
   {
      return piMax_mana;
   }

   GetKillTarget()
   {
      return poKill_target;
   }

   GetTarget()
   {
      return poKill_target;
   }

   SetKillTarget(target=$)
   {
      poKill_target = target;
      
      return;
   }

   HealthTimer()
   {
      ptHealth = $;

      % Only gain health if we've moved since entry.
      if (piFlags & PFLAG_MOVED_SINCE_ENTRY) 
      {
         if piHealth < piMax_Health
         {
            Send(self,@GainHealth,#amount=1);
         }
         else
         {
            Send(self,@LoseHealth,#amount=1,#decay=TRUE);
         }
      }
      else
      {
         Send(self,@NewHealth);
      }         

      return;
   }

   ManaTimer()
   {
      ptMana = $;

      if piMana < piMax_mana
      {
         Send(self,@GainMana,#amount=1);
      }
      else
      {
         Send(self,@LoseMana,#amount=1);
      }

      return;
   }

   EnchantmentTimer(timer = $)
   {
      local i,oEnchanter;
 
      for i in plEnchantments
      {
         if First(i) = timer
         {
            if Length(i) >= 3
            {
               Send(Nth(i,2),@EndEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@EndEnchantment,#who=self);
            }

            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                 #type=ENCHANTMENT_PLAYER);

            % TODO: i no longer exists at this point?  EndEnchantment removing it?
            plEnchantments = DelListElem(plEnchantments,i);
            Send(self,@ResetPlayerFlagList,#who=self);
            if poOwner <> $
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   PeriodicEnchantmentTimer(timer = $)
   {
      local i ;
 
      for i in plEnchantments
      {
         if First(i) = timer
         {
            plEnchantments = DelListElem(plEnchantments,i);
            
            if Length(i) >= 3
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=Nth(i,3));
            }
            else
            {
               Send(Nth(i,2),@StartPeriodicEnchantment,#who=self,#state=$);
            }

            return;
         }
      }

      Debug("Enchantment timer went off with no enchantment",timer);

      return;
   }

   StartEnchantment(what = $,time = $,state = $,lastcall=TRUE,addicon=TRUE)
   "Adds <what> to our enchantments, and creates a timer that will cause it "
   "to end."
   {
      local oTimer, lNew_enchantment;

      if time = $ OR time = SPELL_INDEFINITE_DURATION 
      {
         oTimer = $;
      }
      else 
      {
         if lastcall
         {
            oTimer = CreateTimer(self,@EnchantmentTimer,time);
         }
         else
         {
            oTimer = CreateTimer(self,@PeriodicEnchantmentTimer,time);
         }
      }

      if state = $
      {
         lNew_enchantment = [oTimer, what];
      }
      else
      {
         lNew_enchantment = [oTimer, what, state];
      }

      plEnchantments = Cons(lNew_enchantment,plEnchantments);
      Send(self,@ResetPlayerFlagList,#who=self);
      if addicon
      {
         Send(self,@ShowAddEnchantment,#what=what,#type=ENCHANTMENT_PLAYER);
      }

      return;
   }

   GetEnchantmentList()
   {
      return plEnchantments;
   }

   GetEnchantmentsByClass(enchClass=&Spell)
   "returns a subset of plEnchantments whose elements are of the given class"
   {
      local i, returnList;
      returnList = $;

      for i in plEnchantments
      {
         if IsClass(Nth(i,2),enchClass)
         {
            returnList = cons(i,returnList);
         }
      }
      
      return returnList;
   }

   IsEnchanted(what = $, byClass = &Spell)
   "Returns whether or not currently enchanted by <what>."
   {
      local i;

      if what = $
      {
         for i in plEnchantments
         {
            if IsClass(Nth(i,2),byClass)
            {
               return TRUE;
            }
         }
      }
      else
      {
         for i in plEnchantments
         {
            if Nth(i,2) = what
            {
               return TRUE;
            }
         }      
      }
      
      return FALSE;
   }

   GetEnchantedState(what = $)
   "If enchanted by <what>, returns the state data (which MUST exist, or it's an error.  "
   "In other words, the caller must know that <what> adds state data).  Returns $ otherwise."
   {
      local i;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            return Nth(i,3);
         }
      }
      
      return $;
   }

   RemoveAllEnchantments(report=TRUE)
   "Remove all current enchantments."
   {
      local i;

      for i in plEnchantments
      {
         Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
      }
      
      return;
   }

   RemoveAllPersonalEnchantments(report=TRUE,override=FALSE)
   "Remove all current *personal* enchantments."
   {
      local i, oSpell, removedSomething;

      removedSomething = FALSE;

      for i in plEnchantments
      {
        oSpell = Nth(i,2);
        if Send(oSpell,@IsPersonalEnchantment)
           AND ((NOT IsClass(oSpell,&DMSpell)) OR override)
        {
           Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
           removedSomething = TRUE;
        }
      }
      
      % Just to be sure, reset the player's flag list.
      %  this should remove any excess flags like invis or shadowform.
      Send(self,@ResetPlayerFlagList);
      Send(self,@ResetPlayerDrawfx,#SendSomethingChanged=TRUE);
      
      return removedSomething;
   }

   FreezeAllEnchantments()
   "Called when a player logs off."
   {
      local i, iTime;

      for i in plEnchantments
      {
         if First(i) <> $
         {
            iTime = GetTimeRemaining(First(i));
            DeleteTimer(First(i));

            % If it's a negative enchantment, add a bit to the time in
            %  order to prevent people from just "flashing" on and off
            %  to wait out an enchantment and be relatively unhittable.
            if Send(Nth(i,2),@IsHarmful)
            {
               % Time is measured in milliseconds, 3000 = 3 seconds.
               iTime = iTime + 3000;
            }

            SetNth(i,1,iTime);
         }
      }

      return;
   }

   ReactivateAllEnchantments()
   "Called when a player logs on."
   {
      local i, tTimer, iTime, state;

      for i in plEnchantments
      {
         state = $;
         if length(i) > 2
         {
            state = Nth(i,3);
         }

         iTime = first(i);
         
         if iTime = $ OR iTime < 1
         {
            Debug("Trying to make a negative timer!",
                  Send(Nth(i,2),@GetTrueName));
         }

         if Send(Nth(i,2),@IsPeriodic,#state=state,#who=self)
         {
            SetNth(i,1,CreateTimer(self,@PeriodicEnchantmentTimer,iTime));
         }
         else
         {
            SetNth(i,1,CreateTimer(self,@EnchantmentTimer,iTime));
         }
          
         Send(Nth(i,2),@RestartEnchantmentEffect,#who=self,#state=state);
      }
      
      Send(self,@ResetPlayerFlagList,#who=self);
      
      return;
   }

   DispelIllusionEnchantments(report = TRUE, iChance = 100)
   {
      local i, oSpell, each_obj;

      for i in plEnchantments 
      {                       
         oSpell = Nth(i,2);
         if Send(oSpell,@IsIllusion)
            AND Random(1,100) <= iChance
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }
      
      % Kludgy, but oh well.  Not like any other code from this era is
      %  exactly well-engineered or even "good", really.
      for i in plActive
      {
         each_obj = Send(self,@HolderExtractObject,#data=i);
         if IsClass(each_obj,&NecromancerAmulet)
         {
            Send(each_obj,@DispelIllusions);
         }
      }
      
      return;
   }

   RemoveSchoolEnchantments(school = $,report=TRUE)
   {
      local i, oSpell, each_obj;

      for i in plEnchantments 
      {                       
         oSpell = Nth(i,2);
         if Send(oSpell,@GetSchool) = school
         {
            Send(self,@RemoveEnchantment,#what=Nth(i,2),#report=report);
         }
      }
      
      return;
   }

   RemoveEnchantment(what = $, report=TRUE)
   "If have a current enchantment set by <what>, end it."
   {
      local i,state;

      state = $ ;

      for i in plEnchantments
      {
         if Nth(i,2) = what
         {
            if Send(self,@IsLoggedOn)
            {
               % TODO: First(i) isn't always a timer?
               if First(i) <> $
               {
                  DeleteTimer(First(i));
                  SetNth(i,1,$);
               }
            }
            if Length(i) >= 3
            {
               state = Nth(i,3);
            }
       
            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#state=state,#report=report);
       
            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),#type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i); 
            Send(self,@ResetPlayerFlagList,#who=self);
         }
      }
      
      return;
   }

   RemoveEnchantmentClass(class = &Object)
   "If have a current enchantment set by anything in class, end it."
   {
      local i,state,removedSomething;
      
      removedSomething = FALSE;

      for i in plEnchantments
      {
         if IsClass(Nth(i,2),class)
         {
            removedSomething = TRUE;
            if First(i) <> $
            {
               DeleteTimer(First(i));
            }

            if Length(i) >= 3
            {
               state = Nth(i,3);
            }
       
            Send(Nth(i,2),@RemoveEnchantmentEffects,#who=self,#state=state);
       
            Send(self,@ShowRemoveEnchantment,#what=Nth(i,2),
                   #type=ENCHANTMENT_PLAYER);

            plEnchantments = DelListElem(plEnchantments,i); 
            Send(self,@ResetPlayerFlagList,#who=self);
         }
      }
      
      return removedSomething;
   }

   SendEnchantmentIcons()
   "Users do this after GC to redisplay their enchantments"
   {
      local i,each_obj;
      
      for i in plEnchantments
      {
         each_obj = Nth(i,2);
         if NOT (IsClass(each_obj,&Seance) OR IsClass(each_obj,&IllusionaryWounds))
         {
            Send(self,@ShowAddEnchantment,#what=each_obj,#type=ENCHANTMENT_PLAYER);
         }
      }
      
      return;
   }

   AddAttackModifier(what = $)
   "Adds <what> to plAttack_modifiers, which can modify attack strength and damage."
   {
      plAttack_modifiers = Cons(what,plAttack_modifiers);
      
      return;
   }

   RemoveAttackModifier(what = $)
   "Removes <what> from plAttack_modifiers."
   {
      local i;

      for i in plAttack_modifiers
      {
         if i = what
         {
            plAttack_modifiers = DelListElem(plAttack_modifiers,i);
            
            return;
         }
      }
      
      % Karahol's Curse can get here, because it has to remove itself when
      %  done, because it doesn't know if it was a normal ending or a
      %  user-quit ending.

      return;
   }

   AddDefenseModifier(what = $)
   "Adds <what> to plDefense_modifiers, which can modify defense strength "
   "and damage."
   {
      plDefense_modifiers = Cons(what,plDefense_modifiers);
      
      return;
   }

   RemoveDefenseModifier(what = $)
   "Removes <what> from plDefense_modifiers."
   {
      local i, bFound;

      bFound = FALSE ;
      for i in plDefense_modifiers
      {
         if i = what
         {
            plDefense_modifiers = DelListElem(plDefense_modifiers,i);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         Debug(self,"Tried to remove defense modifier",what,"but not in list",
               plDefense_modifiers);
      }

      return;
   }

   SquelchPlayer(value=$)
   "Sets if a player can broadcast or not.  Toggles condition by default."
   {
      local bSquelched;

      bSquelched = value;
      
      if bSquelched = $
      {
         % Toggle the current state.
         bSquelched = NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_SQUELCHED);
      }

      Send(self,@SetPlayerFlag,#flag=PFLAG_SQUELCHED,#value=bSquelched);

      return bSquelched;
   }

   TryBroadcast()
   "Called when the user wants to broadcast a string.  Return True/False, "
   "and use some mana too."
   {
      local iCost;
      
      if piFlags & PFLAG_SQUELCHED
      {
         Send(self,@MsgSendUser,#message_rsc=player_squelched);

         return FALSE;
      }

      if NOT Send(Send(SYS,@GetParliament),@BetaPotionsEnabled)
      {
         iCost = Bound(piMax_mana/2+1,11,$);
         if piMana < iCost
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_broadcast);

            return FALSE;
         }

         Send(self,@LoseMana,#amount=iCost);
      }
      
      return TRUE;
   }

   TrySayGroup(users = $)
   "Called when the user wants to say a string to a list of people.  Return True/False, "
   "and use some mana too."
   {
      if piMana < Length(users)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_send);
         return FALSE;
      }

      Send(self,@LoseMana,#amount=Length(users));

      return TRUE;
   }

   CheckPosition(what=$,type=$,space=0)
   {
      local i, iSpace;

      if space = 0 OR type = $ OR what = $
      {
         return FALSE;
      }
      
      iSpace = space;
      for i in plUsing
      {
         if Send(i,@GetItemUseType) & type
         {
            iSpace = iSpace - Send(i,@GetItemUseAmount);
         }
      }
      
      if iSpace < Send(what,@GetItemUseAmount)
      {
         if IsClass(what,&Token) OR IsClass(what,&Totem)
         {
            return FALSE;
         }

         % Soldier Shields allow bows or lutes to be wielded even if they
         %  are taking up all the hand spaces.  But, you can't use a shield, bow,
         %  lute, and book all simlutaneously!
         if (IsClass(what,&Bow) OR IsClass(what,&Lute))
            AND Send(self,@FindUsing,#class=&SoldierShield) <> $
            AND Send(self,@FindUsing,#class=&Lute) = $
            AND Send(self,@FindUsing,#class=&Book) = $
         {
            % Don't allow them to wield a lute if we already have a bow.
            % Trying to wield a second bow will unwield the first bow automatically.
            if NOT IsClass(what,&Lute)
               OR (Send(self,@FindUsing,#class=&Bow) = $)
            {
               return TRUE;
            }
         }

         if type = ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full_hands);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_full);
         }
         
         return FALSE;  
      }
      
      return TRUE;
   }

   TryUseItem(what = $)
   {
      local i,iSpace,iUse_type;

      if Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);
         
         return FALSE;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
              
         return FALSE;
      }

      iUse_type = Send(what,@GetItemUseType);

      if iUse_type & ITEM_SINGLE_USE
      {
         return Send(self,@TryApplyItem,#what=what,#apply_on=self);
      }

      if iUse_type & ITEM_BROKEN
      {
         Send(self,@MsgSendUser,#message_rsc=player_use_broken,#parm1=Send(what,@GetDef),
              #parm2=Send(what,@GetName));
              
         return FALSE;
      }
      
      if iUse_type & ITEM_CANT_USE
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_use);
         
         return FALSE;
      }
      
      if NOT Send(what,@ReqUse,#what=self)
      {
         return FALSE;
      }

      % make sure nothing in room disallows
      if poOwner <> $ AND NOT Send(poOwner,@ReqSomethingUse,#what=self,#use_item=what)
      {
         return FALSE;
      }

      % make sure not already using or something using disallows
      for i in plUsing
      {
         if i = what
         {
            Send(self,@MsgSendUser,#message_rsc=player_using_already);
            
            return FALSE;
         }
    
         if NOT Send(i,@ReqUseSomething,#what=what)
         {
            return FALSE;
         }
      }
      
      if (iUse_type & ITEM_USE_HAND)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_HAND,#space=viHand_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_BODY)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_BODY,#space=viBody_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_NECK)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_NECK,#space=viNeck_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_QUIVER)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_QUIVER,#space=viQuiver_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_FINGER)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_FINGER,#space=viFinger_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_GAUNTLET)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_GAUNTLET,#space=viGauntlet_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_HEAD)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_HEAD,#space=viHead_space)
      {
         return FALSE;
      }
      
      if (iUse_type & ITEM_USE_LEGS)
         AND NOT Send(self,@CheckPosition,#what=what,#type=ITEM_USE_LEGS,#space=viLeg_space)
      {
         return FALSE;
      }

      plUsing = Cons(what,plUsing);
      Send(self,@NewUsing,#what=what);
      Send(what,@NewUsed,#what=self);

      if poOwner
      {
         Send(poOwner,@SomethingUsed,#what=self,#use_item=what);
      }
      
      Send(self,@ResetPlayerFlagList);
      
      return TRUE;
   }

   TryUnuseItem(what = $)
   {
      local bFound, i;

      bFound = FALSE;

      %check and see if item disallows
      for i in plUsing
      {
         if i = what
         {
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         % This can happen if TryUnuseItem is called in, for example,
         %  a ring of invisibility when you log off.
         return FALSE;
      }
      
      if Send(what,@ReqUnuse)
      {
         Post(self,@ResetPlayerFlagList);

         return Send(self,@UnuseItem,#what=what);
      }
      
      return FALSE;
   }

   UnuseItem(what = $, Recalibrate = FALSE)
   {
      local i;
      
      for i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            Send(self,@NewUnusing,#what=what);
            
            if Recalibrate
            {
               Send(what,@NewUnused,#what=self,#Recalibrate=TRUE);
            }
            else
            {
               Send(what,@NewUnused,#what=self);
            }

            return TRUE;
         }
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_not_using);
      
      return FALSE;
   }

   TryApplyItem(what = $,apply_on = $)
   {
      local i,iUse_type;
      
      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=player_not_holding,#parm1=Send(what,@GetName));
         
         return FALSE;
      }

      iUse_type = Send(what,@GetItemUseType);
      if iUse_type <> ITEM_SINGLE_USE
      {
         if iUse_type = ITEM_BROKEN
         {
            Send(self,@MsgSendUser,#message_rsc=player_use_broken,
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_apply,
                 #parm1=Send(what,@GetIndef),#parm2=Send(what,@GetName));
         }
         
         % error
         return FALSE;
      }

      % make sure nothing in room disallows
      if NOT Send(poOwner,@ReqSomethingApply,#what=self,#use_item=what,#apply_on=apply_on)
      {
         return FALSE;
      }

      if Send(what,@ReqNewApply,#what=self,#apply_on=apply_on)
      {
         Send(what,@NewApplied,#what=self,#apply_on=apply_on);
         Send(poOwner,@SomethingApplied,#what=self,#use_item=what,#apply_on=apply_on);
      }
      
      Send(self,@ResetPlayerFlagList);
      
      return TRUE;
   }

   CanAdvance()
   {
      return TRUE;
   }

   AllowPlayerAttack(victim=$, stroke_obj=$, use_weapon=$, report=TRUE)
   "Will not let a person attack someone who isnt pkill_enabled."
   "Wll not let a person who isnt pkill_enabled attack another person."
   {
      local oRoom;
      
      % Default location to check is where we are.
      oRoom = poOwner;

      % If the victim is in a room, then check that location instead.  This allows
      %  distance attacks (like wall spells) to work properly.
      if victim <> $
         AND Send(victim,@GetOwner) <> poOwner
      {
         oRoom = Send(victim,@GetOwner);
      }

      % Make sure room allows the attack. Check if room has special combat affects.
      if NOT Send(oRoom,@ReqSomethingAttack,#what=self,#victim=victim,
                  #use_weapon=use_weapon,#stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      % If we're in an arena and it let us attack, then it's a legal attack.
      if Send(oRoom,@IsArena)
      {
         return TRUE;
      }

      % Frenzies!  Anything goes if allowed by the room!
      if Send(SYS,@GetChaosNight)
      {
         return TRUE;
      }

      % Can always attack mortal event characters.
      if IsClass(victim,&DM)
         AND Send(victim,@IsEventCharacter)
         AND NOT Send(victim,@PlayerIsImmortal)
      {
         return TRUE;
      }

      if IsClass(victim,&Monster)
      {
         if IsClass(victim,&Reflection)
         {
            if NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
            {
               Send(self,@MsgSendUser,#message_rsc=player_cant_hit_newbie);
         
               return FALSE;
            }
         }
            
         % No attacking pets on Sacred Haven
         if NOT Send(SYS,@IsPKAllowed)
            AND Send(victim,@GetMaster) <> $ 
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                    #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
            }
                
            return FALSE;
         }
      }
      else
      {
         % Not a monster; is a player.

         % No player attacks on Sacred Haven, but allow DM attacks for events.
         if NOT Send(SYS,@IsPKAllowed)
            AND NOT IsClass(victim,&DM)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safe_server);
            }
            
            return FALSE;
         }
         
         % This prevents attacks on immortal DMs.
         if NOT Send(victim,@IsLikelyVictim)
         {
            return FALSE;
         }
         
         if NOT Send(oRoom,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
         {
            if NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
            {
               % A newbie (someone below pkill_enable_hp) tried to attack
               % another player! note that this does not affect murderers
               % who have been knocked below this level by angry retributers.

               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_cant_hit_newbie);
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }
            
               return FALSE;
            }
                     
            if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
            {
               % The target is a newbie.  Murderers are perfectly attackable
               if report
               {
                  if Send(SYS,@IsPKAllowed)
                  {   
                     Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                          #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));        
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_safe_server);
                  }
               }

               return FALSE;
            }
         }
      }

      % Finally, check status and safety.
      if NOT Send(self,@CheckStatusAndSafety,#victim=victim,#report=report)
      {
         return FALSE;
      }

      % Stop any rescue attempts if the user makes an attack.
      if ptRescue <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_cancel_rescue);
         DeleteTimer(ptRescue);
         ptRescue = $;
      }

      return TRUE;
   }
   
   CheckStatusAndSafety(victim=$,report=TRUE)
   "PFLAG_SAFETY prevents accidental attacks. You can always successfully "
   "hit a murderer or outlaw, though."     
   {
      local oEnemyGuild, oSoldierShield;

      % Don't care about monsters.
      % And, free attacks on token holders.
      if IsClass(victim,&Monster)
         OR (Send(victim,@FindUsing,#class=&Token) <> $)
      {
         % Unless they're factioned.
         if NOT Send(self,@CheckFactionAttack,#what=victim)
         {
            return FALSE;
         }

         return TRUE;
      }

      % We don't penalize you for trying to hurt yourself.
      % Also don't care about Morphed or Anonymous players.
      if (victim = self)
         OR (IsClass(victim,&Player)
             AND (Send(victim,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
                  OR Send(victim,@CheckPlayerFlag,#flag=PFLAG_MORPHED)))
      {
         return TRUE;
      }

      oEnemyGuild = Send(victim,@GetGuild);
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      % Check for enemy guild or faction soldier fighting - If attacking a (mutual)
      %  enemy, then they can whack on each other freely, without outlaw penalty
      %  or faction loss.
      if (poGuild <> $
          AND oEnemyGuild <> $
          AND Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
         OR (oSoldierShield <> $
             AND Send(oSoldierShield,@IsEnemyAttack,#what=victim))
      {
         % Okay, attack is against a player, so record the time
         piTimeAttackedPlayer = GetTime();

         return TRUE;
      }

      % Check to see if we deserve to be an outlaw.
      if NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         AND NOT Send(victim,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
      {
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_SAFETY)
         {
            % If your opponent is not a murderer or outlaw, you must
            % have your 'safety' off to attack anyone.
            if report
            {
               if IsClass(self,&Guest)
               {
                  Send(self,@MsgSendUser,#message_rsc=player_guardian_angel,
                       #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
               else
               {
                  Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                       #parm1=Send(victim,@GetDef),#parm2=Send(victim,@GetName));
               }
            }
            
            return FALSE;
         }
         else
         {         
            if NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
               AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
            {
               % attacking someone who is without fault is cause to
               % gain the outlaw flag.
               Send(self,@MsgSendUser,#message_rsc=player_aggressor);
               Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=TRUE);
               Send(self,@EvaluatePKStatus,#dbug=TRUE);
            }
         }
      }

      % Check for faction loss.  Handles appropriate conditions.
      if NOT Send(self,@CheckFactionAttack,#what=victim)
      {
         return FALSE;
      }

      % Okay, attack is against a player, so record the time
      piTimeAttackedPlayer = GetTime();
      
      return TRUE;
   }

   CheckFactionAttack(what=$,report=TRUE)
   "Checks if you are attacking something in the same faction as you are.  Boots you out"
   "of your faction if you attack an innocent or a monster.  Safety will catch a bad "
   "attack, however."
   {
      local bBooted, rMessage;

      % If attacking nothing, or faction is neutral, or attacking self
      %   or in the Arena, or during a Frenzy, don't go any further.
      if what = $
         OR piFaction = FACTION_NEUTRAL
         OR what = self
         OR Send(poOwner,@IsArena)
         OR Send(SYS,@GetChaosNight)
      {
         return TRUE;
      }

      bBooted = FALSE;

      % If faction loss is disabled, then attacking a user never boots you
      if Send(SYS, @GetServerFlag, #flag = SERVER_FLAG_DISABLE_FACTION_LOSS)
         AND IsClass(what, &User) 
      {	 
         return TRUE;
      }     

      % Checking for faction alignment.  If you attack something of your own faction, you get busted!
      if (Send(what,@GetFaction) = piFaction)
      {
         % Attacks vs. Outlaws, Murderers are not punishable by booting, so just return.
         % Also, attacks vs. anonymous or morphed people are not punishable.
         if (IsClass(what,&User)) 
            AND (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
                 OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
                 OR Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
                 OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED))
         {
            return TRUE;
         }
         
         bBooted = TRUE;
         rMessage = player_faction_attacked;
      }

      % Preying on non-intriguing, white-named newbies boots ya, too.
      if IsClass(what,&User)
         AND NOT Send(what,@PlayerIsIntriguing)
         AND NOT (Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         OR Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW))
      {
         bBooted = TRUE;
         rMessage = player_non_intriguing_attacked;
      }

      if bBooted
      {
         % Check for safety before booting.
         if Send(self,@CheckPlayerFlag,#flag=PFLAG_SAFETY)
         {
            if report
            {
               Send(self,@MsgSendUser,#message_rsc=player_safety_caught,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }

            return FALSE;
         }

         % Get booted.
         Send(self,@MsgSendUser,#message_rsc=rMessage);
         Send(self,@ResignFaction);
      }
      
      return TRUE;
   }

   GetLastPlayerAttackTime()
   "Returns the last time the player attacked another player."
   {
      return piTimeAttackedPlayer;
   }

   CanHelpPlayer()
   "Checks to see if can be affected by spells cast by angeled characters."
   {
      if (piTimeAttackedPlayer + ATTACKED_PLAYER_WAIT) > GetTime()
         AND NOT Send(SYS,@GetChaosNight)
      {
         return FALSE;
      }

      return TRUE;
   }

   TryAttack(what = $,use_weapon = $,stroke_obj=$)
   {
      local iRange, oWinds, oSandstorm;

      % Can't target self.
      if what = self
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_target_self);
         
         return FALSE;
      }

      % Check attack time.
      % IsOkayAttackTime defaults to 1 second
      if NOT Send(self,@IsOkayAttackTime) 
      {
         return FALSE;
      }  

      % Is it in the same room?
      if poOwner <> Send(what,@GetOwner) 
      {
         return FALSE;
      }

      % Holding a token?  Then don't let them attack
      if send(self,@FindHolding,#class=&Token) <> $
      {
         return FALSE;
      }

      % Can pay costs?  Only check for skills, spells have already been cast.
      if IsClass(stroke_obj,&Skill)
         AND NOT Send(stroke_obj,@CanPayCosts,#who=self,#oTarget=what)
      {
         return FALSE;
      }

      % Send to the STROKE to get the range, so unarmed attacks have ranges, too
      iRange = Send(stroke_obj,@GetRange,#weapon_used=use_weapon);

      % A little fudge factor to account for lag drift, etc.
      %  Don't fudge for ranged weapons.
      if IsClass(what,&User) AND Send(what,@HasMovedRecently)
         AND (use_weapon <> $ AND NOT IsClass(use_weapon,&RangedWeapon))
      {
         iRange = iRange + RANGE_MOVEMENT_BONUS;
      }

      if NOT Send(self,@TargetWithinSightAndRange,#oTarget=what,#iRange=iRange,
                  #use_weapon=use_weapon,#stroke_obj=stroke_obj)
      {
         return FALSE;
      }

      % Special case assassin's daggers
      if use_weapon <> $
         AND IsClass(use_weapon,&BlackDagger)
         AND IsClass(stroke_obj,&Stroke)
      {
         % Let the assassin's game handle it
         return Send(Send(SYS,@GetAssassinGame),@TryAssassinAttack,#attacker=self,
                     #target=what,#dagger_obj=use_weapon);  
      }

      if IsClass(what,&Monster)
      {
         % check if its a non hittable monster
         if NOT Send(what,@CanMonsterFight,#who=self,#oStroke=stroke_obj,
                     #use_weapon=use_weapon)
         {
            return FALSE;
         }
         else
         {
            % Tell the monster this is a valid attack.
            Send(what,@ValidAttack,#who=self);
         }
      }

      % Checking for legal PK attack here.
      if NOT Send(self,@AllowPlayerAttack,#victim=what,#stroke_obj=stroke_obj,
                  #use_weapon=use_weapon)
      {
         return FALSE;
      }

      % Special stroke stuff 
      if NOT Send(stroke_obj,@CheckSpecial,#who=self,#victim=what)
      {
         return FALSE;
      }

      % Okay, checking is done, attack is okay.  Do the animation thing.
      if NOT Send(stroke_obj,@CheckWeaponAndDoAnimation,#who=self,
                  #weapon_used=use_weapon,#victim=what)
      {
         return FALSE;
      }

      % Switching targets?
      % Do this before paying skill costs, otherwise projectiles will try to find our 
      %  "kill target" and fail.
      if poKill_target <> what
      {
         Send(self,@ResetGainFlags);
         poKill_target = what;
      }

      % Pay costs here.  Only check skills, because spells are already cast.
      if IsClass(stroke_obj,&Skill)
      {
         Send(stroke_obj,@PayCosts,#who=self);
      }

      % Special case:  Ranged weapons in windy room.
      %  Do this after paying the costs so that the arrow is used.
      if use_weapon <> $ AND IsClass(use_weapon,&RangedWeapon)
      {
         oWinds = Send(SYS,@FindSpellByNum,#num=SID_WINDS);
         oSandstorm = Send(SYS,@FindSpellByNum,#num=SID_SANDSTORM);
         
         if Send(poOwner,@IsEnchanted,#what=oWinds)
            AND Send(oWinds,@WindsRuinShot,#who=self)
         {
            return FALSE;
         }

         if Send(poOwner,@IsEnchanted,#what=oSandstorm)
            AND Send(oSandstorm,@WindsRuinShot,#who=self)
         {
            return FALSE;
         }
      }

      Send(poOwner,@SomethingAttacked,#what=self,#victim=what,
           #use_weapon=use_weapon,#stroke_obj=stroke_obj);

      % Record the swing for potential advancement.
      %  Only recorded if the player can advance on the monster, and if they
      %  are within line of sight of the target.  (If they aren't in line of sight,
      %  then only advance 1 out of 5 swings.  Allow the random, since sometimes
      %  not being in line of sight is an accident.
      if Send(what,@CanPlayerAdvanceOnMe)
         AND (Send(poOwner,@LineOfSight,#obj1=self,#obj2=what) OR random(1,25) = 1)
      {
         % We got another swing in, so increment that.
         Send(self,@SwingWeapon,#times=1);
      }

      propagate;
   }

   % Determines if target is within attacking range, and within sight.
   %  iRange=$ means there's no range check.
   TargetWithinSightAndRange(oTarget=$,iRange=$,use_weapon=$,stroke_obj=$)
   {
      local iSquareRange, iDist, oTargetOwner, oFinalTarget, iAngle, iRow, iCol,
            iTargetRow, iTargetCol;

      oTargetOwner = Send(oTarget,@GetOwner);

      % We are always in range of ourselves or anything we carry.
      if oTarget = self
         OR oTargetOwner = self
      {
         return TRUE;
      }

      oFinalTarget = oTarget;

      % Strange case of us targetting something that someone else is holding.
      %  This cannot be owned by us, since we already checked that.
      if oTargetOwner <> $
         AND IsClass(oTargetOwner,&Battler)
      {
         oFinalTarget = oTargetOwner;
         oTargetOwner = Send(oFinalTarget,@GetOwner);
      }

      iDist = Send(self,@SquaredDistanceTo,#what=oFinalTarget);

      % If we don't share the same owner, then we're not in range.
      if poOwner <> oTargetOwner
      {
         return FALSE;
      }

      % See if target is within range, if we provided a range.
      if iRange <> $
      {
         iSquareRange = iRange;
         iSquareRange = iSquareRange * iSquareRange;

         if iDist > iSquareRange
         {
            Send(self,@SendAttackOutOfRangeMessage,#what=oFinalTarget,
                 #use_weapon=use_weapon,#stroke_obj=stroke_obj);
         
            return FALSE;
         }
      }

      % See if target is in a reasonable viewing area.
      %  Only applies to weapon strokes and single-target spells.
      if IsClass(oFinalTarget,&Battler)
         AND stroke_obj <> $
         AND (IsClass(stroke_obj,&Stroke)
              OR (IsClass(stroke_obj,&Spell) AND Send(stroke_obj,@GetNumSpellTargets) = 1))
      {
         iAngle = Send(self,@GetAngle);
         iRow = Send(self,@GetRow);
         iCol = Send(self,@GetCol);
         iTargetRow = Send(oTarget,@GetRow);
         iTargetCol = Send(oTarget,@GetCol);

         % What this does:
         % Basically, it finds your direction and makes sure you aren't trying to target
         %  something behind you.  "Behind you" is defined as behind the line defined
         %  by the cardinal directions that are the closest to being perpendicular to the
         %  player's direction vector.  For example, if you're facing mostly east, then
         %  the cardinal direction direction line runs north/south; in essense, anything
         %  that is further west than you is "behind" you.  The more interesting cases
         %  are when the player is facing one of the corner directions.  We calculate
         %  the equation of the line using the point-slope formula and determine which
         %  side of the line the target is.
         %    Equation of the SW-NE line: iTargetRow - iRow = iCol - iTargetRow
         %    Equation of the SE-NW line: iTargetRow - iRow = iTargetCol - iCol
         if iDist > 1
            AND (   ((iAngle > ANGLE_ENE OR iAngle <= ANGLE_ESE)
                    AND iTargetCol < iCol)
                 OR (iAngle > ANGLE_ESE AND iAngle <= ANGLE_SSE
                    AND (iTargetRow - iRow) < (iCol - iTargetCol))
                 OR (iAngle > ANGLE_SSE AND iAngle <= ANGLE_SSW
                    AND iTargetRow < iRow)
                 OR (iAngle > ANGLE_SSW AND iAngle <= ANGLE_WSW
                    AND (iTargetRow - iRow) < (iTargetCol - iCol))
                 OR (iAngle > ANGLE_WSW AND iAngle <= ANGLE_WNW
                    AND iTargetCol > iCol)
                 OR (iAngle > ANGLE_WNW AND iAngle <= ANGLE_NNW
                    AND (iTargetRow - iRow) > (iCol - iTargetCol))
                 OR (iAngle > ANGLE_NNW AND iAngle <= ANGLE_NNE
                    AND iTargetRow > iRow)
                 OR (iAngle > ANGLE_NNE AND iAngle <= ANGLE_ENE
                    AND (iTargetRow - iRow) > (iTargetCol - iCol))
                )
         {
            if iDist > 2
               AND IsClass(oFinalTarget,&Player)
               AND Send(self,@CheckLog)
            {
               Debug("ALERT! ",Send(self,@GetTrueName),self," at "
                     "[",iRow,iCol,"] and angle ",iAngle," tried to hit ",
                     Send(oFinalTarget,@GetTrueName),oFinalTarget," at "
                     "[",iTargetRow,iTargetCol,"] that was behind them.");
            }

            Send(self,@MsgSendUser,#message_rsc=player_attack_not_in_view);

            return FALSE;
         }
      }

      return TRUE;
   }

   % This returns the battler's ability to-hit.  Ranges from 1 to 1000
   GetOffense(what = $, stroke_obj=$)
   {
      local i, oWeapon, iStroke, iProficiency, iAim, iOffense, oMonster;

      oWeapon = $;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $) and Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         iOffense = Send(oMonster,@GetOffense,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         % A player's offense is based on his stroke (basic), proficiency (advanced) skills, aim and max hps.
         oWeapon = Send(self,@GetWeapon);

         if oWeapon <> $
         {
            % Get weapon's numbers.
            iStroke = Send(oWeapon,@GetStroke,#who=self);
            iProficiency = Send(oWeapon,@GetProf,#who=self);
         }
         else
         {
            % Unarmed
            iStroke = Send(self,@GetSkillAbility,#skill_num=SKID_PUNCH);
            iProficiency = Send(self,@GetSkillAbility,#skill_num=SKID_BRAWLING);
         }

         iAim = Send(self,@GetAim);
         iOffense = (iStroke*3) + (iProficiency*2) + (iAim*4) + (piBase_Max_Health*3/2);

         if oWeapon <> $
         {
            iOffense = Send(oWeapon,@ModifyHitRoll,#target=what,#hit_roll=iOffense);
         }
      }

      % List of items and spells that affect chance-to-hit
      for i in plAttack_modifiers
      {
         iOffense = Send(i,@ModifyHitRoll,#who=self,#what=what,
                         #hit_roll=iOffense,#stroke_obj=stroke_obj);
      }

      iOffense = iOffense + Send(Send(SYS,@GetParliament),
                                 @GetFactionHitrollBonus,#who=self);

      % If we're using a ranged weapon and don't have a clear line of sight,
      %  then half our offense.
      if what <> $
         AND oWeapon <> $
         AND IsClass(oWeapon,&RangedWeapon)
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
         AND NOT (IsClass(self,&DM) AND Send(self,@PlayerIsImmortal))
      {
         iOffense = iOffense / 2;
      }

      % The universal modifier.
      iOffense = iOffense + ((iOffense * piFlags3) / 100);

      return bound(iOffense,1,1000);
   }

   % This returns the battler's ability to avoid being hit.  Ranges from 1 to 1000.
   GetDefense(what = $, stroke_obj=$)
   {
      local i, oWeapon, oShield, iParry, iDodge, iBlock, iAgility, iDefense, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $) and Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         iDefense = Send(oMonster,@GetDefense,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         % A player's defense is based on his dodge, parry, block skills, agility, and max hps.
         iParry = 0;
         iDodge = 0;
         iBlock = 0;

         % Ask the weapon, it might give a bonus to parrying.
         iParry = Send(self,@GetParryAbility,#stroke_obj=stroke_obj);
         
         % Ask the shield, it might give a bonus to block.
         iBlock = Send(self,@GetBlockAbility,#stroke_obj=stroke_obj);
         
         iDodge = Send(self,@GetDodgeAbility,#stroke_obj=stroke_obj);

         iAgility = Send(self,@GetAgility);
         iDefense = (iParry*2) + (iBlock) + (iDodge*3) + (iAgility*4) + (piBase_Max_Health*3/2);
      }

      for i in plDefense_modifiers
      {
         iDefense = Send(i,@ModifyDefensePower,#who=self,#what=what,#defense_power=iDefense);
      }

      iDefense = iDefense + Send(Send(SYS,@GetParliament),@GetFactionDefenseBonus,#who=self);

      % The universal modifier.
      iDefense = iDefense + ((iDefense * piFlags3) / 100);

      return bound(iDefense,1,1000);
   }

   % The next three messages deal with the three defense skills.  These messages return the relative values of the three
   % skills.  Used in player for defense, used in battler for defense messages.
   GetParryAbility(stroke_obj=$)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         return Send(oMonster,@GetParryAbility,#stroke_obj=stroke_obj);
      }
      
      oWeapon = Send(self,@GetWeapon);
      if oWeapon = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_PARRY),@CanPayCosts,#who=self)
         OR (stroke_obj <> $ AND NOT Send(stroke_obj,@CanParry))
      {
         return 0;
      }
      
      return Send(oWeapon,@GetParryAbility,#who=self);
   }

   GetBlockAbility(stroke_obj=$)
   {
      local oShield, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         % Should only be one morph enchantment on the player.
         return Send(oMonster,@GetBlockAbility,#stroke_obj=stroke_obj);
      }

      oShield = Send(self,@LookupPlayerShield);
      if oShield = $
         OR NOT Send(Send(sys,@FindSkillByNum,#num=SKID_BLOCK),@CanPayCosts,#who=self)
         OR ((stroke_obj <> $) AND NOT Send(stroke_obj,@CanBlock))
      {
         return 0;
      }
      
      return Send(oShield,@GetBlockAbility,#who=self);
   }

   GetDodgeAbility(stroke_obj=$)
   {
      local oMonster;
      
      if stroke_obj <> $ AND NOT Send(stroke_obj,@CanDodge)
      {
         return 0;
      }

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
         AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_NO_MOVE)
      {
         return Send(oMonster,@GetDodgeAbility,#stroke_obj=stroke_obj);
      }

      if Send(Send(sys,@FindSkillByNum,#num=SKID_DODGE),@CanPayCosts,#who=self)
      {
         return Send(self,@GetSkillAbility,#skill_num=SKID_DODGE);
      }

      return 0;
   }

   % This returns the damage done to target "what" before resistances.
   GetDamage(what = $, stroke_obj=$)
   {
      local i, iDamage, oStroke, oWeapon, iStrokeNum, iModBonus, iDamageBonus,
            oSpell, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         iDamage = Send(oMonster,@GetDamage,#what=what,#stroke_obj=stroke_obj);
      }
      else
      {
         oStroke = stroke_obj;
         if stroke_obj = $
         {
            oWeapon = Send(self,@GetWeapon);
            if oWeapon = $
            {
               oStroke=Send(SYS,@FindSkillByNum,#num=SKID_PUNCH);
            }
            else
            {
               if IsClass(oWeapon,&Weapon)
               {
                  oStroke=Send(SYS,@FindSkillByNum,#num=Send(oWeapon,@GetDefaultStrokeNumber));
               }
               else
               {
                  % It's a spell, use it as the stroke object.
                  oStroke = oWeapon;
               }
            }
         }

         % Currently considers the damage of the weapon and player's might.
         % Stroke sets damage
         iDamage = Send(oStroke,@FindDamage,#weapon_used=Send(self,@GetWeapon),
                        #who=self,#victim=what); 
      }

      % Spells and attmods that modify damage
      iDamageBonus = 0;
      for i in plAttack_modifiers
      {
         % Attack modifiers return the total damage, subtract out the original
         %  damage to get the damage bonus.
         iModBonus = Send(i,@ModifyDamage,#who=self,#what=what,#damage=iDamage,
                          #stroke_obj=oStroke);
         iDamageBonus = iDamageBonus + (iModBonus - iDamage);

         Send(i,@WeaponHitTarget);
      }
               
      iDamageBonus = iDamageBonus + Send(Send(SYS,@GetParliament),
                                         @GetFactionDamageBonus,#who=self);

      iDamage = iDamage + iDamageBonus;

      % The universal modifier.
      iDamage = iDamage + ((iDamage * piFlags3) / 100);

      return iDamage;
   }

   % This is the type of damage done.
   GetDamageType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         return Send(oMonster,@GetDamageType,#what=what);
      } 

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }
      
      if oWeapon = $
      {
         % No weapon means we are punching
         return ATCK_WEAP_UNARMED+ATCK_WEAP_PUNCH;
      }

      return Send(oWeapon,@GetAttackType);
   }

   GetSpellType(what = $, use_weapon = $)
   {
      local oWeapon, oMonster;

      % Morphed?
      oMonster = Send(self,@GetIllusionForm);
      if oMonster <> $ AND Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
      {
         return Send(oMonster,@GetSpellType,#what=what);
      } 

      if use_weapon = $
      {
         oWeapon = Send(self,@GetWeapon);
      }
      else
      {
         oWeapon = use_weapon;
      }

      if oWeapon = $
      {
         % No weapon means we are punching, no magical damage
         return 0;
      }

      return Send(oWeapon,@GetAttackSpell);
   }   

   AssessHit(what = $, stroke_obj = $, damage = $)
   {
      local oMonster;
      
      if stroke_obj <> $
         AND Send(self,@GetWeaponSwingBonus) > 0
      {
         Send(stroke_obj,@ImproveStroke,#who=self,#target=what,
              #use_weapon=Send(self,@GetWeapon));
      }      

      % Morphed?  As a bonus, people in illusionary form get the hit side effect.  :)
      oMonster = Send(self,@GetIllusionForm);
      if (oMonster <> $)
      {
         Send(oMonster,@HitSideEffect,#what=what);
      }

      Send(self,@DoHitMessageSound,#what=what,#damage=damage,#stroke_obj=stroke_obj);
      
      propagate;
   }

   % Handles damage done to player
   AssessDamage(what = $,damage = $, atype = 0, aspell = 0, stroke_obj = $,bonus = 0,
              report = True, report_resistance = TRUE, absolute = FALSE)
   {
      local i, iResistance, oSoldierShield, gainchance, color_rsc, iDuration, oSpell,
            iLimit;

      color_rsc = player_hit_color_none;
      
      if what <> $ AND IsClass(what,&monster)
      {
         color_rsc = player_hit_color_blue;
      }

      if NOT absolute
      {
         for i in plDefense_modifiers
         {
            damage = Send(i,@ModifyDefenseDamage,#who=self,#what=what,#damage=damage,
                          #atype=atype,#aspell=aspell);
            Send(i,@DefendingHit,#who=self,#what=what);
         }
      
         iResistance = Send(self,@ResistanceCheck,#atype=atype,#aspell=aspell);                             
         damage = Send(self,@GetDamageFromResistance,#what=damage,#value=iResistance);

         % Add attmods AFTER resistance/suscep mods.    
         damage = damage + bonus;               
      }
      
      iDuration = 800;
      if damage <= 6
      {
         iDuration = 600;
      }
      
      if damage <= 3
      {
         iDuration = 400;
      }
      
      Send(self,@EffectSendUserDuration,#what=self,#effect=EFFECT_PAIN,#duration=iDuration);

      if NOT absolute and damage <= 0
      {
         damage = 1;
      }

      if damage > 0
      {
         if Send(self,@CheckPlayerFlag,#flag=PFLAG2_PARALYZED,#flagset=2)
         {
            Send(self,@RemoveEnchantment,#what=Send(SYS,@FindSpellByNum,#num=SID_PARALYZE));
         }
      }

      if NOT absolute
      {
         % If we have more health than twice our max, no percent limit on damage.
         if piHealth < (piBase_Max_Health * 2)
         {
            % Cap damage to 1/3 of max health (+2 so we "round up")
            iLimit = (piBase_Max_Health + (MAX_HEALTH_DAMAGE_FRACTION-1)) / MAX_HEALTH_DAMAGE_FRACTION;
            damage = bound(damage,$,iLimit);
         }

         % maximum of 30 damage per hit.
         damage = bound(damage,$,MAX_DAMAGE_PER_HIT);
      }

      % Faction enemies an extra 15% damage to each other, above caps.
      if what <> $ AND IsClass(what,&Player)
      {
         oSoldierShield = Send(what,@FindUsing,#class=&SoldierShield,#damage=TRUE);
         if oSoldierShield <> $
            AND Send(oSoldierShield,@IsEnemyAttack,#what=self,#damage=TRUE)
         {
            damage = (damage * 115)/100;
         }
      }

      Send(self,@LoseHealth,#amount=damage);

      if piHealth <= 0
      {
         if stroke_obj = $
            OR NOT Send(stroke_obj,@PlayerWasKilledMsg,#who=self,#attacker=what,#damage=$)
         {
            if report
            {
               Send(self,@MsgSendUser,
                    #message_rsc=Send(self,@PlayerWasHit,#atype=atype,#aspell=aspell),
                    #parm1=color_rsc,#parm2=Send(what,@GetCapDef),
                    #parm3=Send(what,@GetName));
            }
         }
         
         return $;
      }

      % flip flag for possible HP gain.
      if poKill_target = $
      {
         poKill_target = what;
      }
      
      if what = poKill_target AND damage > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE,#value=TRUE);
      }

      % Should we print resistance message?
      if report_resistance
      {
         if IsClass(what,&User)
         {
            Post(what,@MsgPlayerHitResisted,#what=what,#resistance=iresistance,#target=self);
         }
         
         Post(self,@MsgPlayerResistsHit,#what=what,#resistance=iResistance,#target=self,
              #color_rsc=color_rsc);
      }
      
      return damage;
   }

   % This function handles when is damage done to opponent.
   DidDamage(what = $, amount = 0)
   {
      local oWeapon, i;

      oWeapon = Send(self,@GetWeapon);
      
      if oWeapon <> $
      {
         Send(oWeapon,@WeaponHitTarget);
      }
      
      for i in plAttack_modifiers
      {
         Send(i,@WeaponHitTarget);
      }

      if Send(self,@GetSkillAbility,#Skill_num=SKID_DISARM) > 0
      {
         if oWeapon <> $ AND IsClass(oWeapon,&Spell)
         {
            oWeapon = $;
         }
         
         Send(Send(SYS,@FindSkillByNum,#num=SKID_DISARM),@DoSkill,#who=self,
              #oTarget=what,#oWeapon=oWeapon);
      }

      if amount > 0
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);
      }

      return;
   }

   % Returns weapon used.
   GetWeapon()
   {
      local oWeapon;
      
      oWeapon = Send(self,@LookupPlayerWeapon);
      % If there is no wielded melee weapon, then see if we have a touch attack active.
      if oWeapon = $
      {
         % This will return $ if there's no Touch Attacks enchanting player.
         oWeapon = Send(self,@GetEnchantmentsByClass,#EnchClass=&TouchAttackSpell);
         if oWeapon <> $
         {
            % The spell object is the second element of the list.  Get that.
            oWeapon = Nth(first(oWeapon),2);
         }
      }

      return oWeapon;
   }

   % The next three functions deal with weapon improvement.

   % This keeps track of the weapon swings.
   SwingWeapon(times=1)
   {
      local oWeapon, iProfNum;

      oWeapon = Send(self,@LookupPlayerWeapon);

      if oWeapon <> $
      {
         % Get weapon's numbers.
         iProfNum = Send(oWeapon,@GetProfNumber,#who=self);
      }
      else
      {
         % Unarmed or touch attacks.
         iProfNum = SKID_BRAWLING;
      }
      
      if iProfNum <> (piWeaponInfo mod 1000)
      {
         Send(self,@ResetWeaponSwings,#prof=iProfNum);
      }
      
      piWeaponSwings = piWeaponSwings + times;
      if (piWeaponSwings mod SWINGS_PER_IMPROVE_CHECK) = 0
      {
         % Increase this number.  Allows us to advance, and get bonuses for advancement.
         piWeaponInfo = piWeaponInfo + 1000;
      }
      
      return;
   }

   % This resets the weapon swings, for example, after an improvement or a
   %  weapon type change.
   ResetWeaponSwings(prof=$)
   {
      local iProf;

      if prof <> $
      {
         iProf = prof;
      }
      else
      {
         iProf = piWeaponInfo mod 1000;
      }
      
      piWeaponSwings = 0;
      piWeaponInfo = iProf;
      
      return;
   }

   GetWeaponSwingBonus()
   {
      % Separate out the number of groups of swings (the bonus) fromt he proficiency number.
      return piWeaponInfo/1000;
   }

   KilledSomething(what = $,use_weapon = $,stroke_obj = $)
   "Called when the player killed something."
   {
      local i, oSoldierShield, monstkarma, iChance, oEnemyGuild;

      % If we killed someone or something, we did damage.
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=TRUE);

      % Send text message - a stroke may want to provide it's own.
      if NOT Send(what,@SayDyingWords,#what=self)
      {
         if stroke_obj
         {
            if NOT Send(stroke_obj,@PlayerKilledSomethingMsg,#who=self,#victim=what)
               AND self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }
         }
         else
         {
            if self <> what
            {
               Send(self,@MsgSendUser,#message_rsc=player_killed_something,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
            }          
         }
      }
      
      Send(poOwner,@SomethingKilled,#what=self,#victim=what);

      % Let our shield know we killed something.
      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);
      if oSoldierShield <> $
      {
         Send(oSoldierShield,@KilledSomething,#what=what);
      }

      if IsClass(what,&User) AND NOT Send(poOwner,@SafePlayerAttack)
         AND what <> self
      {
         Send(Send(SYS, @GetStatistics), @PlayerKillsCounter);
         
         if Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
            OR Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         {
            piJustified_kill_count = piJustified_kill_count + 1;
         }
         else
         {
            piKill_count = piKill_count + 1;
            piKill_count_decay = piKill_count_decay + 1;              
         }
         
         Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
              #karma_killer=Send(self,@GetKarma),#karma_victim=Send(what,@GetKarma)));
         
         if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
            AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_ANONYMOUS)
            AND NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
         {
            %Attacked an innocent!

            % Check for enemy guild - If both guilds are enemies, then they can whack on each other
            %   freely, without murderer or faction penalty.
            oEnemyGuild = Send(what,@GetGuild);

            % Check for various murderer things if any are true:
            %  We're not in a guild, opponent wasn't in a guild, we're not in a mutual war
            %  AND if we're not a faction soldier, the opponent isn't an opposing faction soldier
            if (poGuild = $
                OR oEnemyGuild = $
                OR NOT Send(poGuild,@IsMutualEnemy,#otherguild=oEnemyGuild))
               AND (oSoldierShield = $
                    OR NOT Send(oSoldierShield,@IsEnemyAttack,#what=what,#damage=TRUE))
            {
               % SUBTLE BUG: Somehow, the faction check is missed when you kill something.
               %   We check it here, but only for players.  This means that if you score
               %   just the killing blow on a factioned monster, you won't get checked for
               %   faction loss.  It's a bug, but currently not that vital.
               
               % Check to see if the attack was faction-based.
               Send(self,@CheckFactionAttack,#what=what);

               % Apply penalties for someone NOT holding a token
               if Send(what,@FindUsing,#class=&Token) = $
               {
                  if Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_killed_player);
                  }
                  else
                  {
                     Send(self,@MsgSendUser,#message_rsc=player_wanted_now,
                          #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
                     Send(self,@SetPlayerFlag,#flag=PFLAG_MURDERER,#value=TRUE);
                     Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
                     Send(self,@EvaluatePKStatus,#dbug=TRUE);
                  }
   
                  % Does the lucky murderer win a Revenant?
                  % If it was an easy fight, lets haunt em more often than if
                  % it was competitive (or the victim at least had a shot)
                  % If were twice as strong as them, we get haunted.
                  % If the victim was good, we get haunted.
                  iChance = Send(self,@RevenantChance,#target=what);
                  if (random(1,100) < iChance) AND NOT Send(SYS,@GetChaosNight)
                  {       
                     Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=TRUE);
                     Send(self,@MsgSendUser,#message_rsc=player_haunted_on,
                          #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName,#Cap=TRUE));
                     Create(&Revenant,#target=self,#location=poOwner,
                            #level=(((piBase_Max_health*110)/100)+(7*piKill_Count_decay)),
                            #diff=bound(piBase_Max_health/12,4,9),#karmic=-piKarma/100);
                  }
               }
            }
         }
      }

      if IsClass(what,&Monster)
      {         
         Send(self,@AddKarma,#amount=Send(self,@CalculateKarmaChangeFromKill,
              #karma_victim=Send(what,@GetKarma),#karma_killer=Send(self,@GetKarma)),
              #bIsMob=TRUE);
      }

      Send(what,@Killed,#what=self,#stroke_obj=stroke_obj);

      return;
   }

   GetSomethingMissedYouSound(what = $,weapon_used = $)
   {
      local i,iRoll;

      if Send(self,@LookupPlayerWeapon)
      {
         iRoll = Random(1,3);
         
         if iRoll = 1
         {
            return player_sound_sword1;
         }
         
         if iRoll = 2
         {
            return player_sound_sword2;
         }
         
         if iRoll = 3
         {
            return player_sound_sword3;
         }
      }
      
      iRoll = Random(1,3);
      
      if iRoll = 1
      {
         return player_sound_metal1;
      }
      
      if iRoll = 2
      {
         return player_sound_metal2;
      }
      
      if iRoll = 3
      {
         return player_sound_metal3;
      }

      Debug("Can't get here");
      
      return $;
   }

   GetOuchSound()
   {
      local iHealthFraction;

      if piMax_health > 0
      {
         iHealthFraction = 100 * piHealth / piMax_health;
      }
      else
      {
         iHealthFraction = 0;
      }

      if piGender = GENDER_MALE
      {
         if iHealthFraction > 75
         {
            return player_sound_male_ouch1;
         }

         if iHealthFraction > 50
         {
            return player_sound_male_ouch2;
         }

         if iHealthFraction > 25
         {
            return player_sound_male_ouch3;
         }

         return player_sound_male_ouch4;
      }

      if iHealthFraction > 75
      {
         return player_sound_female_ouch1;
      }

      if iHealthFraction > 50
      {
         return player_sound_female_ouch2;
      }

      if iHealthFraction > 25
      {
         return player_sound_female_ouch3;
      }

      return player_sound_female_ouch4;
   }

   RevenantChance(who=$,target=$)
   {
      local oChance, oGuild, iFaction, oSpell;

      if IsClass(poOwner,&Guildhall)
      {
         return 0;
      }
      
      % PFLAG2_NOHAUNT is only settable by a guide or guardian.
      % The last two checks prevent outlaw/murderer players from creating revenants.
      if Send(Self,@CheckPlayerFlag,#flagset=2,#flag=PFLAG2_NOHAUNT)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         OR Send(target,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         return 0;
      }

      oChance = 10;
      oGuild = Send(target,@GetGuild);
      
      if poGuild <> $ AND oGuild <> $ 
      {
         if poGuild = oGuild
         {
            oChance = oChance + 20;
         }
         else
         {
            if Send(poGuild,@IsMutualEnemy,#otherguild=oGuild)
            {
               return 0;
            }
            
            if Send(poGuild,@IsAlly,#otherguild=oGuild)
            {
               oChance = oChance + 10;
            }
            
            if Send(oGuild,@IsAlly,#otherguild=poGuild)
            {
               oChance = oChance + 10;
            }
            
            if Send(poGuild,@IsEnemy,#otherguild=oGuild)
            {
               oChance = oChance - 10;
            }
            
            if Send(oGuild,@IsEnemy,#otherguild=poGuild)
            {
               oChance = oChance - 10;
            }
         }

      }

      iFaction = Send(target,@GetFaction);
      if piFaction <> FACTION_NEUTRAL AND iFaction <> FACTION_NEUTRAL
      {
         if piFaction <> iFaction
         {
            oChance = oChance - 5;
         }
         else
         {
            oChance = oChance + 15;
         }
      }

      % Punish them more if they beat up someone weaker than they are.
      oChance = oChance + ((10*piBase_Max_Health)/Send(target,@GetBaseMaxHealth));

      % People with greater absolute Karma have a greater chance to produce a revenant.  Being a good
      %  person, in general, decreases your chance.  Even if you are murderous scum.
      oChance = oChance + (abs(Send(target,@GetKarma)-piKarma/100))/20;

      % Punish them more if they walked away with more health.
      oChance = oChance + bound(20*piHealth/piBase_Max_health,0,20);

      % Bind the number to a reasonable amount, then add in the penalty for being a repeat killer.
      oChance = (bound(oChance,2,30) + (5*piKill_count_decay));

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_MARTYRS_BATTLEGROUND);
      if Send(poOwner,@IsEnchanted,#what=oSpell)
      {
         oChance = oChance + (oChance * Send(poOwner,@GetEnchantmentState,#what=oSpell) / 100);
      }
      
      return oChance;
   }

   DoHitMessageSound(what = $,damage = 0,stroke_obj = $)
   {
      local iRoll,rSound;

      if (stroke_obj = $)
      {
         return;
      }
      
      if IsClass(stroke_obj,&Spell)
      {
         rSound = Send(stroke_obj,@GetHitSound);
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
         if IsClass(what,&Player)
         {
            Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
         }

         return;
      }

      if IsClass(what,&Monster)
      {
         if damage <> $
         {
            if damage <= 3
            {
               iRoll = Random(1,3);
               
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_flesh1;
               }
               
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_flesh2;
               }
               
               if iRoll = 3
               {
                  rSound = player_sound_hit_monster_flesh3;
               }
               
               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
               
               return;
            }
         
            if damage <= 6
            {
               iRoll = Random(1,3);
               
               if iRoll = 1
               {
                  rSound = player_sound_hit_monster_leather1;
               }
               
               if iRoll = 2
               {
                  rSound = player_sound_hit_monster_leather2;
               }
               
               if iRoll = 3
               {
                  rSound = player_sound_hit_monster_leather3;
               }
               
               Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
               
               return;
            }
         }
         
         iRoll = Random(1,3);
         
         if iRoll = 1
         {
            rSound = player_sound_hit_monster_metal1;
         }
         
         if iRoll = 2
         {
            rSound = player_sound_hit_monster_metal2;
         }
         
         if iRoll = 3
         {
            rSound = player_sound_hit_monster_metal3;
         }
         
         Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound); 
         
         return;
      }

      if damage <> $
      {
         if damage <= 3
         {
            iRoll = Random(1,3);
            
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_flesh1;
            }
            
            if iRoll = 2
            {
               rSound = player_sound_hit_monster_flesh2;
            }
            
            if iRoll = 3
            {
               rSound = player_sound_hit_monster_flesh3;
            }
            
            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
            
            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
            }
            
            return;
         }

         if damage <= 6
         {
            iRoll = Random(1,3);
            
            if iRoll = 1
            {
               rSound = player_sound_hit_monster_leather1;
            }
            
            if iRoll = 2
            {
               rSound = player_sound_hit_monster_leather2;
            }
            
            if iRoll = 3
            {
               rSound = player_sound_hit_monster_leather3;
            }
            
            Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
            
            if IsClass(what,&Player)
            {
               Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
            }
            
            return;
         }
      }

      iRoll = Random(1,3);
      
      if iRoll = 1
      {
         rSound = player_sound_hit_monster_metal1;
      }
      
      if iRoll = 2
      {
         rSound = player_sound_hit_monster_metal2;
      }
      
      if iRoll = 3
      {
         rSound = player_sound_hit_monster_metal3;
      }
      
      Send(poOwner,@SomethingWaveRoom,#what=self,#wave_rsc=rSound);
      
      if IsClass(what,&Player)
      {
         Send(poOwner,@SomethingWaveRoom,#what=what,#wave_rsc=Send(what,@GetOuchSound));
      }

      return;
   }

   IsOkayAttackTime(time = 1000, seconds = $)
   "Have we waited long enough since the last attack/spell?  Sets new valid attack time."
   "(time in msec, default 1 second)"
   {
      local i;

      if ptAttackTimer <> $
      {
         return FALSE;
      }

      if seconds <> $
      {
         i = seconds*1000;
      }
      else
      {
         i = time;
      }

      if i > 0
      {
         ptAttackTimer = CreateTimer(self,@AttackTimer,i);
      }
      
      return TRUE;
   }

   AttackTimer()
   "Sets the attack timer variable to NIL so we know it's okay to attack again."
   {
      ptAttackTimer = $;

      return;
   }

   SendAttackOutOfRangeMessage(what = $, use_weapon = $, stroke_obj = $)
   {
      if use_weapon <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_range,
              #parm1=Send(what,@GetCapDef),#parm2=Send(what,@GetName),
              #parm3=Send(use_weapon,@GetIndef),#parm4=Send(use_weapon,@GetName));
      }
      else
      {
         if IsClass(stroke_obj,&spell)
         {
            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_SPELL_range,
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                 #parm3=Send(stroke_obj,@GetName));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_attack_out_of_PUNCH_range,
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
                 #parm3=Send(stroke_obj,@GetName));
         }
      }
      
      return;
   }

   GetMoneyObject()
   {
      local i;

      for i in plPassive
      {
         if IsClass(i,&Money)
         {
            return i;
         }
      }
      
      return $;
   }

   % Returns wielded Melee/Ranged weapon.
   LookupPlayerWeapon()
   {
      local i;

      for i in plUsing
      {
         if IsClass(i,&Weapon)
         {
            return i;
         }      
      } 

      return $;
   }
   
   LookupPlayerShield()
   {
      local i;

      for i in plUsing
      {
         if IsClass(i,&Shield)
         {
            return i;
         }      
      } 

      return $;
   }
   
   LeaveHold(what = $)
   {
      local i;

      % in case it's on the list of window overlays 
      Send(self,@RemoveWindowOverlayObject,#what=what);

      % in case it set our icon
      if poIcon_set = what
      {
         Send(self,@ResetPlayerIcon);
      }

      % in case it removed our hair
      if poHair_remove = what
      {
         Send(self,@ResetHair);
      }

      % in case it set our legs
      if poLegs_set = what
      {
         Send(self,@ResetPlayerLegs);
      }
      
      if poArms_set = what
      {
         Send(self,@ResetPlayerArms);
      }

      for i in plUsing
      {
         if i = what
         {
            plUsing = DelListElem(plUsing,i);
            % implied by drop: Send(self,@NewUnusing,#what=what)
            Send(what,@NewUnused,#what=self);
            
            break;
         }
      }
      
      propagate;
   }

   GetPlayerUsing()
   {
      return plUsing;
   }

   IsUsingA(class=$)
   {
      local i;
      
      if class = $
      {
         return FALSE;
      }
      
      for i in plUsing
      {
         if IsClass(i,class)
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   FindUsing(class=$)
   "Find the first instance of 'class' that player has equipped.  Returns $ if nothing is found."
   {
      local i;
      
      if class = $
      {
         return $;
      }
      
      for i in plUsing
      {
         if IsClass(i,class)
         {
            return i;
         }
      }
      
      return $;
   }

   ChooseArmorPosition()
   "Defense now chooses a body place at random, and checks to see if the "
   "defender has any defense value there.  Much better than rendom pattern "
   "of previous combat."
   {
      local rand, armor_pos;

      rand = random(1,12);
      armor_pos = 0;

      if rand < 6
      {
         return ITEM_USE_BODY;
      }
           
      if rand < 8
      {
         return ITEM_USE_LEGS;
      }
           
      if rand < 9
      {
         return ITEM_USE_HEAD;
      }
                   
      if rand < 10
      {
         return ITEM_USE_GAUNTLET;
      }

      % Default position: shield
      return -1;
   }

   GetDefenseModifier()
   "Returns a number from 0-100."
   {
      local armor_mod, armor_pos, i, shirt;

      armor_mod = 0;
      armor_pos = Send(self,@ChooseArmorPosition);
      
      if armor_pos = -1
      {
         for i in plUsing
         {
            if IsClass(i,&Shield)
            {
               return i;
            }
         }
         
         return $;
      }
      else
      {
         if armor_pos & ITEM_USE_BODY
         {
            shirt = $;
            for i in plUsing
            {
               if Send(i,@GetItemUseType) & armor_pos
               {
                  return i;
               }
               if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
               {
                  shirt = i;
               }
            }

            return shirt;
         }
         else
         {
            for i in plUsing
            {
               if Send(i,@GetItemUseType) = armor_pos
               {
                  return i;
               }
            }
         }
         
         return $;
      }
      
      return $;
   }

   CalculateHealthTime()
   "Calculate # of milliseconds until user will gain a health point"
   {
      local iTime, iMaxHealth, lJalaInfo, oJalaSpell, iJalaPower;
      
      % Faster regen with higher vigor
      iTime = ((200-piVigor)*(200-piVigor))/6 + 1000;
      
      iTime = ((125-Send(self,@GetStamina)) * iTime)/100;
      iMaxHealth = bound(piMax_health,40,100);
      iTime = (iTime *100)/iMaxHealth;

      iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                           #who=self,#hpregen=TRUE);
      
      if poOwner <> $
      {
         lJalaInfo = Send(poOwner,@GetJalaInfo);

         if lJalaInfo <> $
         {
            oJalaSpell = Nth(lJalaInfo,2);
            if IsClass(oJalaSpell,&Restorate)
            {
               iJalaPower = Nth(Nth(lJalaInfo,3),3);
               iTime = Send(oJalaSpell,@AdjustHealthTime,#time=iTime,
                            #iSpellPower=iJalaPower);
            }
         }
      }

      return bound(iTime,1000,60000);
   }

   CalculateManaTime()
   "Calculate # of milliseconds until user will gain a mana point"
   {
      local iTime, lJalaInfo, oJalaSpell, iJalaPower;

      if piMana > piMax_mana
      {
         iTime = BOOST_DECAY_TIME;
      }
      else
      {
         iTime = BASE_REGEN_TIME + (25-Send(self,@GetMysticism))*1000;
         iTime = iTime * 200 / bound(piVigor,1,$);
         iTime = iTime/ bound(piMax_Mana,1,$);
      
         iTime = iTime - Send(Send(SYS,@GetParliament),@GetFactionRegenBonus,
                              #who=self,#hpregen=FALSE);

         iTime = bound(iTime,1000,60000);

         if poOwner <> $
         {
            lJalaInfo = Send(poOwner,@GetJalaInfo);

            if lJalaInfo <> $
            {
               oJalaSpell = Nth(lJalaInfo,2);
               if IsClass(oJalaSpell,&Rejuvenate)
               {
                  iJalaPower = Nth(Nth(lJalaInfo,3),3);
                  iTime = Send(oJalaSpell,@AdjustManaTime,#time=iTime,
                               #iSpellPower=iJalaPower);
               }
            }
         
            iTime = bound(iTime,500,60000);
         }
      }

      return iTime;
   }

   ReqEatSomething(filling = 0, what = $)
   {
      % This is the only place we need piStomach to be correct
      Send(self,@UpdateStomach);

      if (piStomach + filling) > 100
      {
         if what = $ OR NOT Send(what,@IsBeverage)
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=player_too_full_drink);
         }
         
         return FALSE;
      }
      
      return TRUE;
   }

   EatSomething(nutrition = 0, filling = 0)
   {
      Send(self,@AddExertion,#amount=-10000*nutrition);
      piStomach = piStomach + filling;
      
      return;
   }

   LoseHealth(amount = $, decay = FALSE)
   "decay = TRUE if you lose a HP over time because you are boosted over max "
   "by some sort of vamp effect.  If this is true, you shouldn't break a trance."
   {
      if piFlags & PFLAG_TRANCE AND NOT decay
      {
         Send(self,@BreakTrance,#event=EVENT_DAMAGE);
      }

      piHealth = piHealth - amount;
      
      Send(self,@NewHealth);
      
      return;
   }

   GainHealth(amount = $)
   "Some attempt here to quell the vamp touch bugs"
   {
      if (2*piMax_health) < (piHealth+amount)
      {
         Send(self,@MsgSendUser,#message_rsc=player_health_gain_maxed);
         piHealth = 2 * piMax_health;
      }
      else
      {
         piHealth = piHealth + amount;
      }

      Send(self,@NewHealth);
      
      return;
   }

   GainHealthNormal(amount = $)
   "Don't add beyond piMax_health"
   {
      local oldhealth;

      oldhealth = piHealth;
      
      if amount < 0
      {
         return;
      }
      
      if piHealth > piMax_health
      {
         return 0;
      }

      pihealth = piHealth + amount;
      if piHealth > piMax_health
      {
         piHealth = piMax_health;
      }

      Send(self,@NewHealth);
      
      return (piHealth - OldHealth);
    }
  
   NewHealth()
   {
      if piHealth < 0
      {
         piHealth = 0;
      }

      % Keep health from going above natural max if affected by Mark of Dishonor.
      if piHealth > piBase_Max_health
         AND Send(self,@IsEnchanted,#byClass=&MarkOfDishonor)
      {
         piHealth = piBase_Max_health;
      }

      if ptHealth = $
      {
         if piHealth <> piMax_health
            AND piHealth > 0
         {
            ptHealth = CreateTimer(self,@HealthTimer,Send(self,@CalculateHealthTime));
         }
      }
      else
      {
         if piHealth = piMax_health
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }
      }
      
      Send(self,@DrawHealth);
      
      return;
   }
   
   GainLight(amount = $)
   "Adds <amount> to player source light."
   {      
      if (amount = $)
      {
         return 0;
      }
      
      piLight = piLight + amount;

      Send(self,@NewLight);
      
      return amount;
   }

   LoseLight(amount = $)
   "Subtracts <amount> to player source light."
   {
      if (amount = $)
      {
         return 0;
      }
      
      piLight = piLight - amount;
      
      Send(self,@NewLight);
      
      return amount;
   }

   NewLight()
   "Call this everytime player light is changed."
   {      
      Send(self,@SourceLightChanged);
      
      return;
   }

   GainBaseMaxHealth(amount = 0)
   {
      local iPrev_max;

      iPrev_max = piBase_max_health;

      piBase_max_health = bound(piBase_max_health + amount, 20, (100 + Send(self,@GetStamina)));
      % Bound ourselves at the top end to 150.
      piBase_max_health = bound(piBase_max_health,$,150);
      amount = piBase_max_health - iPrev_max;

      % Give them the "further info" gmail if they've advanced to 25.
      if piBase_Max_health = 25
         AND amount > 0
         AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_TUTORIAL)
      {
         Send(self,@ReceiveNestedMail,#from=player_angel,
              #dest_list=[self],#nest_list=[4,player_tutorial_mail]);           
      }
      
      Send(self,@PlayerIsIntriguing);
      Send(self,@GainMaxhealth,#amount=amount);
      
      return;
   }

   GainMaxHealth(amount = 0)
   "Call this any time you modify piMax_health, to set stuff on the user's display, "
   "and make sure the value doesn't get too high.  Returns actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_health;
      piMax_health = bound(piMax_health + amount, 20, $);

      %  no longer reset health to max - will need to test for abusability
      %     the motivation for this originated in using a circlet with health > max_health,
      %     which would erase hp boons or vamptouch gains - kinda mean.
      %     thought about preserving (health - max_health):
      %           OOOOOOOOOOOOOOOOOOOOoooooo       (o is health above max)
      %     -->   OOOOOOOOOOOOOOOOoooooo
      %     but in parallel with this scheme, we should also do:
      %           OOOOOOOOOOOOOO......             (. is space to max)
      %     -->   OOOOOOOOOO......
      %     which could result in death!
      %     the behavior could be made assymetrical,
      %           OOOOOOOOOOOOOO......
      %     -->   OOOOOOOOOOOOOO..
      %     but what about this case?
      %           OOOOOOOOOOOOOOOOO...    or    OOOOOOOOOOOOOOOOO...
      %     -->   OOOOOOOOOOOOOOOOo             OOOOOOOOOOOOOOOO
      %     the left is obviously abusable - compound it with the first gain above,
      %     and by putting on and removing a circlet we gain health!
      %     the right might be ok, and is closest to the current scheme,
      %     but this introduces even more assymmetry and thus makes me nervous.
      %     so my first pass is to do nothing to health here:
      %
      %if piHealth > piMax_health { piHealth = piMax_health; }
      %
      %     if this becomes undesirable, use this new code:
      %if piHealth > iPrev_max { piHealth = piMax_health + (piHealth - iPrev_max); }
      %else { piHealth = bound(piHealth, $, piMax_health); }

      Send(self,@NewHealth); % in case need heal timer
      
      return piMax_health - iPrev_max;
   }

   GetInitialMaxMana()
   {
      return 15 + Send(self,@GetMysticism)/5;
   }
 
   StripNodeList(number=$)
   {
      local nodelist, count;
      
      nodelist = Send(self,@GetNodelist);

      if number = $
      {
         number = length(nodelist);
      }

      count = 1;

      while nodelist >=1
      {
         if ((nodelist/2)*2) <> nodelist  %we do an "# was odd" operator
         {
            Send(Send(SYS,@FindNodeByNum,#num=count),@UnMeld,#who=self);
         }
         
         count = count*2;
         nodelist = nodelist/2;
      }
      
      Send(self,@ResetNodeList);
      Send(self,@NewMana);
      
      return;
   }

   StripOneNode(report=TRUE)
   {
      local lNodes, index, bFaerieNode, bQNode, oNode;

      if piNodeList = 0
      {
         return;
      }

      lNodes = $;
      index = 1;
      bFaerieNode = FALSE;
      bQNode = FALSE;

      while index <= NODE_MAX_VALUE
      {
         if piNodelist & index
         {
            if index = NODE_FAERIE
            {
               bFaerieNode = TRUE;
            }
            else
            {
               if index = NODE_Q
               {
                  bQNode = TRUE;
               }
               else
               {
                  lNodes = cons(index,lNodes);
               }
            }
         }

         index = index * 2;
      }

      if lNodes = $
      {
         % No nodes; let's rip out one of the special ones, then.
         if bFaerieNode
         {
            lNodes = cons(NODE_FAERIE,lNodes);
         }
         
         if bQNode
         {
            lNodes = cons(NODE_Q,lNodes);
         }
      }

      if lNodes
      {
         index = Nth(lNodes,random(1,length(lNodes)));
         oNode = Send(SYS,@FindNodeByNum,#num=index);
         Send(oNode,@UnMeld,#who=self);
         
         if report
         {
            Post(self,@MsgSendUser,#message_rsc=player_lose_node,
                 #parm1=Send(oNode,@GetLocationName));
         }
      }

      Send(self,@NewMana);

      return;
   }

   RemoveNodeFromList(node_num=0)
   {
      piNodelist=piNodelist & ~node_num ;
      
      return;
   }

   ResetNodeList()
   {
      piNodelist = 0;
      
      return;
   }

   NewMaxMana(amount=0,node_num=-1)
   "This is called from the mana node.  Unlike newMaxHealth, the amount is "
   "checked here.  Returns actual amount changed"
   {
      local iPrev_max;

      iPrev_max = piMax_mana;
      if amount > 0 AND node_num <> -1
      {
         piNodelist = piNodelist | node_num;
      }
      
      if amount < 0 AND node_num <> -1
      {
         if piNodelist & node_num
         {
            piNodelist = piNodelist & ~node_num;
         }
         else
         {
            Debug("BAD: missing node_num from nodelist in mana adjust.",self);
         }
      }
      
      piMax_Mana = piMax_mana+amount;      

      Send(self,@NewMana);
      
      return (piMax_mana - iPrev_max);
   }

   ComputeMaxMana()
   {
      local index, iNodeList, oNode, i;

      index = 1;
      iNodelist = piNodelist;
      
      piMax_mana = Send(self, @GetInitialMaxMana);
      
      while iNodeList > 0 AND index <= NODE_MAX_VALUE
      {          
         if (iNodeList & index)   
         {      
            oNode = Send(SYS,@FindNodeByNum,#num=index);      
            piMax_mana = piMax_mana + Send(oNode,@GetManaAdjust,#who=self);
            iNodelist = iNodelist & ~index;
         }
         
         index=index*2;
      }
      
      % account for any items that may affect max mana
      for i in plUsing
      {
         if Send(i,@AdjustsMaxMana)
         {
            piMax_mana = piMax_mana + Send(i,@GetManaChange);
         }
      }
      
      for i in plEnchantments
      {
         if Send(Nth(i,2),@AffectsMaxMana)
         {
            piMax_mana = piMax_mana + Send(Nth(i,2),@getManaBonus,#state=Nth(i,3));
         }
      }
      
      Send(self,@NewMana);
      
      return;
   }

   NumManaNodes()
   {
      local i, n;
      
      n = 0;
      i = 1;

      while i <= NODE_MAX_VALUE
      {
         if piNodelist & i
         {
            n = n + 1;
         }
         
         i = 2 * i;
      }
      
      return n;
   }

   GetNodeList()
   "Returns the list of nodes that a player has successfully melded with."
   {
      return piNodelist;
   }

   LoseMana(amount = 0)
   {
      local iManaLost;

      piMana = piMana - amount;
      if piMana < 0
      {
         iManaLost = amount - abs(piMana);
      }
      
      Send(self,@NewMana);

      return iManaLost;
   }

   GainMana(amount=0, bCapped=FALSE)
   {
      local iManaGained;
   
      iManaGained = amount;
      piMana = piMana + amount;

      if bCapped AND piMana > piMax_Mana
      {
         iManaGained = amount - (piMana - piMax_Mana);
         piMana = piMax_Mana;
      }
      
      Send(self,@NewMana);

      return iManaGained;
   }

   NewMana()
   {
      if piMana < 0
      {
         piMana = 0;
      }

      % Set a limit for maximum here in player? -BJG
      
      if piMana <> piMax_mana AND ptMana = $
      {
         ptMana = CreateTimer(self,@ManaTimer,Send(self,@CalculateManaTime));
      }
      
      if piMana = piMax_mana AND ptMana <> $
      {
         DeleteTimer(ptMana);
         ptMana = $;
      }
      
      Send(self,@DrawMana);
      
      return;
   }

   GetSpellList()
   {
      return plSpells;
   }

   % These next three functions handle school casts.

   % This message handles adding a weighted cast to the school casts list.
   AddSchoolCast(school=$, amount=$)
   {
      local iToAdd;
      
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ]; 
      }
      
      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
         OR amount = $
      {
         return;
      }

      iToAdd = amount;

      % Give a penalty for sitting at the botting imp cap.
      if NOT Send(self,@CheckAdvancementPoints)
      {
         iToAdd = iToAdd / 2;
      }

      SetNth(plSchoolCasts,school,(Nth(plSchoolCasts,school)+iToAdd));

      return;
   }

   % This message returns the appropriate school cast amount from the list.
   GetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ]; 
      }
      
      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return 0;
      }

      return Nth(plSchoolCasts,school);
   }

   % This message resets the weighted cast count back to 0.
   ResetSchoolCast(school=$)
   {
      if plSchoolCasts = $
      {
         % 11 elements for now
         plSchoolCasts = [ 0,0,0,0,0,0,0,0,0,0,0 ]; 
      }
      
      if school = $
         OR school < 0
         OR school > length(plSchoolCasts)
      {
         return;
      }

      SetNth(plSchoolCasts,school,0);
      
      return;
   }

   GetNumAbilityPointsInSchool(school=0)
   {
      if school = 0
      {
         return 0;
      }

      if plSchools = $
      {
         return 0;
      }
      
      return Nth(plSchools,school);
   }   

   GetNumSpellsInSchool(school = 0)
   "Used by the advancement checker to see the odds of a player advancing."
   {
      local num, i, oSpell;
      
      num = 0;
      for i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=i));
         if school = Send(oSpell,@GetSchool)
         {
            num = num + 1;
         }
      }
      
      return num;
   }
     
   GetSkillList()
   {
      return plSkills;
   }
   
   GetHealth()
   {
      return piHealth;
   }

   GetMana()
   {
      return piMana;
   }
   
   GetMight()
   {
      return bound((piMight + piMightMod),1,MAXIMUM_STAT);
   }
   
   GetIntellect()
   {
      return bound((piIntellect + piIntellectMod),1,MAXIMUM_STAT);
   }
   
   GetAgility()
   {
      return bound((piAgility + piAgilityMod),1,MAXIMUM_STAT);
   }
   
   GetAim()
   {
      return bound((piAim + piAimMod),1,MAXIMUM_STAT);
   }
   
   GetStamina()
   {
      return bound((piStamina + piStaminaMod),1,MAXIMUM_STAT);
   }
   
   GetMysticism()
   {
      return bound((piMysticism + piMysticismMod),1,MAXIMUM_STAT);
   }

   GetRawMight()
   {
      return bound(piMight,1,50);
   }
   
   GetRawIntellect()
   {
      return bound(piIntellect,1,50);
   }
   
   GetRawAgility()
   {
      return bound(piAgility,1,50);
   }
   
   GetRawAim()
   {
      return bound(piAim,1,50);
   }
   
   GetRawStamina()
   {
      return bound(piStamina,1,50);
   }

   GetRawMysticism()
   {
      return bound(piMysticism,1,50);
   }

   GetKarma()
   "Returns karma in natural units"
   {
      return piKarma/100;
   }

   GetVigor()
   {
      return piVigor;
   }

   AddKarma(amount = 0)
   "Adds argument (which must be in hundreths of karma units) to karma"
   {
      piKarma = piKarma + amount;
      Send(self,@NewKarma);

      return;
   }

   LoseKarma(amount = 0)
   {
      piKarma = piKarma - 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   GainKarma(amount = 0)
   {
      piKarma = piKarma + 100 * amount;
      Send(self,@NewKarma);

      return;
   }

   NewKarma()
   {
      if piKarma < -10000
      {
         piKarma = -10000;
      }

      if piKarma > 10000
      {
         piKarma = 10000;
      }

      Send(self,@DrawKarma);

      return;
   }

   CalculateKarmaChangeFromAct( karma_doer=$, karma_act=$, Swing_factor = 1)
   {
      local iBase, iChange;

      if karma_doer = $ OR karma_act = $
      {
         return 0;
      }

      % Do not change karma if player is good, act is good, but not as good as player.
      % I.e. only change karma if good player does bad stuff (or vice versa).
      if (karma_doer > 0 AND karma_act > 0 AND karma_doer > karma_act)
      OR (karma_doer < 0 AND karma_act < 0 AND karma_doer < karma_act)
      {
         return 0;
      }

      iBase = karma_doer  - karma_act;
    
      iChange = - ((iBase*iBase*ibase)/2500 + (5*iBase));
    
      % Swing factor must be a number from 1 to 10
      swing_factor = bound(swing_factor,1,10);
    
      return (iChange / (11 - swing_factor));
   }

   CalculateKarmaChangeFromKill( karma_killer = 0, karma_victim = 0, bIsMob = FALSE )
   {
      local iChange, iSwing, oRoom;

      % No karma changes from killing players during Frenzies.
      % Also, no Karma change from event monsters: Xeos and admin-spawned.
      if (Send(SYS,@GetChaosNight) AND NOT bIsMob)
         OR karma_victim = $
      {
         return 0;
      }

      % No karma changes in the newbie area.  Otherwise e.g. killing a negative
      % karma monster may make your spell inoperable.
      oRoom = Send(self, @GetOwner);
      if oRoom <> $ AND Send(oRoom, @GetRegion) = RID_NEWB_BASE
      {
         return 0;
      }

      % No karma changes from killing neutral monsters.
      if bIsMob AND karma_victim = NEUTRAL
      {
         return 0;
      }

      % A kill is merely an act, like all other acts, with the
      %  strongest swing factor possible.  The karma of a kill
      %  is equal to the negative karma of the person who died -
      %  thus, killing someone with 100 karma is a -100 karma act.
      if bIsMob
      {
         iSwing = Send(Send(SYS, @GetSettings), @GetKillKarmaSwingMonster);
      }
      else
      {
         iSwing = Send(Send(SYS, @GetSettings), @GetKillKarmaSwingPlayer);
      }
 
      % Okay, let's give them a break if they are moving towards
      %  neutrality, and they've just killed a monster.  This happens,
      %  for example, if a player with 20 karma kills a monster with
      %  -10.  It moves the player towards 10, but at a slower pace.

      if bIsMob 
      {
         if (karma_killer > 0) <> (karma_victim > 0)
            AND (abs(karma_killer) > abs(karma_victim))
         {
            iSwing = Send(Send(SYS, @GetSettings), @GetKillKarmaSwingNeutral);
         }
      }

      iChange = Send(self,@CalculateKarmaChangeFromAct,#karma_doer = karma_killer,
                     #karma_act = -(karma_victim),#swing_factor = iSwing);
        
      if bIsMob 
      {
         iChange = Bound(iChange,-150,150);
      }

      return iChange;    
   }

   %%% Guild Command Stuff

   RemoveAllGuildCommands()
   "Removes all of the player's guild commands from him."
   {
      piGuild_commands = 0;
      
      return;
   }

   HasGuildCommand(command_num=0)
   "This always checks to be sure that the flag exists."
   {
      return (piGuild_commands & command_num);
   }
   
   AddGuildCommand(command_num = 0)
   "Adds a guildcommand to player's arsenal.  Usually called by resetpowers"
   "in guild.kod."
   {
      local oCommand;

      if Send(self,@HasGuildCommand,#command_num=command_num)
      {
         return FALSE;
      }
      
      piGuild_Commands = piGuild_Commands | command_num;
      
      return TRUE;
   }


   RemoveGuildCommand(command_num=0)
   {
      piGuild_commands = piGuild_commands & ~command_num;
      
      return;
   }
   
   SetGuild(guild_obj=$)
   "Sets the player's poGuild to be equal to the guild object."
   {
      poGuild = guild_obj;
      Send(self,@EvaluatePKStatus,#dbug=TRUE);
      
      return;
   }

   QuitGuild()
   "Call this if you're an admin trying to kick someone out of a guild."
   "This will tell the guild to delete the user."
   {
      if poGuild <> $
      {
         Send(poGuild,@removefromguild,#who=self);
      }
      
      return;
   }

   ResetGuildStuff()
   "This should never be called directly, except from 'RemoveFromGuild' in"
   "guild.kod!  Otherwise, the guild lists may not match with player's poGuild!"
   {
      poGuild = $;
      piGuild_commands = 0;
      if poOwner <> $ AND Send(poOwner,@GetWatcher) <> $
      {
         Send(Send(poOwner,@getwatcher),@PlayerQuitGuild,#who=self);
      }
      
      return;
   }

   %%%  Spells Stuff
   
   HasSpell(num = 0)
   "Returns TRUE if a spell is in a player's spell list,"
   "FALSE if it is not."
   {
      local i,oSpell;

      for i in plSpells
      {
         if Send(self,@DecodeSpellNum,#compound=i) = num
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   EncodeSpell(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used=TRUE 
      {
         return num*100 + iability;
      }
      
      return -(num*100 + iability);
   }
 
   DecodeSpellNum(compound = 0)
   {
      return abs(compound) / 100;
   }
 
   DecodeSpellAbility(compound = 0)
   {
      return abs(compound) mod 100;
   }
   
   GetSpellAbility(spell_num = 0)
   {
      local i;
      
      for i in plSpells
      {
         if Send(self,@DecodeSpellNum,#compound=i) = spell_num
         {
            return Send(self,@DecodeSpellAbility,#compound=i);
         }
      }
      
      % this spell is not in the player's spell list.  return 0 ability.
      return 0;
   }

   ChangeSpellAbility(spell_num = 0, amount = 0, report = FALSE,
                      refigureschools = TRUE)
   {
      local i, bFound, elemnum, iability, bUsed, spellname, iChange,
            newability, oSpell, oRoom;

      oSpell = Send(sys,@FindSpellByNum,#num=spell_num);
      if oSpell = $
      {
         return FALSE;
      }

      % Make sure user has this spell (should always have it if this is being called)
      bFound = FALSE;
      elemnum = 0;
      spellname = Send(oSpell,@GetName);
      iChange = 0;

      % Do _not_ replace with HasSpell.  
      % This also finds the spell/ability pair and puts it in 'i' for later use.
      for i in plSpells
      {
         elemnum = elemnum + 1;
         if spell_num = Send(self,@DecodeSpellNum,#compound=i)
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % Can't advance a spell you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if NOT bUsed
      {
         bUsed = -1;
      }
        
      iability = Send(self,@DecodeSpellAbility,#compound=i);
      newability = bound(iability+amount,1,99);
      iChange = newability-iability;

      SetNth(plSpells,elemnum,Send(self,@EncodeSpell,#num=spell_num,#iability=newability));
      Send(self,@DrawStatSpell,#index=elemnum);
      if report AND iChange > 0
      {
         oRoom = Send(self, @GetOwner);
         Post(self,@MsgSendUser,#message_rsc=player_improved,#parm1=spellName);
         Send(oRoom, @SomethingWaveRoom, #what=self, 
              #wave_rsc=player_improved_wav_rsc);
      }
      
      if iChange > 0 
      {
         Send(self,@AddAdvancementPoints,#number=amount);
      }
      
      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {    
         Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),#change=iChange);
      }

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," changed in spell ability of ",spellname,
               " by ",iChange," to ",abs(i));
      }

      return TRUE;
   }
   
   AddToSchools(school=0, change=0)
   {
      local iOldValue, oLore;

      if school = $
         OR school < 1
         OR change = $
         OR change = 0
      {
         return FALSE;
      }

      if plSchools = $
      {
         % 11 elements right now.
         plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];  
      }
      
      while length(plSchools) < school
      {
         plSchools = cons(0, plSchools);
      }

      iOldValue = Nth(plSchools,school);
      SetNth(plSchools,school,(iOldValue+change));

      oLore = Send(SYS,@GetLore);
      Send(oLore,@PlayerAdvanced,#who=self,#school = school);

      return TRUE;
   } 

   RefigureSchoolsLists(informlore=FALSE)
   {
      local i, lOldList, oAbility, iSchool, iAbility, iValue, oLore, bChanged,
            index, iNum;

      lOldList = plSchools;

      % 11 elements right now.
      plSchools = [ 0,0,0,0,0,0,0,0,0,0,0 ];  

      for i in plSpells
      {
         iAbility = Send(self,@DecodeSpellAbility,#compound=i);
         iNum = Send(self,@DecodeSpellNum,#compound=i);
         oAbility=Send(SYS,@FindSpellByNum,#num=iNum);    
         if IsClass(oAbility,&spell)
         {
            iSchool = Send(oAbility,@GetSchool);    
            iValue = Nth(plSchools,iSchool);
            SetNth(plSchools,iSchool,(iValue+iAbility));
         }
      }
      
      for i in plSkills
      {
         oAbility=Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
         iSchool = Send(oAbility,@GetSchool);
         iAbility = Send(self,@DecodeSkillAbility,#compound=i);
         iValue = Nth(plSchools,iSchool);
         SetNth(plSchools,iSchool,(iValue+iAbility));
      }
      
      if informlore OR lOldList = $
      { 
         % Assume that something has changed
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school = iSchool);
         
         return;
      }

      % We want to know if something has changed.
      bChanged = FALSE;
      index = 0;
      for i in lOldList
      {
         index = index + 1;
         if Nth(lOldList,index) <> Nth(plSchools,index)
         {
            bChanged = TRUE;
         }
      }
      
      % If they changed, update them in the lore.
      if bChanged
      {
         oLore = Send(SYS,@GetLore);
         Send(oLore,@PlayerAdvanced,#who=self,#school=-1);
      }

      return TRUE;
   }

   AdminSetSpell(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a spell by an additional or absolute value."
   {
      local oSpell, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSpellAbility,#spell_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSpell,#num=num,#iability=ability)
         {
            return player_admin_added_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 and add <= -oldAbility
      {
         if Send(self,@RemoveSpell,#num=num)
         {
            return player_admin_removed_spell;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 and add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }
      
      if Send(self,@ChangeSpellAbility,#spell_num=num,#amount=add)
      {
         return player_admin_modified_spell;
      }
      
      return Send(SYS,@GetFailureRsc);
   }

   AddSpell(num = 0, iability=0, bDM=FALSE, initial=FALSE, dontSend=FALSE)
   "Admin supported\n"
   "Adds a spell by spell ID to the user's castable list of spells"
   {
      local i, j, oSpell, lSpell_info, lPrereqs, bFound, iBoundAbility, lEncode;
      
      if Send(self,@HasSpell,#num=num)
      {
         if Send(self,@GetSpellAbility,#spell_num=num) < iAbility
         {
            Send(self,@ChangeSpellAbility,#spell_num=num,#amount=iAbility);

            return TRUE;
         }
         
         return FALSE;
      } 

%  When I re-enabled the shadow rift spell, it was only sold by the lich,
%  and the Ao3/SotH quest that was needed to get the spell was broken and unfixable,
%  so I made the spell sold by a different NPC.  I had to remove this check
%  (which clearly doesn't belong in player; should be in the spell itself) to
%  make it buyable.  - ARK 10/26/2010
%
%      if num = SID_DEATHS_DOOR
%          AND ((NOT Send(self, @IsUsingA,#class=&NecromancerAmulet))
%               AND (NOT IsClass(self,&Admin)))
%      {
%         return FALSE;
%      }
      
      oSpell = Send(SYS,@FindSpellByNum,#num=num);
      if oSpell = $
      {
         return FALSE;
      }
      
      lPrereqs = Send(oSpell,@GetPrerequisites);
      
      for i in lPrereqs
      {
         if NOT Send(self,@HasSpell,#num=i)
         {
            %Player can't learn this spell without all the prerequisites.
            return FALSE;
         }
      }
      
      % Spell format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSpell,@InitialAbility,#who=self);
      }
      
      lEncode = Send(self,@EncodeSpell,#num=num,#iability=iBoundAbility);
      plSpells = Cons(lEncode,plSpells);

      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," added spell ",Send(oSpell,@GetName));
      }           

      if dontSend = FALSE
      {
         Send(self,@ToCliAddSpell,#oSpell=oSpell);
      }
      
      if NOT bDM
         AND NOT initial
      {  
          Send(self,@AddToSchools,#school=Send(oSpell,@GetSchool),\
               #change=iBoundAbility);     
          Send(self,@AddAdvancementPoints,#number=2);
      }

      if poOwner <> $
         AND NOT bDM
         AND NOT dontSend
      {
         Send(poOwner,@SomethingWaveRoom,#what=self,
              #wave_rsc=player_sound_learn_spell);
      }

      for i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@PlayerIsIntriguing);

      return TRUE;
   }
   
   RemoveAllSpells()
   {
      local i;
      
      plSpells=$;
      if Send(self,@CheckLog)
      {
         Debug("LOG:  ",vrName," lost all spells.");
      }

      Send(self,@PlayerIsIntriguing);

      for i in plUsing
      {
         if IsClass(i,&DiscipleRobe)
         {
            Send(i,@ResetColors);
         }
      }

      Send(self,@ToCliStats,#group=3);

      return TRUE;
   }

   RemoveSpell(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a spell by spell ID from the user's castable list of spells"
   {
      local oSpell, i, j, bFound;
      
      oSpell = Send(SYS,@FindSpellbyNum,#num=num);
      if oSpell = $
      {
         Debug("Trying to delete a spell that doesn't exist in system.");
         
         return FALSE;
      }
    
      bFound = FALSE;
      for i in plSpells
      {
         if num = Send(self,@DecodeSpellNum,#compound=i)
         {
            plSpells = DelListElem(plSpells,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," removed spell ",Send(oSpell,@GetName));
            }

            Send(self,@ToCliRemoveSpell,#oSpell=oSpell);
            Send(self,@PlayerIsIntriguing);

            bFound = TRUE;
            for j in plUsing
            {
               if IsClass(j,&DiscipleRobe)
               {
                  Send(j,@ResetColors);
               }
            }
            
            if NOT isDM  
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

     Debug("Trying to delete a spell not on spell list",self,num);
     
     return FALSE;
   }
   
   WasSpellUsed(compound=0)
   {
      if compound > 0
      {
         return TRUE;
      }
      
      return FALSE;
   } 
   
   % In case player has been enchanted with the forget spell, this checks
   % to see if they have forgotten the skill/spell (what)
   HasForgetEnchantment(what = $)
   {
      local oSpell, lState, iStateMember;

      lState = $;

      if NOT piFlags & PFLAG_FORGOTTEN
      {
         return FALSE;
      }

      oSpell = Send(SYS,@FindSpellbyNum,#num=SID_FORGET);
      lState = Send(self,@GetEnchantedState,#what=oSpell);
      if lState = $
      {
         return FALSE;
      }
   
      for iStateMember in lState
      {
         if iStateMember = what
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   FlipSpellAtrophyFlag(SID=0)
   "This spell was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, spellnum;
      
      elemnum = 0;
      for i in plSpells
      {       
         elemnum = elemnum + 1;      
         if Send(self,@DecodeSpellNum,#compound=i) = SID
         {
            SetNth(plspells,elemnum,abs(i));
            
            break;
         }
      }
      
      return;
   }

   ActivateSpellAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSpell, bSpell, bFound, highmark, iAmount;

      % Must get below highmark for atrophy to activate
      iAmount = -2;

      highmark = piAdvancement_points + ((50-bound(Send(self,@GetIntellect),1,50))
                 * piAdvancement_Points)/20; 

      for i in plSpells
      {
         if i < 0 AND Random(1,200) < highmark               
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            if iAbility > 2                                                         
            {
               aSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=i));
               bFound = FALSE;
               
               for j in plSpells
               {
                  bSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,#compound=j));
                  if j > 0 AND Send(aSpell,@GetSchool) = Send(bSpell,@GetSchool)
                  {
                     iAmount = -1;
                     
                     break;
                  }                                 
               }
               Send(self,@ChangeSpellAbility,#spell_num=Send(aSpell,@GetSpellNum),
                    #amount=iamount);
            }
         }
      }
      
      return;
   }

   %%%  Skills Stuff

   HasSkill(num = $)
   "Returns TRUE if a Skill is in a player's Skill list,"
   "FALSE if it is not."
   {
      local i,oSkill;

      for i in plSkills
      {
         if Send(self,@DecodeSkillNum,#compound=i) = num
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   EncodeSkill(num = 0, iability = 0, Has_Been_Used=TRUE)
   {
      if Has_been_used
      {
         return num*100 + iability;
      }
      
      return -(num*100 + iability);
   }
 
    DecodeSkillNum(compound = 0)
    {
       return abs(compound) / 100;
    }
 
    DecodeSkillAbility(compound = 0)
    {
       return abs(compound) mod 100;
    }

   GetSkillAbility(Skill_num = 0, absolute=FALSE)
   {
      local i;

      for i in plSkills
      {
         if Send(self,@DecodeSkillNum,#compound=i) = Skill_num
         {
            return Send(self,@DecodeSkillAbility,#compound=i);
         }
      }
      
      % this Skill is not in the player's Skill list.  return 0 ability.
      return 0;
   }

   ChangeSkillAbility(Skill_num = 0, amount = 0, report = FALSE, refigureschools = TRUE, bDM = FALSE)
   {
      local i, bFound, elemnum, iability, bUsed, iChange, skillname, 
            newability, oSkill, oRoom;
 
      oSkill = Send(SYS,@FindSkillByNum,#num=skill_num);
      if oSkill = $
      {
         return FALSE;
      }

      % Make sure user has this Skill (should always have it if this is being called)
      bFound = FALSE;
      elemnum = 0;
      skillname = Send(oSkill,@GetName);
      iChange = 0;
 
      % Do _not_ replace with HasSkill.  
      % This also finds the Skill/ability pair and puts it in 'i' for later use.
      for i in plSkills
      {
         elemnum = elemnum + 1;
         if Skill_num = Send(self, @DecodeSkillNum, #compound=i)
         {
            bFound = TRUE;
            
            break;
         }
      }
      
      if NOT bFound
      {
         % Can't advance in a skill you don't have.
         return FALSE;
      }

      bUsed = Send(self,@WasSpellUsed,#compound=i);
      if bUsed = 0
      {
         bUsed = -1;
      }

      iability = Send(self,@DecodeSkillAbility,#compound=i);
      newability = bound(iability+amount,1,99);
      iChange = newability - iability;

      % If we advance a stroke or a proficiency, then reset our stroke count (and bonuses)
      if IsClass(oSkill,&Stroke) OR IsClass(oSkill,&Proficiency)
      {
         Send(self,@ResetWeaponSwings);
      }

      SetNth(plSkills, elemnum, Send(self,@EncodeSpell,#num=skill_num,#iability=newability));
      Send(self,@DrawStatSkill,#index=elemnum);
      if report AND (iChange > 0)
      {
         oRoom = Send(self, @GetOwner);
         Post(self,@MsgSendUser,#message_rsc=player_improved,#parm1=skillName);
         Send(oRoom, @SomethingWaveRoom, #what=self, 
              #wave_rsc=player_improved_wav_rsc);
      }
      
      if iChange > 0 
      {
         Send(self,@AddAdvancementPoints,#number=amount);
      }
      
      Send(self,@PlayerIsIntriguing);

      if refigureschools
      {    
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),#change=iChange);
      }
   
      if Send(self,@CheckLog)
      {           
         Debug("LOG:  ",vrName," changed skill ",skillname,"by ",iChange,
               " to ",abs(i)); 
      }

      return TRUE;
   }

   AdminSetSkill(num = 0, ability = 0, add = 0)
   "Admin supported.\n"
   "Adds, removes or changes a skill by an additional or absolute value."
   {
      local oSkill, oldAbility;

      if num = $ OR num = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      oSkill = Send(SYS,@FindSkillByNum,#num=num);
      if oSkill = $
      {
         return Send(SYS,@GetFailureRsc);
      }

      oldAbility = Send(self,@GetSkillAbility,#skill_num=num);

      % Add?
      if oldAbility = 0
      {
         if Send(self,@AddSkill,#num=num,#iability=ability)
         {
            return player_admin_added_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Remove?
      if ability = 0 AND add <= -oldAbility
      {
         if Send(self,@RemoveSkill,#num=num)
         {
            return player_admin_removed_skill;
         }

         return Send(SYS,@GetFailureRsc);
      }

      % Modify?
      if ability = 0 AND add = 0
      {
         return Send(SYS,@GetFailureRsc);
      }

      if add = 0
      {
         add = ability - oldAbility;
      }
      
      if Send(self,@ChangeSkillAbility,#skill_num=num,#amount=add)
      {
         return player_admin_modified_skill;
      }
      
      return Send(SYS,@GetFailureRsc);
   }

   AddSkill(num = 0, iability = 0, bDM = FALSE, initial = FALSE, dontSend = FALSE)
   "Admin supported\n"
   "Adds a Skill by Skill ID to the user's castable list of Skills"
   {
      local i,j,oSkill, lSkill_info, lPrereqs, bFound, iBoundAbility;
      
      if Send(self,@HasSkill,#num=num)              
      {
         % Already has it.
         if Send(self,@GetSkillAbility,#skill_num=num) < iAbility
         {
            Send(self,@ChangeSkillAbility,#skill_num=num,#amount=iAbility);

            return TRUE;
         }

         return FALSE;
      }
      
      oSkill = Send(SYS,@FindSkillByNum,#num=num);    % system has no info on this skill.
      if (oSkill = $)
      {
         return False;
      }
           
      % Skill format: [ num * 100 + ability ]

      iBoundAbility = bound(iAbility,0,99);
      
      if iBoundAbility = 0
      {
         iBoundAbility = Send(oSkill,@InitialAbility,#who=self);
      }

      plSkills = Cons(Send(self, @EncodeSkill,#num=num,#iability=iBoundAbility),plSkills);
                      
      if Send(self,@checklog)
      {
         Debug("LOG:  ",vrName," added skill ",Send(oSkill,@GetName));
      }

      if NOT dontSend
      {
         Send(self,@ToCliAddSkill,#oSkill=oSkill); 
      }
      
      if NOT bDM and NOT initial
      {  
         Send(self,@AddToSchools,#school=Send(oSkill,@GetSchool),
              #change=iBoundAbility);     
         Send(self,@AddAdvancementPoints,#number=4);
      }
      
      return True;
   }
   
   RemoveAllSkills()
   {
      plSkills = $;

      if Send(self,@checklog)
      {
         Debug("LOG:  ",vrName," loses all skills.");
      }

      Send(self,@ToCliStats,#group=4);

      return TRUE;
   }
   
   RemoveSkill(num = 0, isDM = FALSE)
   "Admin supported\n"
   "Removes a Skill by Skill ID from the user's castable list of Skills"
   {
      local oSkill,i;
      
      oSkill = Send(SYS, @FindSkillbyNum, #num=num);
      if oSkill = $
      {
         Debug("Trying to delete a skill the system doesn't recognize.");

         return FALSE;
      }
    
      for i in plSkills
      {
         if num = Send(self,@DecodeSkillNum,#compound=i)
         {
            plSkills = DelListElem(plSkills,i);
            if Send(self,@CheckLog)
            {
               Debug("LOG:  ",vrName," lost skill ",Send(oSkill,@GetName));
            }

            Send(self,@ToCliRemoveSkill,#oSkill=oSkill);

            if NOT isDM
            {
               % DMs get it all figured out at once.
               Send(self,@RefigureSchoolsLists);
            }

            return TRUE;
         }
      }

      Debug("Tried to delete skill not in skill list",self,num);
      
      return FALSE;
   }
   
   FlipSkillAtrophyFlag(SKID=0)
   "This Skill was used recently, meaning it will NOT atrophy."
   {
      local i, elemnum, Skillnum;

      elemnum = 0;
      for i in plSkills
      {       
         elemnum = elemnum + 1;      
         if Send(self,@decodeSkillNum,#compound=i) = SKID
         {
            SetNth(plSkills,elemnum,abs(i));
            
            break;
         }
      }
      
      return;
   }

   ActivateSkillAtrophy()
   {
      local i, j, iability, lSchoolsUsed, aSkill, bSkill, bFound, highmark, iAmount;

      iAmount = -2;
      highmark = piAdvancement_points + ((50-bound(Send(self,@GetIntellect),1,50))*piAdvancement_Points)/20;

      for i in plSkills
      {
         if i < 0 AND Random(1,200) < highmark           
         {
            iAbility = Send(self,@decodeSkillability,#compound=i);
            if iAbility > 2                                                         
            {
               aSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=i));
               bFound = FALSE;
               for j in plSkills
               {
                  bSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,#compound=j));
                  if j > 0 AND Send(aSkill,@GetSchool) = Send(bSkill,@GetSchool)
                     AND aSkill <> bSkill
                  {
                     iAmount=-1;
                     break;
                  }                                 
               }
               
               Send(self,@ChangeSkillAbility,#skill_num=Send(aSkill,@GetSkillNum),
                    #amount=iAmount);
            }
         }
      }
      
      return;
   }

   %%%  Advancement

   ResetAtrophyFlags()
   "This sets all of a player's spell values to negative."
   "This means that the player has not used these spells in a while."
   "Meaning they have a chance to atrophy when ptAdvancement goes off."
   {
      local i, elemnum;

      elemnum = 0;
      for i in plSpells
      {
         elemnum = elemnum+1;
         SetNth(plSpells,elemnum,-(abs(i)));
      }
      
      elemnum = 0;
      for i in plSkills
      {
         elemnum = elemnum+1;
         SetNth(plSkills,elemnum,-(abs(i)));
      }
      
      return;
   }

   AddAdvancementPoints(number=1)
   "A player can only gain so many advancement points per hour, in spells"
   "And skills combined."
   {
      local iTime;
      
      if ptAdvancement = $
      {
         iTime = random(ADVANCE_TIMER_MIN,ADVANCE_TIMER_MAX);
         ptAdvancement = CreateTimer(self,@AdvancementTimer,iTime);
      }
      
      piAdvancement_points = piAdvancement_points + number;
      
      return;
   }

   CheckAdvancementPoints()
   "Checks to be sure a player isn't at the limit yet."
   {
      if piAdvancement_points < ADVANCEMENT_LIMIT
      {
         return TRUE;
      }
      
      return FALSE;
   }

   AdvancementTimer()
   "This does a few things when it goes off.  It clears advancement points, "
   "so people can learn again.  It also checks for spell or skill atrophy, "
   "and resets the atrophy flags."
   {
      ptAdvancement = $;

      if piAdvancement_points > 0 AND pbLogged_on
      {
         if Send(Send(SYS, @GetSettings), @IsAtrophyOn)
         {
            Send(self,@ActivateSpellAtrophy);
            Send(self,@ActivateSkillAtrophy);
         }
         
         Send(self,@ResetAtrophyFlags);
      }
      
      piAdvancement_Points = 0;
      
      return;
   }

   %%% Advancement in combat

   SomethingKilled(what=$,victim=$,use_weapon=$)
   {
      if victim = poKill_target AND IsClass(victim,&Battler)
      {
         if what = self
         {
            Send(self,@AdvancementCheck,#what=victim,#killing_blow=TRUE);
         }
         else
         {
            Send(self,@AdvancementCheck,#what=victim,#killing_blow=FALSE);
         }
         
         poKill_target=$;
         Send(self,@ResetGainFlags);
      }
      
      propagate;
   }

   ResetGainFlags()
   {
      poKill_target = $;
      Send(self,@SetPlayerFlag,#flag=PFLAG_DID_DAMAGE,#value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_TOOK_DAMAGE, #value=FALSE);
      Send(self,@SetPlayerFlag,#flag=PFLAG_DODGED, #value=FALSE);
      
      return;
   }


   AdvancementCheck(what=$,killing_blow=TRUE)
   "A player will need, on average, to kill a number of monsters equal to"
   "their maxhealth to gain a HP.  This number is reduced by the player's"
   "stamina, all the way down to half for those with high staminas."
   {
      local highmark, rand, dodgeskill, oSkill, monster_level, gain, gainmult, roll, iNumber, oWeapon;
            
      gain = 0;
      roll = FALSE;

      % Some things just never allow advancement.
      % Can advance in arena if realdeath is on in an arena.
      if NOT Send(what,@CanPlayerAdvanceOnMe)
         OR Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFE_DEATH)
         OR (Send(poOwner,@IsArena) AND NOT Send(poOwner,@ArenaRealDeath))
      {
         return FALSE;  
      }

      if IsClass(what,&User)
      {
         monster_level = Send(what,@GetBaseMaxHealth);
      }
      else
      {
         monster_level = Send(what,@GetLevel);
      }

      if Send(self,@CheckPlayerFlag,#flag=PFLAG_DID_DAMAGE)
         AND poKill_target = what
      {
         if monster_level > piBase_Max_health
         {
            if killing_blow AND Send(self,@CheckPlayerFlag,#flag=PFLAG_TOOK_DAMAGE)
            {
               % Player took damage and landed killing blow
               gain = 2;
               roll = TRUE;
            }
            else
            {
               % Player either did not take damage, but did killing blow (mage),
               %  or did take damage, did not land killing blow.
               gain = 1;
               roll = TRUE;
            }
         }
         else
         {
            % Monster was equal or close to player level.  Small bonus,
            %  no roll chance.
            if (monster_level + 5) > piBase_Max_health
               AND IsClass(what,&monster) AND killing_blow 
               AND Send(self,@CheckPlayerFlag,#flag=PFLAG_TOOK_DAMAGE)
            {
               gain = 1;
            }
            else
            {
               % Monster was too easy for player to kill!
               if random(1,100) < 10 AND killing_blow
               {
                  Send(self,@MsgSendUser,#message_rsc=player_spits);
               }
            }
         }

         % Give newbies a little bonus.
         if piBase_Max_health < 26 and random(20,bound(piBase_Max_health,20,25)) = 20
         {
            gain = gain + 1;
         }

         % If they're cheesing the situation by fighting wussy monsters in an altered form,
         %  penalize the gain amount.
         if piMax_health > piBase_Max_health * 2
            AND monster_level < piMax_health
         {
            gain = gain / 2;
            roll = FALSE;
         }

         gainmult = bound(Send(Send(SYS, @GetSettings), @GetHPGainMultiplier),1,100);
         gain = gain * gainmult;

         piGain_chance = piGain_chance + gain;

         if roll
         {
            highmark = Send(self,@GetHighMark);
            rand = random(1,highmark);
            iNumber = Send(self,@GetGainChance) + bound((monster_level-piBase_Max_health)/5,0,10);
                  
            if rand < iNumber
               AND piBase_Max_health < (101 + Send(self,@GetStamina))
            {
               Send(self,@GainBaseMaxHealth,#amount = 1);
               if Send(self,@CheckLog)
               {
                  Debug("LOG:  ",vrName," gained a health point: ",
                        piMax_health,pibase_max_health);
               }

               Send(self,@evaluatepkstatus);

               Send(self,@MsgSendUser,#message_rsc=player_improve_maxhealth);
               Send(self,@WaveSendUser, #what=self, #wave_rsc=player_tougher_wav_rsc);

               piGain_chance = -(piBase_Max_health/2);
               
               if piBase_max_health > 30
               {
                  piGain_chance = piGain_chance - ((50-Send(self,@GetStamina))/2);
               }

               return TRUE;
            }
         }
      }
      
      if Send(self,@CheckPlayerFlag,#flag=PFLAG_DODGED)
      {
         dodgeskill = SKID_DODGE;
         oWeapon = Send(self,@LookupPlayerWeapon);
         if oWeapon <> $
            AND (not IsClass(oWeapon,&RangedWeapon))
            AND Send(self,@HasSkill,#num=SKID_PARRY)
         {
            if random(1,100) < 30
            {
               dodgeskill=SKID_PARRY;
            }
         }
         
         if dodgeskill = SKID_DODGE
            AND (Send(self,@LookupPlayerShield) <> $)
            AND Send(self,@HasSkill,#num=SKID_BLOCK)
         {
            if random(1,100) < 30
            {
               dodgeskill=SKID_BLOCK;
            }
         }
         
         oSkill=Send(sys,@FindSkillByNum,#num=dodgeskill);
         Send(oSkill,@ImproveAbility,#who=self,#target=poKill_Target);
      }

      return FALSE;
   }

   GetGainChance()
   {
      return piGain_chance;
   }

   GetHighMark()
   {
      local index, highmark;
      
      index = (piBase_Max_health*(100-Send(self,@GetStamina)))/100;
      highmark = (index+1)*index;
      
      return highmark;
   }

   %%% Player Killed %

   Killed(what = $)
   {
      local lItems,i, amount, oBody, oSoldierShield, bNo_drop_death, oItemAtt,
            oRoom, iRow, iCol, iFine_Row, iFine_Col, iAngle, oItem, iRoom;

      % Skill, spell and hp penalties are handled by ApplyDeathPenalties, which
      %  is called from LeaveHold() in the Underworld.  This is to allow time
      %  for Portal of Life to reduce penalties.  We get the default value of
      %  piDeathCost from SYS, so that we can adjust global death penalties.

      % "Normal" value is 100.
      piDeathCost = Send(Send(SYS, @GetSettings), @GetDefaultDeathCost);  

      % A player (probably) cannot die twice in two seconds in any valid way.
      if GetTime() < (piLastDeathTime + 2)
      {
         Debug("Averted double-death of",vrName);

         return;
      }

      % Stop any rescue attempts that were going on.
      if ptRescue <> $
      {
         DeleteTimer(ptRescue);
         ptRescue = $;
      }
      
      piLastDeathTime = getTime();

      % Grab the location of the deceased.
      % Might need to grab the old location if logged off.

      if pbLogged_on
      {
         oRoom = poOwner;
         iRow = piRow;
         iCol = piCol;
         iFine_Row = piFine_Row;
         iFine_Col = piFine_Col;
         iAngle = Send(self,@GetAngle);
      }
      else
      {
         if NOT Send(self,@IsUsingA,#class=&NecromancerAmulet)
         {
            Debug("Player died while offline, but not a necromancer: ",
                  Send(self,@GetName));
         }
         
         oRoom = Send(SYS,@FindRoomByNum,#num=Send(self,@GetSaveRoom));
         iRow = Send(self,@GetSaveRow);
         iCol = Send(self,@GetSaveCol);
         iFine_Row = Send(self,@GetSaveFineRow);
         iFine_Col = Send(self,@GetSaveFineCol);
         iAngle = Send(self,@GetSaveAngle);
      }

      % Any other quick escapes from certain death?
      % Such as the Arena "loser", or while in the Out of Grace prison.
      % These aren't cheap deaths, these are ways to avoid actual death.
      if pbLogged_on
         AND ((Send(poOwner,@IsArena)
               AND Send(poOwner,@InPlay,#what=Self)
               AND NOT Send(poOwner,@ArenaRealDeath))
              OR IsClass(poOwner,&OutOfGrace)
              OR Send(poOwner,@SafePlayerAttack))
      {
         piHealth = 1;
         Send(self,@NewHealth);
         %Currently, the following block is only for Necromancer Amulets and Hunter Swords.
         for i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }
         
         return;
      }
      
      % Okay, we're really dying now.
      % Now we need to determine if it's a 'cheap' death where we don't lose stuff.

      Send(self,@RemoveAllEnchantments,#report=FALSE);
      bNo_drop_death = FALSE;

      iRoom = Send(poOwner,@GetRoomNum);

      % Reign of Blood Frenzy death?  Newbie death?
      % Don't drop anything or take any penalties.
      if Send(SYS,@GetChaosNight)
        OR (iRoom >= RID_NEWB_BASE AND iRoom <= RID_NEWB_MAX)
        OR (piBase_Max_health < PKILL_ENABLE_HP
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE))
      {
         bNo_drop_death = TRUE;
         piDeathCost = FALSE;    
      }

      % Currently, the following block is only for Necromancer Amulets and Hunter Swords.
      % This is placed before the token death check,
      % so that token deaths _will_ make you lose your artifact.
      if bNo_drop_death
      {
         for i in plActive
         {
            if Send(i,@IsItemType,#type=ITEMTYPE_SPECIAL)
            {
               Send(i,@ActivateCheapDeath);
            }
         }
      }

      % Record-keeping.  Keep this before the token check, so we can give proper message.
      Send(SYS,@UserKilled,#what=self,#killer=what);
      Send(Send(SYS, @GetStatistics), @PlayerDiedCounter);

      % Token death?
      for i in plUsing
      {
         if IsClass(i,&Token)
         {
            bNo_drop_death = TRUE;
            piDeathCost = FALSE;
            Send(self,@MsgSendUser,#message_rsc=player_token_death);
            Send(i,@NewUnused,#what=self,#where=oRoom);
            
            break;
         }       
      }

      if Send(SYS,@GetInvestigator)
      {
         Post(Send(SYS,@GetInvestigator),@InvestigateDeath,#killer=what,#victim=self,#cheap=bNo_drop_death);
      }

      % Create the corpse.
      oBody = Send(self,@CreateCorpse);
      Send(oRoom,@NewHold,#what=oBody,#new_row=iRow,#new_col=iCol,#fine_row=16,#fine_col=16, #new_angle=iAngle);

      % Start losing stuff if applicable.
      if NOT bNo_drop_death
      {
         if ptHealth <> $
         {
            DeleteTimer(ptHealth);
            ptHealth = $;
         }

         % Lose the inventory.  It falls onto the corpse.
         if (what = $) OR (NOT IsClass(what,&user))
         {
            oItemAtt = $;
         } 
         else 
         {
            oItemAtt = Send(sys,@FindItemAttByNum,#num=IA_PKPOINTER);
         }

         for lItems in [plActive,plPassive]
         {
            for i in lItems
            {
               if Send(oRoom,@ReqNewHold,#what=i,#new_row=iRow,#new_col=iCol) 
                  AND Send(oRoom,@ReqSomethingMoved,#what=i,#new_row=iRow,#new_col=iCol)
                  AND Send(i,@DropOnDeath)
               {
                  if oItemAtt <> $    
                  {
                     % We know this was a pk.  Only let PKillables pick up the loot.
                     %  Put the appropriate item attribute on it.
                     Send(oItemAtt,@AddToItem,#oItem=i,#timer_duration=PKPOINTER_TIME,
                          #state1=self);
                  }
                  
                  Send(oRoom,@NewHold,#what=i,#new_row=iRow,#new_col=iCol,#merge=FALSE);
               } 
            }
         }

         % Atrophy of skills or learning progress.
         piAdvancement_points = 0;
         piGain_chance = piGain_chance/2;
         Send(self,@ResetGainFlags);
         Send(self,@ResetAtrophyFlags);
         if ptAdvancement <> $
         {
            DeleteTimer(ptAdvancement);
            ptAdvancement = $;
         }

         Post(self,@EvaluatePKStatus);

         % Let SoldierShields know we died.  It handles itself as apropriate.
         oSoldierShield = Send(self,@FindUsing,#what=&SoldierShield);
         if oSoldierShield <> $
         {
            Send(oSoldierShield,@OwnerDied,#what=what);
         }
   
         % Positive karma makes us eligible for a booby prize.
         if piKarma > 5000 AND (Send(self,@GetHomeRoom) <> RID_NEWB1)
         {
            % To prevent mule money abuse, make the hammer "created".  This makes it
            %  worthless to try to sell.  It lasts for 5 hours.
            
            oItem = create(&Hammer);
            oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
            Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
            Send(self,@NewHold,#what=oItem);
         }
         else 
         {
            if piKarma >= 0
            {
               % To prevent mule money abuse, make the mace "created".  This makes it
               %  worthless to try to sell.  It lasts for 5 hours.
               
               oItem = create(&Mace);
               oItemAtt = Send(SYS,@FindItemAttByNum,#Num=IA_MADE);
               Send(oItemAtt,@AddtoItem,#oitem=oItem,#timer_duration=18000000);
               Send(self,@NewHold,#what=oItem);
            }
         }
      }

      % Give out your dying scream.
      if piGender = GENDER_FEMALE
      {
         i = playerf_death_wav;
      }
      else
      {
         i = playerm_death_wav;
      }

      Send(oRoom,@SomethingWaveRoom,#what=oBody,#wave_rsc=i);
      if pbLogged_on
      {
         Send(self,@WaveSendUser,#what=self,#wave_rsc=i);
      }

      % Teleport to the Underworld.
      Send(self,@UserGotoDeadRoom);
      
      % Change health, mana, vigor.
      if Send(SYS,@GetChaosNight)
      {
         % It's a frenzy!  Give us a leg up.
         piHealth = piMax_Health / 2;
         piMana = piMax_Mana / 2;
         piVigor = 100;
      }
      else
      {
         % We're not in a frenzy.  Give us the bare minimums.
         piMana = 1;
         piHealth = 1;
         piVigor = bound(piVigor/4,0,50);   
      }
      
      Send(self,@NewHealth);
      Send(self,@NewMana);
      Send(self,@NewVigor);

      % Refresh the client with what's really going on.
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);
      }

      % Wake up with red foggy hangover.
      if pbLogged_on
      {
         Send(self,@EffectSendUserDuration,#effect=EFFECT_PAIN,#duration=5000);
      }

      if piDeathCost > 0
         AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_TUTORIAL)
         AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         % Give an encouraging gmail and some mana to broadcast.
         Send(self,@ReceiveNestedMail,#from=player_angel,
              #dest_list=[self],#nest_list=[4,player_death_mail]);           
         Send(self,@MsgSendUser,#message_rsc=player_death_mail_notice);

         % Give them half their mana to broadcast for help with.
         piMana = (piMax_mana / 2) + 2;
         Send(self,@NewMana);
      }

      if poOwner = oRoom
      {
         Debug("Player didn't teleport after death!",vrName);
      }

      propagate;
   }

   ApplyDeathPenalties()
   {
      local iAmount, bLostHealth, i;
      
      if Send(SYS,@GetChaosNight)
      {
         % Remove any revenants.
         Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);

         % Return out.  Don't apply death penalties during frenzies.
         return;
      }

      bLostHealth = FALSE;

      % Lose your revenant, satisfied if you took a real death.
      if piDeathCost >= Send(Send(SYS, @GetSettings), @GetDefaultDeathCost)
      {
         % As an outlaw, justice was met by dying.  But, not if it's a cheap death!
         Send(self,@SetPlayerFlag,#flag=PFLAG_OUTLAW,#value=FALSE);
         Post(self,@EvaluatePKStatus);

         if Send(self,@CheckPlayerFlag,#flag=PFLAG_HAUNTED)
         {
            if pbLogged_on
            {
               Send(self,@MsgSendUser,#message_rsc=player_haunted_off);
            }

            Send(self,@SetPlayerFlag,#flag=PFLAG_HAUNTED,#value=FALSE);
         }
      }

      % Only do this stuff if the cost of death is not zero.
      if piDeathCost > 0
      {
         if NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_TUTORIAL)
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
         {
            piDeathCost = piDeathCost / 3;
         }
         else
         {
            % If you're not new, chance to lose a hp!
            if random(1,100) <= piDeathCost
            {
               Send(self,@GainBaseMaxHealth,#amount=-1);
               bLostHealth = TRUE;
            }
         }
      }

      if Send(self,@CheckLog) 
      {
         if bLostHealth
         {   
            Debug("LOG:  ",vrName," died, lost a health point: ",
                  piMax_health,pibase_max_health,"Death Cost = ",piDeathCost);
         }
         else
         {
            Debug("LOG:  ",vrName," died, but made death cost check: ",
                  piDeathCost);
         }
      }

      % Remove from guild if now under min HP
      if piBase_max_health < PKILL_ENABLE_HP
      {
         Send(self, @QuitGuild);
      }
   

      % Lose some skill or spell proficiency.

      % Murderers get hit harder.
      if Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
      {
         iAmount = -2;
      } 
      else 
      {
         iAmount = -1;
      }
    
      for i in plSpells
      {
         if Send(self,@DecodeSpellAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSpellAbility,#spell_num=Send(self,@DecodeSpellNum,#compound=i),
                 #amount=iAmount);
         }
      }

      for i in plSkills
      {
         if Send(self,@DecodeSkillAbility,#compound=i) > 5
            AND random(1,100) > Send(self,@GetStamina)
            AND random(1,100) < piDeathCost
         {
            Send(self,@ChangeSkillAbility,#skill_num=Send(self,@DecodeSpellNum,#compound=i),
                 #amount=iAmount);
         }
      }

      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=1);
         Send(self,@ToCliStats,#group=2);
         Send(self,@ToCliStats,#group=3);
         Send(self,@ToCliStats,#group=4);
      }

      Debug("Player ",Send(self,@GetTrueName),self," took death penalties of ",
            piDeathCost," percent.");

      piDeathCost = 0;

      return;
   }

   SetDeathCost(DeathCost = $, bOverride = FALSE)
   {
      % Don't raise the cost of death, unless we want to override it.
      if DeathCost < piDeathCost
         OR bOverride
      {
         piDeathCost = DeathCost;
      }
      
      return;
   }

   GetDeathCost()
   {
      return piDeathCost;
   }

   CreateCorpse(Assassinated=FALSE)
   {
      local inKocatan;

      %  Send current pant/shirt color to body only if they both use the new two-color xlats
      %        otherwise, Send default colors
      inKocatan = FALSE;
      if pbLogged_on
      {
         if Send(poOwner,@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }
      else
      {
         if Send(Send(SYS,@FindRoomByNum,#num=Send(self,@GetSaveRoom)),@GetRegion) = RID_KOCATAN
         {
            inKocatan = TRUE;
         }
      }

      if Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetBodyTranslation))
         AND Send(sys,@IsTwoColorXLAT,#xlat=Send(self,@GetLegsTranslation))
      {
         if piGender = GENDER_MALE
         {
            % male, current colors
            return Create(&DeadBody,#icon=player_dead_male_icona_rsc,
                          #name=player_dead_male_name_rsc,
                          #playername=vrName,
                          #good=(piKarma>0),
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_male_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan,#DearlyDeparted=self);
         }
         else
         {
            % female, current colors
            return Create(&DeadBody,#icon=player_dead_female_icona_rsc,
                          #name=player_dead_female_name_rsc,
                          #playername=vrName,
                          #good=(piKarma>0),
                          #assassinated=Assassinated,
                          #PlayerBodyOverlay=player_dead_female_iconb_rsc,
                          #BodyTranslation=Send(self,@GetBodyTranslation),
                          #LegsTranslation=Send(self,@GetLegsTranslation),
                          #inKocatan = inKocatan,#DearlyDeparted=self);
         }
      }
      
      if piGender = GENDER_MALE
      {
         % male, default colors
         return Create(&DeadBody,#icon=player_dead_male_icona_rsc,
                       #name=player_dead_male_name_rsc,#playername=vrName,
                       #good=(piKarma>0),#PlayerBodyOverlay=player_dead_male_iconb_rsc,
                       #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                       #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                       #inKocatan = inKocatan,#DearlyDeparted=self);
      }
      % female, default colors
      return Create(&DeadBody,#icon=player_dead_female_icona_rsc,
                    #name=player_dead_female_name_rsc,#playername=vrName,
                    #good=(piKarma>0),#PlayerBodyOverlay=player_dead_female_iconb_rsc,
                    #BodyTranslation=Send(self,@GetDefaultShirtTranslation),
                    #LegsTranslation=Send(self,@GetDefaultPantsTranslation),
                    #inKocatan = inKocatan,#DearlyDeparted=self);
   }

   FreeHands()
   "Attempts to remove all items from hands if possible."
   {
      local i;
      
      for i in plUsing
      {
         if (Send(i,@GetItemUseType) & ITEM_USE_HAND)
            AND Send(i,@ReqUnuse)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }
      
      return;
   }
   
   DoDance()
   {
      local i, iSpace;

      for i in plUsing
      {
         if Send(i,@GetItemUseType) & ITEM_USE_HAND
         {
            Send(self,@MsgSendUser,#message_rsc=player_cant_dance);

            return FALSE;
         }
      }

      if ptRest <> $
      {
         Send(self,@MsgSendUser,#message_rsc=player_cant_dance_resting);

         return FALSE;
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_dance);
      
      piAnimation = PANM_DANCE;
      Send(poOwner,@SomethingChanged,#what=self);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=TRUE,#flagset=2);
      piAnimation = PANM_NONE;

      return;
   }

   StopDancing()
   {
      if Send(poOwner,@CheckRoomFlag,#Flag=ROOM_JIG)
      {
         return;
      }
      
      Send(self,@MsgSendUser,#message_rsc=player_stop_dance);
      Send(self,@SetPlayerFlag,#flag=PFLAG2_DANCING,#value=FALSE,#flagset=2);      
      Send(poOwner,@SomethingChanged,#what=self);
      
      return;
   }

   DoWave()
   "Causes the user do the wave animation, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_wave);

      piAnimation = PANM_WAVE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoFistAttack()
   "Causes the user do the fight animation w/fist, 1st and 3rd person"
   {
      Send(self,@DoWindowOverlayFistAttack);

      piAnimation = PANM_FIST_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoPoint()
   "Causes the user to point, 3rd person only"
   {
      Send(self,@MsgSendUser,#message_rsc=player_point);

      piAnimation = PANM_POINT;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoCast()
   "Causes the user to do spell casting arm, 1st & 3rd person"
   {
      Send(self,@DoWindowOverlayHandGlow);

      piAnimation = PANM_CAST;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoBowFire()
   {
      piAnimation = PANM_BOW_FIRE;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   DoWindowOverlayFistAttack()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0);
         AddPacket(1,ANIMATE_ONCE, 4,175, 2,1, 2,3, 2,0);
         AddPacket(1,0);
    
         SendPacket(poSession);    
      }
      
      return;
   }

   DoWindowOverlayHandGlow()
   {
      local i,iGroup;

      if pbLogged_on
      {
         iGroup = 0;
         for i in plWindow_overlays
         {
            if Send(i,@GetWindowOverlayID) = PWO_RIGHT_HAND
            {  
               % Of right hand overlay already exists, we can't restore it correctly
               %  yet, so just don't change it
               return;
            }
         }
         
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,HS_SE);
         AddPacket(4,PWO_RIGHT_HAND);
         AddPacket(4,player_window_overlay_hand);
         AddPacket(4,0, 4,0);
         AddPacket(1,ANIMATE_ONCE,4,300,2,4,2,6,2,iGroup);
         AddPacket(1,1);
         AddPacket(4,player_window_overlay_glow, 1,HS_RIGHT_HAND,
                   1,ANIMATE_ONCE, 4,300, 2,1, 2,3, 2,0);

         SendPacket(poSession);    
      }
      
      return;
   }


   SetWindowOverlay(what = $)
   "Sends a message to the client about a window overlay, and adds <what> "
   "to plWindow_overlays."
   {
      Send(self,@AddWindowOverlayObject,#what=what);
      Send(self,@ChangeWindowOverlay,#what=what);
      
      return;
   }

   ChangeWindowOverlay(what = $)
   "Things can call this when they have a current window overlay and want "
   "to change it, such as for an attack.  Note--it's NOT verified that it's "
   "in plWindow_overlays."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_OVERLAY);
         AddPacket(1,Send(what,@GetWindowOverlayHotspot));
         AddPacket(4,Send(what,@GetWindowOverlayID)); % supposedly "object id" in client
         AddPacket(4,Send(what,@GetWindowOverlay));
         AddPacket(4,Send(what,@GetName)); % useless field, used to make client parsing easier 
         AddPacket(4,0);
         Send(what,@SendWindowOverlayAnimation);
         Send(what,@SendWindowOverlayOverlays);
    
         SendPacket(poSession);    
      }
      
      return;
   }

   AddWindowOverlayObject(what = $)
   "Adds <what> to plWindow_overlays, in case the user leaves and relogs on"
   {
      local i;

      for i in plWindow_overlays
      {
         if i = what
         {
            return;
         }
      }

      plWindow_overlays = Cons(what,plWindow_overlays);

      return;
   }

   RemoveWindowOverlay(what = $)
   "Removes <what> from plWindow_overlays if it's in there, after updating client."
   {
      Send(self,@ChangeWindowOverlay,#what=what);
      Send(self,@RemoveWindowOverlayObject,#what=what);

      return;
   }

   RemoveWindowOverlayObject(what = $)
   "Removes <what> from plWindow_overlays if it's in there."
   {
      local i;

      for i in plWindow_overlays
      {
         if i = what
         {
            plWindow_overlays = DelListElem(plWindow_overlays,what);
            return;
         }
      }

      return;
   }

   SetOverlay(what = $)
   "Adds <what> to plOverlays, and tells everyone we changed."
   {
      Send(self,@AddOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   RemoveOverlay(what = $)
   "Removes <what> from plOverlays if it's in there, and tells everyone we changed."
   {
      Send(self,@RemoveOverlayObject,#what=what);
      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   AddOverlayObject(what = $)
   "Adds <what> to plOverlays, so we can keep track of whom to call about overlays"
   {
      local i;

      for i in plOverlays
      {
         if i = what
         {
            return;
         }
      }

      plOverlays = Cons(what,plOverlays);

      return;
   }

   RemoveOverlayObject(what = $)
   "Removes <what> from plOverlays if it's in there."
   {
      local i;

      for i in plOverlays
      {
         if i = what
         {
            plOverlays = DelListElem(plOverlays,what);
            
            return;
         }
      }

      return;
   }

   RemoveHair(what = $)
   {
      if what = $
      {
         return;
      }

      poHair_remove = what;
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   ResetHair()
   {
      poHair_remove = $;

      if poOwner
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx | drawfx;
      if poOwner <> $ AND SendSomethingChanged
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   GetPlayerDrawfx()
   {
      return piDrawfx;
   }

   ResetPlayerDrawfx(drawfx = 0, SendSomethingChanged = TRUE)
   {
      piDrawfx = piDrawfx & (FLICKERING_YES | PHASING_YES | FLASHING_YES);
      piDrawfx = piDrawfx | drawfx;
      
      if poOwner <> $ AND SendSomethingChanged
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }
      
      return;
   }

   SetPlayerIcon(what = $,new_icon = $,translation = $, alldone = TRUE)
   "Sets our icon to <new_icon>, and keeps track of <what> to undo when necessary.  "
   "Tells everyone we changed."
   {
      poIcon_set = what;
      vrIcon = new_icon;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_BODY_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   GetPlayerIcon()
   {
      return vrIcon;
   }

   ResetPlayerIcon(alldone=TRUE)
   "Sets our icon to its natural, unarmored state."
   {
      local i;

      poIcon_set = $;
      
      % A player may be wearing something under his armor.
      for i in plUsing
      {
         % Shirt or armor.
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            Send(i,@setIcon);
            return;
         }
      }

      if piGender = GENDER_MALE
      {
         vrIcon = player_male_icon_rsc;
      }
      else
      {
         vrIcon = player_female_icon_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_BODY_MASK;
      piBody_translations = piBody_translations | 
                            (Send(self,@GetDefaultShirtTranslation)*PLAYER_TRANSLATION_BODY_MUL);      

      if poOwner <> $ AND alldone
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerArms(what = $,new_left_arm = $, new_right_arm = $, translation = $, alldone = TRUE)
   "Sets our legs to <new_legs>, and keeps track of <what> to undo when necessary.  "
   "Tells everyone we changed."
   {
      poArms_set = what;
      prleft_Arm = new_left_arm;
      prRight_Arm = new_right_arm;

      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 | (translation * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerArms(alldone = TRUE)
   "Sets our icon to its natural, default-shirted state."
   {
      local iShirt_xlat, i, bFound;
      poArms_set = $;

      bFound = FALSE;
      for i in plUsing
      { 
         if Send(i,@OverrideArms)
         {
            % Gauntlets, probably.
            prRight_arm = Send(i,@GetOverrideRightArm,#who=self);
            prleft_arm = Send(i,@GetOverrideleftArm,#who=self);
            bFound = TRUE;
         }    
      }
      
      if NOT bFound
      {
         if piGender = GENDER_MALE
         {
            prRight_arm = player_Rightarm_a_rsc;
            prLeft_arm = player_leftarm_a_rsc;
         }
         else
         {
            prRight_arm = player_Rightarm_b_rsc;
            prLeft_arm = player_leftarm_b_rsc;
         }
      }
      
      iShirt_xlat = Send(self,@GetDefaultShirtTranslation);         
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_ARMS_MASK;
      piBody_translations2 = piBody_translations2 | (iShirt_xlat * PLAYER_TRANSLATION2_ARMS_MUL);

      if poOwner <> $ AND alldone
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }


   SetPlayerLegs(what = $,new_legs = $,translation = $)
   "Sets our legs to <new_legs>, and keeps track of <what> to undo when necessary.  "
   "Tells everyone we changed."
   {
      poLegs_set = what;
      prLegs = new_legs;

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_LEGS_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   ResetPlayerLegs()
   "Sets our icon to its natural, un-panted state."
   {
      poLegs_set = $;

      if piGender = GENDER_MALE
      {
         prLegs = player_legs_a_rsc;
      }
      else
      {
         prLegs = player_legs_b_rsc;
      }

      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_LEGS_MASK;
      piBody_translations = piBody_translations | 
                            (Send(self,@GetDefaultPantsTranslation) * PLAYER_TRANSLATION_LEGS_MUL); 

      if poOwner <> $
      {      
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetDefaultClothes(pants_color = -1,shirt_color = -1, rand=FALSE, increment = TRUE)
   {   
      local shirt_color_xlat, pants_color_xlat, skin_color, i, bShirt, bLegs, bArms;

      skin_color = Send(self,@GetSkinColor);      
      skin_color = Send(self,@convertskincolortoXLAT,#skin_color = skin_color);

      if rand
      {
         pants_color = random(XLAT_TO_SKIN1, XLAT_TO_SKIN4);
         shirt_color = random(XLAT_TO_ORANGE, XLAT_HIGH_VALUE);
         if shirt_color = XLAT_TO_SKIN4
         {
            shirt_color = XLAT_TO_RED;
         }
         
         shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=shirt_color,#color2=skin_color);
         pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=pants_color,#color2=skin_color);
      }

      else
      {
         if shirt_color = -1
         {
            shirt_color_xlat = Send(self,@GetDefaultShirtTranslation);
         } 
         else
         {
            shirt_color_xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=shirt_color,#color2=skin_color);
         }
      
         if pants_color = -1
         {
            pants_color_xlat = Send(self,@GetDefaultPantsTranslation);
         } 
         else
         {
            pants_color_xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=pants_color,#color2=skin_color);
         }
      }

      piDefault_clothes = (shirt_color_xlat*SHIRT_MUL) | (pants_color_xlat*PANTS_MUL);
      
      bShirt = FALSE;
      bLegs = FALSE;
      bArms = FALSE;
      
      for i in plUsing
      {     
         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
         {
            bArms = TRUE;
         } 

         if Send(i,@GetItemUseType) & ITEM_USE_SHIRT
            OR Send(i,@GetItemUseType) & ITEM_USE_BODY
         {
            % ITEM_USE_BODY is armor
            bShirt = TRUE;
         }

         if Send(i,@GetItemUseType) & ITEM_USE_LEGS
         {
            bLegs = TRUE;
         }
      }
      
      if not bArms
      {
         Send(self,@ResetPlayerArms);
      }
      
      if not bShirt
      {
         Send(self,@ResetPlayerIcon);
      }
      
      if not bLegs
      {
         Send(self,@ResetPlayerLegs);
      }

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;      
   }

   ConvertskincolortoXLAT(Skin_color = 0)
   {
      % since the face translates use a single translate and the body uses
      %  a double translate which has less color values available,
      %  here we map the face translate to a similar body translate.
      if skin_color = PT_BLUE_TO_SKIN1
         OR skin_color = PT_BLUE_TO_SKIN2
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_SKIN3
      {
         return XLAT_TO_SKIN2;
      }

      if skin_color = PT_BLUE_TO_SKIN4
      {
         return XLAT_TO_SKIN4;
      }

      if skin_color = PT_BLUE_TO_GREEN
         OR skin_color = PT_BLUE_TO_YELLOW
      {
         return XLAT_TO_SKIN1;
      }

      if skin_color = PT_BLUE_TO_GRAY
         OR skin_color = PT_BLUE_TO_ASHEN
      {
         return XLAT_TO_GRAY;
      }

      if skin_color = PT_BLEND25YELLOW
         OR skin_color = PT_BLUE_TO_LBLUE
      {
         return XLAT_TO_SKY;
      }

      if skin_color = PT_BLEND25RED
      {
         return XLAT_TO_BLUE;
      }

      if Send(SYS,@IsTwoColorXLAT,#Xlat=skin_color)
      {
         return Send(SYS,@DecodeSecondaryColor,#Xlat=skin_color);
      }

      return XLAT_TO_SKIN1;   
   }

   SetSkinTranslation(translation = $)
   {
      piBody_translations = piBody_translations & ~PLAYER_TRANSLATION_Skin_MASK;
      piBody_translations = piBody_translations | (translation * PLAYER_TRANSLATION_SKIN_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetHairTranslation(translation = $)
   {
      piBody_translations2 = piBody_translations2 & ~PLAYER_TRANSLATION2_HAIR_MASK;
      piBody_translations2 = piBody_translations2 | (translation * PLAYER_TRANSLATION2_HAIR_MUL);

      if poOwner <> $
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   SetPlayerIllusion(what = $)
   "Stores <what> as the object to call back to get our animation and overlays."
   "Tells everyone we changed."
   {
      poIllusion_set = what;

      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetIllusionForm(what = $)
   "Returns what is setting our illusion, if anything is."
   {
      if poIllusion_set = $
      {
         return $;
      }

      return Send(poIllusion_set,@IllusionGetTemplate,#who=self);
   }

   ResetPlayerIllusion()
   "Restores default lighting and DrawFX."
   {
      poIllusion_set = $;

      % Recalculate the flicker flag.
      Send(self,@RecalcFlickerFlag);

      % Reset our drawFX.  Also does the SomethingChanged bit if appropriate.
      Send(self,@ResetPlayerDrawFX);

      return;
   }

   DoAttackSwing()
   {  
      piAnimation = PANM_WEAPON_ATTACK;
      Send(poOwner,@SomethingChanged,#what=self);
      piAnimation = PANM_NONE;

      return;
   }

   GetIcon(trueicon=FALSE)
   {
      % trueicon is set to true anytime you want to know what
      %  a person really looks like.  Good example: statues.

      if poIllusion_set <> $ AND NOT trueicon
      {
         return Send(poIllusion_set,@IllusionGetIcon,#who=self);
      }

      propagate;
   }

   SendAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendAnimation,#who=self,#animation=iAnimation);
         
         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION,1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,2, 2,4, 2,1);
         
         return;
      }
      
      if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,3, 2,4, 2,1);
         
         return;
      }
      
      if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,1200, 2,5, 2,5, 2,1);
         
         return;
      }
      
      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE,4, 150, 2,6, 2,22);
         
         return;
      }

      propagate;
   }

   SendMoveAnimation(iAnimation = $)
   {
      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else 
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $
      {
         Send(poIllusion_set,@IllusionSendMoveAnimation,#who=self);
         
         return;
      }

      if Send(self,@GetBodyTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetBodyTranslation));
      }

      if iAnimation = PANM_DANCE
      {    
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,6, 2,22);
         
         return;
      }

      % use standing torso
      AddPacket(1, ANIMATE_NONE, 2,1);

      return;
   }

   SendMoveOverlays(iAnimation = $)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $ 
      {
         Send(poIllusion_set,@IllusionSendMoveOverlays,#who=self);
         
         return;
      }

      % Player has 7 standard overlays:
      %  right arm, left arm, legs, head, eyes, mouth, nose      
      iOverlays = 7;
      
      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }

      % Which group of arm images do we use?
      iLeft_group = 1;
      iRight_group = 1;

      for i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            % Bend the arm if we have a shield, a bow, or a token.
            if hotspot = HS_LEFT_WEAPON 
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }
      
      AddPacket(1,iOverlays);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      iArms_xlat = Send(self,@GetArmsTranslation);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }
      
      if iLeft_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
         }  
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iLeft_group); 
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);       
      }

      if iRight_group = 1
      {
         if iAnimation = PANM_DANCE
         {
            AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
         }  
         else
         {
            AddPacket(1,ANIMATE_CYCLE, 4,200, 2,2, 2,3);
         }
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }
      
      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
      }  
      else
      {
         AddPacket(1,ANIMATE_CYCLE, 4,100, 2,2, 2,5);
      }

      iSkin_xlat = Send(self,@GetSkinColor);

      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);

      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes,1, HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }

      if poHair_remove = $
      {  
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1); 
      }

      for i in plOverlays
      {
         % Moved all of this to the item kod, since items may now
         %  have more than one overlay.
         Send(i,@SendOverlayInformation,#iAnimation = $);
      }
      
      return;
   }

   SendOverlays(iAnimation=$)
   {
      local i, iOverlays, hotspot, iLeft_group, iRight_group, iSkin_xlat,
            iArms_xlat;

      if iAnimation = $
      {
         if (piFlags2 & PFLAG2_DANCING)
         {
            iAnimation = PANM_DANCE;
         }
         else
         {
            iAnimation = piAnimation;
         }
      }

      if poIllusion_set <> $ and iAnimation <> $
      {
         Send(poIllusion_set,@IllusionSendOverlays,#who=self,
              #animation=iAnimation);
         
         return;
      }


      % Send overlay bitmap info to user.  

      % Player has 7 standard overlays:
      %  right arm, left arm, legs, head, eyes, mouth, nose
      iOverlays = 7;
      
      if poHair_remove = $
      {
         iOverlays = iOverlays + 1;
      }
      
      % Overlay info -- display correct group for animation & action

      iLeft_group = 1;
      iRight_group = 1;
      for i in plOverlays
      {
         iOverlays = iOverlays + Send(i,@GetNumberOverlays,#iAnimation=iAnimation);
         hotspot = Send(i,@GetOverlayHotspot);
         if hotspot = HS_RIGHT_WEAPON
         {
            iRight_group = 17;
         }
         else
         {
            if hotspot = HS_LEFT_WEAPON
               OR hotspot = HS_BOTTOM_BOW
               OR IsClass(i,&Token)
            {
               iLeft_group = 7;
            }
         }
      }

      AddPacket(1, iOverlays);
      iArms_xlat = Send(self,@GetArmsTranslation);

      AddPacket(4,prLeft_arm, 1,HS_LEFT_HAND);
      if iArms_Xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }
      
      if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,8, 2,8, 2,iLeft_group);
      }
      else
      {
         if iAnimation = PANM_FIST_ATTACK
         {
            AddPacket(1,ANIMATE_ONCE, 4,600, 2,5, 2,6, 2,iLeft_group);
         }
         else
         {
            if iAnimation = PANM_BOW_FIRE
            {
               AddPacket(1,ANIMATE_ONCE, 4,1200, 2,9, 2,9, 2,iLeft_group);
            }
            else
            {
               if iAnimation = PANM_WEAPON_ATTACK
               {
                  AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,iLeft_group);
               }  
               else
               {
                  if iAnimation = PANM_DANCE
                  {
                     AddPacket(1,ANIMATE_CYCLE, 4,150, 2,10, 2,26);
                  }  
                  else
                  {
                     AddPacket(1,ANIMATE_NONE,2,iLeft_group);
                  }
               }
            }
         }
      }

      AddPacket(4,prRight_arm, 1,HS_RIGHT_HAND);
      if iArms_xlat <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,iArms_xlat);
      }
      
      if iAnimation = PANM_NONE
      {    
         AddPacket(1,ANIMATE_NONE, 2,iRight_group); 
      }

      if iAnimation = PANM_WAVE
      {
         AddPacket(1,ANIMATE_ONCE, 4,100, 2,7, 2,10, 2,iRight_group);
      }

      if iAnimation = PANM_POINT
      {
         AddPacket(1,ANIMATE_ONCE, 4,700, 2,12, 2,12, 2,iRight_group);
      }
      
      if iAnimation = PANM_CAST
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,11, 2,11, 2,iRight_group);
      }

      if iAnimation = PANM_FIST_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,13, 2,14, 2,iRight_group);
      }

      if iAnimation = PANM_BOW_FIRE
      {
         AddPacket(1,ANIMATE_ONCE, 4,600, 2,15, 2,16, 2,iRight_group);
      }

      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,300, 2,4, 2,6, 2,17);
      }

      if iAnimation = PANM_DANCE
      {
         AddPacket(1,ANIMATE_CYCLE, 4,150, 2,18, 2,34);
      }

      AddPacket(4,prLegs, 1,HS_LEGS);
      if Send(self,@GetLegsTranslation) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,Send(self,@GetLegsTranslation));
      }
      
      if iAnimation = PANM_WEAPON_ATTACK
      {
         AddPacket(1,ANIMATE_ONCE, 4,900, 2,6, 2,6, 2,1);
      }
      else
      {
         if iAnimation = PANM_FIST_ATTACK
         {
            AddPacket(1,ANIMATE_ONCE, 4,1200, 2,6, 2,6, 2,1);
         }
         else
         {
            if iAnimation = PANM_BOW_FIRE
            {
               AddPacket(1,ANIMATE_ONCE, 4,1200, 2,7, 2,7, 2,1);
            }
            else
            {
               if iAnimation = PANM_DANCE
               {
                  AddPacket(1,ANIMATE_CYCLE, 4,150, 2,8, 2,24);
               }
               else
               {
                  AddPacket(1,ANIMATE_NONE, 2,1);
               }
            }
         }
      }

      iSkin_xlat = Send(self,@GetSkinColor);
      AddPacket(4,prHead, 1,HS_HEAD, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                1,ANIMATE_NONE, 2,1);
      % Don't send information about face elements if we're wearing the
      %  shrunken head mask.  See shrnkmsk.kod for details.
%      if prHead <> ShrunkenHeadMask_icon_male_rsc
%         AND prHead <> ShrunkenHeadMask_icon_female_rsc
%      {
         AddPacket(4,prMouth, 1,HS_MOUTH, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prEyes, 1,HS_EYES, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,piAction);
         AddPacket(4,prNose, 1,HS_NOSE, 1,ANIMATE_TRANSLATION, 1,iSkin_xlat,
                   1,ANIMATE_NONE, 2,1);
%      }
      
      if poHair_remove = $
      {  
         AddPacket(4,prToupee, 1,HS_TOUPEE, 1,ANIMATE_TRANSLATION,
                   1,Send(self,@GetHairColor), 1,ANIMATE_NONE, 2,1); 
      }
      
      for i in plOverlays
      {
         Send(i,@SendOverlayInformation,#iAnimation=iAnimation);
      }
      
      return;
   }

   MsgPlayerHitResisted(what = $, resistance = $, target=$, color_rsc = player_hit_color_none)
   "Send a message to the player if the person hit has a resistance"
   "select a message to Send the player if the person hit has a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5)
      {
         if resistance > (3*MAX_RESISTANCE/5)
         {
            rMessage = player_hit_immunity;
         }
         else
         {
            rMessage = player_hit_resisted;
         }
      }

      if resistance <= (MIN_RESISTANCE/5)
      {
         if resistance <= (3*MIN_RESISTANCE/5)
         {
            rMessage = player_hit_anti_immunity;
         }
         else
         {
            rMessage = player_hit_anti_resisted;
         }
      }

      if rMessage <> $
      {
         Send(what,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc,
              #parm2=Send(target,@GetCapDef),#parm3=Send(target,@GetName));
      }

      return;
   }

   MsgPlayerResistsHit(what = $, resistance= $, color_rsc = player_hit_color_none)
   "Send a message to the player if they have a resistance"
   {
      local rMessage;

      if resistance = $
      {
         return;
      }

      rMessage = $;

      if resistance > (MAX_RESISTANCE/5) 
      {
         if resistance > (2*MAX_RESISTANCE/3)
         {
            rMessage = player_immune_to_hit; 
         }
         else
         {
            rMessage = player_resists_hit;
         }
      }

      if resistance < (MIN_RESISTANCE/5)
      {
         if resistance < (2*MIN_RESISTANCE/3)
         {
            rMessage = player_anti_immune_to_hit;
         }
         else 
         {
            rMessage = player_anti_resists_hit;
         }
      }
 
      if rMessage <> $
      {
         Send(self,@MsgSendUser,#message_rsc=rMessage,#parm1=color_rsc);
      }

      return;
   }

   PlayerWasHit(atype = 0, aspell = 0)
   "select a message to Send the player when they are hit"
   {
      if aspell > 0 % do spell attacks first, so flaming swords use the special
      {
         if (aspell&ATCK_SPELL_FIRE) > 0 { return player_was_burned;}
         if (aspell&ATCK_SPELL_SHOCK) > 0 { return player_was_shocked;}
         if (aspell&ATCK_SPELL_COLD) > 0 { return player_was_frozen;}
         if (aspell&ATCK_SPELL_HOLY) > 0 { return player_was_holyhit;}
         if (aspell&ATCK_SPELL_UNHOLY) > 0 { return player_was_unholyhit;}
         if (aspell&ATCK_SPELL_QUAKE) > 0 { return player_was_quaked;}
      }

      if atype > 0   % do weapon attacks (odd ones first).
      {
         if (atype&ATCK_WEAP_BITE) > 0 { return player_was_bitten;}
         if (atype&ATCK_WEAP_CLAW) > 0 { return player_was_clawed;}
         if (atype&ATCK_WEAP_STING) > 0 { return player_was_stung;}
         if (atype&ATCK_WEAP_SLASH) > 0 { return player_was_slashed;}
         if (atype&ATCK_WEAP_BLUDGEON) > 0 { return player_was_bludgeoned;}
         if (atype&ATCK_WEAP_PIERCE) > 0 { return player_was_pierced;}
         if (atype&ATCK_WEAP_THRUST) > 0 { return player_was_thrusted;}

         % Put non-weapon strokes here.
         if (atype&ATCK_WEAP_PUNCH) > 0 {return player_was_punched;}
         if (atype&ATCK_WEAP_KICK) > 0 {return player_was_kicked;}
      }

      return player_was_hit;
   }

   AddPoison(strength = 0, bVigorLoss = TRUE)
   {
      if ptPoison = $
      {    
         ptPoison = CreateTimer(self,@PoisonTimer,10000);
      }
      
      piPoisonStrength = piPoisonStrength + strength;

      if bVigorLoss
      {
         piVigor = piVigor - 20;
         Send(self,@NewVigor);
      }
      
      return;
   }

   RemovePoison(strength = 0)
   {
      piPoisonStrength = piPoisonStrength - strength;
      
      return;
   }

   PoisonTimer()
   {
      ptPoison = $;

      % for safety's sake
      if piPoisonStrength <= 0
      {
         piPoisonStrength = 0;

         return;
      }
      
      if poOwner <> $
      {  
         ptPoison = CreateTimer( self, @PoisonTimer, 10000 );
      }

      if poOwner = $
      {
         return;
      }

      if NOT Send(poOwner,@SafePlayerAttack) OR Send(poOwner,@IsValidTarget,#who=self)
      {
         % Poison only hurts you in the arena if you are a combatant.
         piHealth = piHealth - piPoisonStrength / 1000;
         if piHealth < 1
         {
            piHealth = 1;
         }

         Send(self,@NewHealth);
      }
      
      return;
   }

   AddMight(points = 0, bAbsolute = TRUE)
   "Returns signed change to might (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMight;

      iOrigMight = piMightMod;
      piMightMod = piMightMod + points;
      
      if NOT bAbsolute
      {
         piMightMod = bound(piMightMod,-piMight,(MAXIMUM_STAT-piMight));
      }

      Send(self,@DrawMight);
      
      return piMightMod - iOrigMight;
   }

   AddIntellect(points = 0, bAbsolute = TRUE)
   "Returns signed change to intellect (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigIntellect;

      iOrigIntellect = piIntellectMod;
      piIntellectMod = piIntellectMod + points;
      
      if NOT bAbsolute
      {
         piIntellectMod = bound(piIntellectMod,-piIntellect,(MAXIMUM_STAT-piIntellect));
      }

      Send(self,@DrawIntellect);
      
      return piIntellectMod - iOrigIntellect;
   }

   AddAim(points = 0, bAbsolute = TRUE)
   "Returns signed change to aim (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAim;

      iOrigAim = piAimMod;
      piAimMod = piAimMod + points;
      
      if NOT bAbsolute
      {
         piAimMod = bound(piAimMod,-piAim,(MAXIMUM_STAT-piAim));
      }

      Send(self,@DrawAim);
      
      return piAimMod - iOrigAim;
   }

   AddStamina(points = 0, bAbsolute = TRUE)
   "Returns signed change to stamina (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigStamina;

      iOrigStamina = piStaminaMod;
      piStaminaMod = piStaminaMod + points;
      
      if NOT bAbsolute
      {
         piStaminaMod = bound(piStaminaMod,-piStamina,(MAXIMUM_STAT-piStamina));
      }

      Send(self,@DrawStamina);
      
      return piStaminaMod - iOrigStamina;
   }

   AddAgility(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigAgility;

      iOrigAgility = piAgilityMod;
      piAgilityMod = piAgilityMod + points;
      
      if NOT bAbsolute
      {
         piAgilityMod = bound(piAgilityMod,-piAgility,(MAXIMUM_STAT-piAgility));
      }

      Send(self,@DrawAgility);
      
      return piAgilityMod - iOrigAgility;
   }

   AddMysticism(points = 0, bAbsolute = TRUE)
   "Returns signed change to agility (negative means decrease)"
   "If restore = TRUE, ignore the bounds check and add the amount anyway."
   {
      local iOrigMysticism;

      iOrigMysticism = piMysticismMod;
      piMysticismMod = piMysticismMod + points;
      
      if NOT bAbsolute
      {
         piMysticismMod = bound(piMysticismMod,-piMysticism,(MAXIMUM_STAT-piMysticism));
      }

      Send(self,@DrawMysticism);
      Send(self,@ComputeMaxMana);
      
      return piMysticismMod - iOrigMysticism;
   }

   StartResting()
   {      
      if ptRest <> $
      {
         return;
      }
      
      Send(self,@BreakTrance,#event=EVENT_REST);
      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));
      Send(self,@ResetPlayerFlagList);

      return;
   }
   
   IsResting()
   "If there is no rest timer, the player is not resting."
   {
      if ptRest = $
      {
         return FALSE;
      }

      return TRUE;
   }

   GetRestTime()
   {
      local iTime, lJalaInfo, oJalaSpell, iJalaPower;

      iTime = 1000 + (30* (51-Send(self,@getStamina))); 

      if poOwner <> $
      {
         lJalaInfo = Send(poOwner,@GetJalaInfo);

         if lJalaInfo <> $
         {
            oJalaSpell = Nth(lJalaInfo,2);
            if IsClass(oJalaSpell,&Invigorate)
            {
               iJalaPower = Nth(Nth(lJalaInfo,3),3);
               iTime = Send(oJalaSpell,@AdjustVigorTime,#time=iTime,#iSpellPower=iJalaPower);
            }
         }
      }
      
      return iTime;
   }

   RestTimer()
   {
      ptRest = $;
      
      if piVigor < piVigor_rest_threshold
      {
         Send(self,@RestAddExertion,#amount=-10000);
      }
      
      ptRest = CreateTimer(self,@RestTimer,Send(self,@GetRestTime));
      
      return;
   }

   StopResting()
   {
      if ptRest <> $
      {
         DeleteTimer(ptRest);
         ptRest = $;
      }

      Send(self,@ResetPlayerFlagList);
      
      return;
   }

   IsCursedByItems()
   "Returns TRUE if player is using an item that's cursed, FALSE otherwise."
   {
      local i;

      for i in plUsing
      {
         if Send(i,@IsCursed)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   RemoveCurseAllItems()
   "Returns TRUE if the player has a cursed item stripped away, FALSE if not."
   {
      local i, bFound;

      bFound = FALSE;
      for i in plUsing
      {
         if Send(i,@IsCursed)
         {
            Send(self,@UnuseItem,#what=i);
            bFound = TRUE;
         }
      }

      return bFound;
   }
    
   GetArmor()
   "If plUsing holds any armor, return that object."
   {
      local i;
      
      for i in plUsing
      {
         if IsClass(i,&Armor)
         {
            return i;
         }
      }
      
      return $;
   }

   IsDead()
   {
      return (piHealth <= 0);
   }  

   SetTranceFlag()
   {      
      piFlags = piFlags | PFLAG_TRANCE;
      
      return;
   }

   ClearTranceFlag()
   {
      piFlags = piFlags & (~PFLAG_TRANCE);
      
      return;
   }

   SetFlickerFlag()
   {
      piDrawfx = piDrawfx | FLICKERING_YES;
      
      return;
   }

   ClearFlickerFlag()
   {
      piDrawfx = piDrawfx & (~FLICKERING_YES);
      
      return;
   }

   RecalcFlickerFlag()
   { 
      local i;
      
      piDrawfx = piDrawfx & (~FLICKERING_YES);
      for i in plUsing
      {
         if IsClass(i,&Torch)
            OR (IsClass(i,&Weapon) AND Send(i,@HasAttribute,#ItemAtt=WA_GLOWING))
         {
            piDrawfx = piDrawfx | FLICKERING_YES;
            
            return;
         }
      }
      
      return;
   }

   BreakTrance(event = 0, what = $)
   {
      local i, oEnch,state, bFound, oYellNum, oYellRoom;

      bFound = FALSE;
      for i in plEnchantments
      {
         oEnch = Nth(i,2);
         if IsClass(oEnch,&Spell) OR IsClass(oEnch,&Trance)
         {
            state = $;
            if Length(i) >= 3
            {
               state = Nth(i,3);
            }

            Send(oEnch,@BreakTrance,#who=self,#state=state,#event=event,#what=what);
            bFound = TRUE;
         }
      }

      if event = EVENT_NEWOWNER
      {
         for oYellNum in Send(poOwner,@GetYellZone)
         {
            oYellRoom = Send(SYS,@FindRoomByNum,#num=oYellNum);
            if Send(oYellRoom,@BreakTrance,#who=self)
            {
               bFound = TRUE;
               
               break;
            }
         }
      }
      
      if Send(poOwner,@BreakTrance,#who=self,#event=event)
      {
         bFound = TRUE;
      }
      
      return bFound;
   }

   RecalcBulkAndWeight()
   {
      local i;

      piBulk_hold = 0;
      piWeight_hold = 0;

      for i in plPassive
      {
         piBulk_hold = piBulk_hold + Send(i,@GetBulk);
         piWeight_hold = piWeight_hold + Send(i,@GetWeight);
      }

      for i in plActive
      {
         piBulk_hold = piBulk_hold + Send(i,@GetBulk);
         piWeight_hold = piWeight_hold + Send(i,@GetWeight);
      }

      return;
   }

   RecalcLight()
   {
      local i, iLight, iState, oWeapon, oItemAtt;

      % TODO: Make this into a general check.

      % Default base value
      iLight = 5;       

      % Torch, Amulet
      for i in plUsing
      {
         if IsClass(i,&Torch)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }

         if IsClass(i,&ShadowAmulet)
         {
            iLight = iLight + Send(i,@GetLightEffect);
         }
      }
      
      iState = Send(self,@GetEnchantedState,
                    #what=Send(SYS,@FindSpellByNum,#num=SID_NIGHTVISION));
      if iState <> $
      {
         iLight = iLight + iState;
      }

      % Glowing weapons?
      oWeapon = Send(self,@LookupPlayerWeapon);
      if oWeapon <> $
      {
         iState = Send(oWeapon,@GetAttributeData,#ItemAtt=WA_GLOWING);
         if iState <> $
         {
            iLight = iLight + Nth(iState,3);
         }
      }

      if piLight <> iLight
      {
         Debug("Player ",Send(self,@GetName)," had wrong light value ",piLight,
               ".  Setting it to ",iLight);
         piLight = iLight;
         Send(self,@NewLight);
      }

      return;
   }

   GetPlayerLightLevel()
   "Calls RecalcLight and returns the light level."
   {
      Send(self,@RecalcLight);

      % This should be accurate after calling RecalcLight.
      return piLight;
   }

   UnuseAllItems()
   {
      local i;
      for i in plUsing
      {
         Send(self,@UnuseItem,#what=i,#Recalibrate=TRUE);
      }
      
      if plUsing <> $
      {
         plUsing = $;
      }
      
      return Send(SYS,@GetSuccessRsc);
   }

   RecalibratePlayer()
   {
      local i, bSoldier, iAmount;

      bSoldier = FALSE;
      if Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         bSoldier = TRUE;
      }

      Send(self,@UnuseAllItems);
      Send(self,@RemoveAllEnchantments);
      Send(self,@RecalcBulkAndWeight);
      Send(self,@ResetPlayerFlagList);

      if ptSecondWind <> $
      {
         DeleteTimer(ptSecondWind);
         ptSecondWind = $;
      }

      iAmount = 80 + ((Send(self,@GetSkillAbility,#Skill_num=SKID_SECOND_WIND) + 1) / 5);
      Send(self,@SetVigorRestThreshold,#amount=iAmount);

      % All attack modifiers should be a room enchantment, a personal enchantment
      %  or something they are wearing.  If one still exists, bug.  This is also
      %  true for defense modifiers and resistances.
      if plAttack_modifiers <> $
      {
         for i in plAttack_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had attmod",Send(i,@GetName));
         }
         
         plAttack_modifiers = $;
      }
      
      if plDefense_modifiers <> $
      {
         for i in plDefense_modifiers
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had defmods",Send(i,@GetName));
         }
         
         plDefense_modifiers = $;
      }
      
      if plResistances <> $
      {
         for i in plResistances
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had resistance",first(i),Nth(i,2));
         }
         
         plResistances = $;
      }

      piStomach = 50;
      piTimeLastStomachUpdate = GetTime();
      piKill_count_decay = bound(piKill_count_decay,0,$);

      if plEnchantments <> $
      {
         for i in plEnchantments
         {
            Debug("Recalibrating: player",Send(self,@GetTrueName),self,
                  "still had enchantments",Send(Nth(i,2),@GetName));
         }
         
         plEnchantments = $;
      }
      
      if piLight <> 5
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "had bad light value",piLight,"after being stripped!");
         piLight = 5;
      }
      
      if piMax_health <> piBase_max_health
      {
         Debug("Recalibrating: player",Send(self,@GetTrueName),self,
               "with max health",piMax_health,"did not match Base Max Health",
               piBase_max_health);
         piMax_health = piBase_max_health;      
      }
      
      Send(self,@ComputeMaxMana);
      
      if piDrawfx <> 0
      {
         Debug("Recalibrating: Player",Send(self,@GetTrueName),
               "with piDrawFX was equal to",piDrawFX,"instead of 0.");
         piDrawFX = 0;
      }
      
      if poIllusion_set <> $
      {
         Debug("recalibrating: Player",Send(self,@GetTrueName),
               "with illusion_set not set to $!");
         poIllusion_set = $;
      }
      
      if poGuild <> $ AND NOT Send(poGuild,@IsMember,#who=self)
      {
         Debug("Player",Send(self,@GetTrueName),"points to guild",
               Send(poGuild,@GetName)," but guild doesn't point to player!");
      }
      
      % Reset our modifiers
      Send(self,@ZeroMods);

      if bSoldier
      {
         for i in plPassive
         {
            if IsClass(i,&SoldierShield)
            {
               Send(self,@TryUseItem,#what=i);
            }
         }
      }

      % Reset death costs to 0.
      piDeathCost = 0;

      return Send(SYS,@GetSuccessRsc);
   }

   GetBulkMax()
   {
      return viBulk_hold_max + (Send(self,@GetMight) * 20);
   }

   GetWeightMax()
   {
      return viWeight_hold_max + (Send(self,@GetMight) * 20);
   }

   CountKnownAtLevel(school=$,level=$)
   {
      local i, count, nSID, nObj;

      count = 0;
      for i in plSkills
      {
         nSID = Send(self,@DecodeSkillNum,#compound=i);
         nObj = Send(SYS,@FindSkillByNum,#num=nSID);
         
         if nObj = $
         {
            continue;
         }
         
         % Is this in the same school?
         if Send(nObj,@GetSchool) = school
            AND Send(nobj,@GetLevel) = level
         {
            count = count + 1;
         }
      }
      for i in plSpells
      {
         nSID = Send(self,@DecodeSpellNum,#compound=i);
         nObj = Send(SYS,@FindSpellByNum,#num=nSID);
         
         if nObj = $
         {
            continue;
         }
         
         % Is this in the same school?
         if (Send(nObj,@GetSchool) = school)
            and (Send(nobj,@GetLevel)) = level
         {
            count = count + 1;
         }
      }

      return count;
   }

   PlayerCanLearn(spell_num=0,skill_num=0,scryer=$)
   "New routine as of 14 June 97.  Intended to allow for more schools, odd numbers of spells at "
   "a spell level and easier understanding."
   "The proverbial trick is that players have to know WHY they aren't learning.  For example, "
   "if a player can't learn because he has too many competing schools, he needs to know that."    
   {      
      local bSkill, obj, level, school, division, iHave, prev_level,
            iSamediv, iOtherdiv, aHigh, bHigh, cHigh, iBase, i, temp,
            nObj, nSID, index, iNeed, nSchool, nLevel, msg, bKnowOne,
            iWeapon, iKraanan, iShalille, iQor, iFaren, iRiija, iJala, iPoints;

      % Phase one.  Assert our data.  Be sure we have been fed a valid spell
      %  and skill num for a spell item that actually exists.
      if spell_num = 0
      {    
         if skill_num = 0   
         {
            Debug("No data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }  
         else 
         {
            bSkill = TRUE;
            obj = Send(SYS,@FindSkillByNum,#num=skill_num);
         }
      }
      else
      {
         if skill_num <> 0  
         {
            Debug("Too much data given to playercanlearn!");
            return PLAYER_LEARN_ERROR;
         }  
         else
         {
            bSkill = FALSE;
            obj = Send(SYS,@FindSpellByNum,#num=spell_num);
         }
      }
      if obj = $
      {  
         Debug("Fed a spell number for a spell that does not exist in the "
               "system.");

         return PLAYER_LEARN_ERROR; 
      }
      
      if NOT Send(obj,@IsAccessible)      
      {
         % Sacred Haven server.
         return PLAYER_LEARN_ERROR;     
      }
      
      if IsClass(obj,&Spell) AND NOT Send(obj,@IsEnabled)
      {
         % Spell is temporarily disabled.
         return PLAYER_LEARN_ERROR;     
      }

      % Phase two:  get the hard data.
      level = Send(obj,@GetLevel);
      school = Send(obj,@GetSchool);
      division = Send(obj,@GetDivision);      
                  
      % Phase three.  We begin to find our need.  Start by finding out how many
      %  spells exist at ALL at that level.  While we are going through the spell
      %  skill list, count the spells/skills that count towards our total.  Note
      %  that we only want the top three spells/skills at that school and level.

      bKnowOne = FALSE;

      % Check to see if they have any spells of the next level.
      %  If so, let them buy any spells they want.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level+1);
      if iHave > 0
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % See how many spells they have at this level.
      iHave = Send(self,@CountKnownAtLevel,#school=school,#level=level);
      if iHave > 0
      {
         % For level 3 or higher, they can learn if they have another spell in that school
         % and level. If they have two spells at a lower level, they need 2 or more
         % spells in that school or level.
         % This prevents people getting all level 2 spells fresh out of character creation.
         if level > 2
            OR iHave >= 2
         {
            return PLAYER_LEARN_SUCCESS;
         }

         % Flag it so we know that they already have a spell in that level.
         bKnowOne = TRUE;
      }

      if level > 1
      {
         prev_level = Send(SYS,@GetNumAtLevel,#school=school,#level=level-1);
      }
      else
      {
         prev_level = 0;
      }

      aHigh = 0; bHigh = 0; cHigh = 0;

      iWeapon = 0;
      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      
      for i in plSkills
      {
         nSID=Send(self,@DecodeSkillNum,#compound=i);
         nobj=Send(SYS,@FindSkillByNum,#num=nSID);
         
         if nobj = $ 
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }
         
         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }

         nLevel = Send(nobj,@GetLevel);
    
         % Is this in the same school at level N-1?
         if school=Send(nobj,@GetSchool) AND (level-1) = (nLevel)
         {
            index = Send(self,@DecodeSkillAbility,#compound=i);
            if index > aHigh
            {
               temp = aHigh;
               aHigh = index;
               index = temp;
            }
            
            if index > bHigh
            {
               temp = bHigh;
               bHigh = index;
               index = temp;
            }
            
            if index > cHigh
            {
               cHigh = index;
            }
         }
         
         if nLevel > iWeapon
         {
            iWeapon = nLevel;
         }
      }
         
      for i in plSpells
      {
         nSID=Send(self,@DecodeSpellNum,#compound=i);
         nobj=Send(SYS,@FindSpellByNum,#num=nSID);
         
         if nobj = $ 
         {
            Debug("bad data in spell list!");

            return PLAYER_LEARN_ERROR;
         }

         nSchool = Send(nobj,@GetSchool);
         nLevel = Send(nobj,@GetLevel);

         if (not IsClass(nobj,&Spell)) OR (nLevel> 10)
         {
            continue;
         }
         
         if nobj = obj
         {
            return PLAYER_LEARN_ALREADY;
         }
         
         if nSchool = SS_DM_COMMAND
         {
            continue;
         }

         % Is this in the same school at level N-1?
         if school = nSchool AND (level-1) = (nlevel)
         {
            index = Send(self,@DecodeSpellAbility,#compound=i);
            
            if index > aHigh
            {
               temp = aHigh; aHigh = index; index = temp;
            }
            
            if index > bHigh
            {
               temp = bHigh; bHigh = index; index = temp;
            }
            
            if index > cHigh
            {
               cHigh = index;
            }
         }

         if NOT IsClass(nobj,&Blink)  % DON'T COUNT BLINK!
         {
            if nSchool = SS_KRAANAN
               AND nLevel > iKraanan
            {
               iKraanan = nLevel;
            }
            
            if nSchool = SS_SHALILLE
               AND nLevel > iShalille
            {
               iShalille = nLevel;
            }
            
            if nSchool = SS_QOR
               AND nLevel > iQor
            {
               iQor = nLevel;
            }
            
            if nSchool = SS_FAREN
               AND nLevel > iFaren
            {
               iFaren = nLevel;
            }
            
            if nSchool = SS_RIIJA
               AND nLevel > iRiija
            {
               iRiija = nLevel;
            }
            
            if nSchool = SS_JALA
               AND nLevel > iJala
            {
               iJala = nLevel;
            }
         }
      }

      if level > 1
      {
         % Only top three matter in the math.
         iHave = aHigh + bHigh + cHigh;
      }
      else
      {
         % You always have the "max" for level 1
         iHave = (3 * 99);
      }

      % Do easy checks to prevent unnecessary math.  
      % Keep these checks here so they are of lower precedence than
      %   the 'you already have this spell' check.
      
      if NOT Send(obj,@KarmaCheck,#who=self)   
      { 
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noKarma,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }
         
         return PLAYER_LEARN_KARMA; 
      }      

      % Player can't learn level this because he knows nothing of
      %  previous level.
      if iHave = 0
      {
         return PLAYER_LEARN_NOBASE;
      }      

      % We have done all the information gathering, so now, lets compute:

      iPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
               + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
               + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
               + Send(SYS,@GetLevelLearnPoints,#level=iQor)
               + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
               + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
               + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      % Okay, we're going into new territory if we don't already know one
      %  spell in the school, so we're increasing the level of our
      %  knowledge.  Add points.
      if not bKnowOne
      {
         iPoints = iPoints + Send(SYS,@GetLevelLearnPoints,#level=level)
                           - Send(SYS,@GetLevelLearnPoints,#level=(level-1));
      }

      % How this oddball equation works: You have a POINTS_SLOPE that determines
      %  how steep the advancement slope is.  A higher slope results in lower
      %  levels requiring less points, but each school level gained counts more
      %  against future learning.  You hit your max when you get to 297 points
      %  (3*99), so when your points equals max points, you've maxxed out.  
      %  Intellect gives you a bonus to learning, currently about 20 points
      %  for 50 Intellect (approximately mastering 2 extra schools)
      iNeed =   (iPoints * POINTS_SLOPE)
              + (297 - (Send(Send(SYS, @GetSettings), @GetMaxLearnPoints) * POINTS_SLOPE))
              - ((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5);

      % NOTE: if you modify the above equation, also modify GivePlayerAllSkills
      %  and GivePlayerAllSpells as needed

      % Bound iNeed to a reasonable low level so people can't just rush in and
      %  get high level with very little work.
      iNeed = bound(iNeed,MIN_NEEDED_TO_ADVANCE,$);
      
      if scryer <> $
      {
         % nSchool will equal how much the intended school's points added.
         if bSkill
         {
            nSchool = iWeapon;
         }
         else
         {
            if school = SS_KRAANAN
            {
               nSchool = iKraanan;
            }

            if school = SS_SHALILLE
            {
               nSchool = iShalille;
            }

            if school = SS_QOR
            {
               nSchool = iQor;
            }

            if school = SS_FAREN
            {
               nSchool = iFaren;
            }

            if school = SS_RIIJA
            {
               nSchool = iRiija;
            }

            if school = SS_JALA
            {
               nSchool = iJala;
            }
         }
         
         % Bring the points back down to the original total, before learning.
         if NOT bKnowOne
         {
            iPoints = iPoints - Send(SYS,@GetLevelLearnPoints,#level=level)
                              + Send(SYS,@GetLevelLearnPoints,#level=(level-1));
         }
         
         Send(scryer,@MsgSendUser,#message_rsc=player_Debug_playercanlearn,
              #parm1=Send(self,@GetName),#parm2=Send(obj,@GetLevel),
              #parm3=Send(obj,@GetSchoolStr),#parm4=iPoints,#parm5=nSchool,
              #parm6=((Send(self,@GetRawIntellect) * 2 * POINTS_SLOPE) / 5),
              #parm7=iNeed,#parm8=iHave);
      }

      % If the previous level has fewer than three spells, help them out.
      if prev_level = 1
      {  
         iNeed= iNeed / 3;
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                 #message_rsc=player_Debug_playercanlearn_scarcity,
                 #parm1=iNeed);
         }
      }
      
      if prev_level = 2
      {  
         iNeed = (iNeed*2)/3;  
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,
                 #message_rsc=player_Debug_playercanlearn_scarcity,
                 #parm1=iNeed);    
         }
      }

      if iHave >= iNeed
      {
         return PLAYER_LEARN_SUCCESS;
      }

      % Okay, at this point, we know that they didn't pass the test.  Now give 
      %  them a good reason why.  Essentially, if they know a lot of other
      %  divisions and it's slowing them down, tell them that.  Otherwise,
      %  be more generic.
      
      % Is it now impossible to actually learn this spell level?  This would
      %  mean that the need is greater than 99% in three of the previous
      %  level's spells, or 297 (most of the time).  Levels with fewer than
      %  three spells are a special instance.
      if iNeed > (99*(bound(prev_level,1,3)))
      {
         if scryer <> $
         {
            Send(scryer,@MsgSendUser,#message_rsc=player_Debug_noway,
                 #parm1=Send(self,@GetTrueName),#parm2=Send(obj,@GetName));
         }

         return PLAYER_LEARN_IMPOSSIBLE;
      }

      % Return info in this format (base 10):  xxxy, where xxx is the number
      %  of spell or skill points they need, and y is the reason why they
      %  failed.  Only condition is "not enough points".
      return ((10*(iNeed-iHave))+PLAYER_LEARN_BASE);
   }

   GetTotalLearnPoints(except = $)
   {
      local iSpell, iSID, oSpellObj, iSchool, iLevel, iKraanan, iShalille, iQor, iFaren,
            iRiija, iJala, iWeapon, iTotalLearnPoints;

      iKraanan = 0;
      iShalille = 0;
      iQor = 0;
      iFaren = 0;
      iRiija = 0;
      iJala = 0;
      iWeapon = 0;
            
      for iSpell in plSpells
      {
         iSID = Send(self,@DecodeSpellNum,#compound=iSpell);
         oSpellObj = Send(SYS,@FindSpellByNum,#num=iSID);

         iSchool = Send(oSpellObj,@GetSchool);
         iLevel = Send(oSpellObj,@GetLevel);

         if NOT IsClass(oSpellObj,&Blink)  % DON'T COUNT BLINK!
            AND iSchool <> SS_DM_COMMAND
            AND except <> iSchool
         {
            if iSchool = SS_KRAANAN
               AND iLevel > iKraanan
            {
               iKraanan = iLevel;
            }
         
            if iSchool = SS_SHALILLE
               AND iLevel > iShalille
            {
               iShalille = iLevel;
            }
            
            if iSchool = SS_QOR
               AND iLevel > iQor
            {
               iQor = iLevel;
            }
            
            if iSchool = SS_FAREN
               AND iLevel > iFaren
            {
               iFaren = iLevel;
            }
            
            if iSchool = SS_RIIJA
               AND iLevel > iRiija
            {
               iRiija = iLevel;
            }
            
            if iSchool = SS_JALA
               AND iLevel > iJala
            {
               iJala = iLevel;
            }
         }
      }

      if except <> SKS_FENCING
      {
         for iSpell in plSkills
         {
            iSID = Send(self,@DecodeSkillNum,#compound=iSpell);
            oSpellObj = Send(SYS,@FindSkillByNum,#num=iSID);

            iLevel = Send(oSpellObj,@GetLevel);

            if iLevel > iWeapon
               AND iLevel < 50       % Catch DM only skills
            {
               iWeapon = iLevel;
            }
         }
      }

      iTotalLearnPoints =  Send(SYS,@GetLevelLearnPoints,#level=iWeapon)
                         + Send(SYS,@GetLevelLearnPoints,#level=iKraanan)
                         + Send(SYS,@GetLevelLearnPoints,#level=iShalille)
                         + Send(SYS,@GetLevelLearnPoints,#level=iQor)
                         + Send(SYS,@GetLevelLearnPoints,#level=iFaren)
                         + Send(SYS,@GetLevelLearnPoints,#level=iRiija)
                         + Send(SYS,@GetLevelLearnPoints,#level=iJala);

      return iTotalLearnPoints;
   }

   EvaluatePKStatus(dbug=FALSE)
   "This should always be run AFTER the player undergoes whatever changes "
   "(i.e. quits a guild or drops below 30 health).  Also, take steps to ensure "
   "it is not run immediately prior to death."
   {
      local i, ass_game;

      if Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_LOCK)
      {
         return FALSE;
      }
      
      if Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
      {
         if poGuild = $ AND piBase_Max_health < PKILL_ENABLE_HP
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         {
            ass_game = Send(SYS,@GetAssassinGame);
            if Send(ass_game,@IsCombatant,#who=self)
            {
               Send(self,@MsgSendUser,#message_rsc=Player_dagger_shatters);
               Send(ass_game,@RemoveFromGame,#who=self,#RemoveFromRecords = FALSE);
            }

            Send(self,@MsgSendUser,#message_rsc=player_regain_angel);
            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
            Send(self,@PlayerIsIntriguing);
         }
      }
      else
      {
         if poGuild <> $ OR piBase_Max_health >= PKILL_ENABLE_HP
            OR Send(self,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
            OR Send(self,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
         {
            if Send(SYS,@IsPKAllowed)
            {
               % Happylanders don't get 'vulnerable' message.
               Send(self,@MsgSendUser,#message_rsc=player_no_angel);
            }

            % Once you've become killable, you no longer get tutorial messages
            %  and bonuses.  You also lose your newbie string.
            Send(self,@SetPlayerFlag,#flag=PFLAG_TUTORIAL,#value=TRUE);
            if psHonor <> $ AND StringEqual(psHonor,player_newbie_honor_string)
            {
               Send(self,@SetHonorString);
            }
            
            Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);
            if dbug = TRUE
            {
               Debug("Someone with less than 30 health managed to guild or "
                     "outlaw",self);
            }
         }
      }
      
      return;
   }

   PKillEnable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      if Send(SYS,@IsPKAllowed)
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_angel);
      }
      
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=TRUE);
      
      return Send(SYS,@GetSuccessRsc);
   }

   PkillDisable()
   "This will ALWAYS ignore the checks and ALWAYS sets the flag."
   "Made to be used ONLY from admin mode."
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_ENABLE,#value=FALSE);
      
      return Send(SYS,@GetSuccessRsc);
   }

   % Note: a player with PKILL_ENABLE set will have it reset at will if 
   %  an event naturally causes it to.  If you want to not have this change,
   %  then call PkillLock below.  This will ensure that the status of
   %  PKILL_ENABLE will never change, with the exception of a suicide.

   PkillLock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=TRUE);
      
      return Send(SYS,@GetSuccessRsc);
   }

   PkillUnlock()
   {
      Send(self,@SetPlayerFlag,#flag=PFLAG_PKILL_LOCK,#value=FALSE);

      return Send(SYS,@GetSuccessRsc);
   }

   ResetFaction(faction = FACTION_NEUTRAL)
   {
      local oSoldierShield;
      
      if faction < FACTION_NEUTRAL OR faction > FACTION_MAX
      {
         return FALSE;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      if oSoldierShield <> $
         AND faction <> Send(oSoldierShield,@GetFaction)
      {
         Send(oSoldierShield,@LostFaction);
      }

      piFaction = faction;

      return TRUE;
   }
   
   GetFaction()
   {
      return piFaction;
   }

   % Need to be able to keep track of their service...
   % When players join, and subsequently log on, the updated time gets set and
   % the timer gets started. 
   
   UpdateFactionService(full=False, middle=False, front=False, adjust=True)
   {
      local tyme, oSoldierShield;
      
      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      oSoldierShield = Send(self,@FindUsing,#class=&SoldierShield);

      tyme = GetTime();

      % Don't require new service if the player has been an active soldier.
      if oSoldierShield = $
      {
         piFactionServiceUpdate = piFactionServiceUpdate + tyme - piFactionTimeUpdated;
      }
      else
      {
         % Get rid of warnings.
         if piFactionServiceUpdate > FACTION_WARN_TIME
         {
            piFactionServiceUpdate = FACTION_WARN_TIME;
         }
      }
      
      piFactionTimeUpdated = tyme;

      if NOT adjust
      {
         return;
      }

      if full
      {
         piFactionServiceUpdate = 0;
      }
      else 
      {
         if middle
         {
            piFactionServiceUpdate = piFactionServiceUpdate / 2;
         }
         else
         {
            if front
            {
               piFactionServiceUpdate = 3* piFactionServiceUpdate / 4;
            }
         }
      }

      return;
   }

   FactionServiceRoutine(renew=TRUE)
   {
      if ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer = $;
      }
      
      Send(Self,@FactionServiceTimer,#renew=renew);
      
      return;
   }
      
   FactionServiceTimer(renew=TRUE)
   {
      local iHistory;
      
      if ptFactionTimer <> $
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer = $;
      }
      
      if piFaction = FACTION_NEUTRAL
      {
         return;
      }

      Send(Self,@UpdateFactionService,#adjust=FALSE);
      if piFactionServiceUpdate > FACTION_RESIGN_TIME
      {
         Send(self,@ResignFaction);
         
         return;
      }

      if piFactionServiceUpdate > FACTION_WARN_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=player_faction_time);
         %This should be unnecessary (since loyalty quests reschedule themselves at completion),
         %     but is included nonetheless to ensure that if you've been warned, there's a quest waiting for you.
         
         if piFaction = FACTION_PRINCESS
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,#index=QST_ID_PRINCESS_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,#index=QST_ID_PRINCESS_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_PRINCESS_SERVICE);
            }
         }
         
         if piFaction = FACTION_DUKE
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,#index=QST_ID_DUKE_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,#index=QST_ID_DUKE_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_DUKE_SERVICE);
            }
         }
         
         if piFaction = FACTION_REBEL
         {
            Send(Send(SYS,@GetQuestEngine),@ScheduleQuest,#index=QST_ID_REBEL_SERVICE,#override=TRUE);
            iHistory = first(Send(self,@GetQuestHistory,#index=QST_ID_REBEL_SERVICE)) & (~QUEST_HISTORY_MASK);
            if ( iHistory & QUEST_HISTORY_SUCCESS ) <> 0
            {
               Send(self,@ClearOneQuestHistory,#index=QST_ID_REBEL_SERVICE);
            }
         }
      } 

      if renew AND Send(SYS,@GetParliament) <> $
         AND (NOT Send(Send(SYS,@GetParliament),@IsShutdown))
      {
         ptFactionTimer = CreateTimer(self,@FactionServiceTimer,FACTION_UPDATE_TIME);
      }
      
      return;
   }

   PlayerIsIntriguing()
   "Evaluates player and sets the PFLAG_INTRIGUING"
   {
      local bIntrigue,wasint,i,oParl;
      
      bIntrigue=0;

      oParl=Send(SYS,@GetParliament); 
      if oParl = $
      {
         return FALSE;
      }
      
      wasint = Send(self,@CheckPlayerFlag,#flag=PFLAG_INTRIGUING);

      if wasint AND Send(oParl,@IsShutdown)
      {
         Send(self,@MsgSendUser,#message_rsc=player_intrigue_shut); 
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=False);
         Send(oParl,@UpdateEffects,#who=self);
         if ptFactionTimer<>$
         {
            DeleteTimer(ptFactionTimer);
            ptFactionTimer=$;
         }

         for i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused,#what=self);

               break;
            }
         }
         return FALSE;
      }

      if Send(oParl,@IsShutdown)
      {
         return FALSE;
      }
         
      if Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
         AND (Send(self,@PlayerIsHPIntrigue)
              OR Send(self,@PlayerIsAdept))
      {
         bIntrigue = PFLAG_INTRIGUING;
      }
 
      if wasint <> bIntrigue
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_INTRIGUING,#value=bIntrigue);
      }

      if NOT wasint AND bIntrigue
      {
         if piFactionEffect <> 0
         {
            Debug("NonIntriguing Player",Send(self,@GetName),"had effects "
                  "set:",piFactionEffect);
            piFactionEffect=0;
         }
         
         piFaction = FACTION_NEUTRAL;
         Send(oParl,@UpdateEffects,#who=self);
         Send(oParl,@MovetoFaction,#who=self,#faction=FACTION_NEUTRAL);
         Send(self,@ReceiveNestedMail,#from=intrigue_ambassador,
              #dest_list=[self],#nest_list=[4,player_intrigue_mail]);
      }
      
      if wasint AND NOT bIntrigue
      {
         Send(self,@MsgSendUser,#message_rsc=player_lost_intriguing);
         Send(self,@ResignFaction);
         Send(oParl,@MovetoFaction,#who=self,#faction=(-1));
         for i in plUsing
         {
            if IsClass(i,&Token)
            {
               Send(i,@NewUnused);
               
               break;
            }
         }
      }

      return bIntrigue;
   }

   JoinFaction(new_faction=FACTION_NEUTRAL)
   "Returns true if the joining was a success"
   {
      local factliege,oQuestEngine;
      if NOT Send(Self,@PlayerIsIntriguing)
      {
         return FALSE;
      }
      
      if new_faction <= FACTION_NEUTRAL OR new_faction > FACTION_MAX
      {
         return FALSE;
      }

      if piFaction <> FACTION_NEUTRAL
      {
         return FALSE;
      }

      piFaction = new_faction;
      %increase the max number of loyalty quests by one, and schedule one.
      oQuestEngine = Send(SYS,@GetQuestEngine);
      
      if piFaction = FACTION_PRINCESS
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_PRINCESS_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_PRINCESS_SERVICE),QT_MAX_NUM_ACTIVE)) );
         Send(oQuestEngine,@ScheduleQuest,#index = QST_ID_PRINCESS_SERVICE, #override=TRUE);
      }
      
      if piFaction = FACTION_DUKE
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_DUKE_SERVICE,
              #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                     #index=QST_ID_DUKE_SERVICE),QT_MAX_NUM_ACTIVE)) );
         Send(oQuestEngine,@ScheduleQuest,#index = QST_ID_DUKE_SERVICE, #override=TRUE);
      }
      
      if piFaction = FACTION_REBEL
      {
         Send(oQuestEngine,@SetQuestMaxActive,#index = QST_ID_REBEL_SERVICE,
               #new_max = (1+Nth(Send(oQuestEngine,@GetQuestTemplate,
                                      #index=QST_ID_REBEL_SERVICE),QT_MAX_NUM_ACTIVE)) );
         Send(oQuestEngine,@ScheduleQuest,#index = QST_ID_REBEL_SERVICE, #override=TRUE);
      }
      
      piFactionTimeUpdated = GetTime();
      piFactionServiceUpdate = 0;
      if piFaction <> FACTION_NEUTRAL
      {
         factliege = Send(Send(SYS,@GetParliament),@GetLiege,#faction=piFaction);
      }
                          
      ptFactionTimer = $;
      Send(Self,@FactionServiceTimer);
      Send(Send(SYS,@GetParliament),@MoveToFaction,#who=self,#faction=piFaction);
      Send(Send(SYS,@GetParliament),@UpdateEffects,#who=self);
      Send(self,@MsgSendUser,#message_rsc=player_join_faction,
           #parm1=Send(factliege,@GetDef),#parm2=Send(factliege,@GetName));
           
      return TRUE;
   }

   ResignFaction()
   {
      local numMembers, oQuestEngine, oQuest, oFlagPole;

      oFlagPole = Send(poOwner,@FindHoldingActive,#Class=&Flagpole);
      if oFlagPole <> $ AND Send(oFlagPole,@IsClaimAttemptInProgress)
      {
         if Send(oFlagPole,@GetClaimer) = self
         {
            Send(oFlagPole,@ClaimFailed);
         }
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      if (oQuestEngine = $)
      {
         return;
      }

      if Send(Self,@PlayerIsIntriguing) AND (piFaction<>FACTION_NEUTRAL)
      {
         Send(self,@MsgSendUser,#message_rsc=player_unfactioned);
      }
      
      %decrease the max number of loyalty quests by one
      if piFaction = FACTION_PRINCESS
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_PRINCESS_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,
                 #index=QST_ID_PRINCESS_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of faction members!");
         }
      }
      
      if piFaction = FACTION_DUKE
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_DUKE_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);

         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_DUKE_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of faction members!");
         }
      }
      
      if piFaction = FACTION_REBEL
      {
         oQuest = Send(oQuestEngine,@GetQuestTemplate,
                       #index=QST_ID_REBEL_SERVICE);
         numMembers = Nth(oQuest,QT_MAX_NUM_ACTIVE);
         if numMembers > 0
         {
            Send(oQuestEngine,@SetQuestMaxActive,#index=QST_ID_REBEL_SERVICE,
                 #new_max=(numMembers-1));
         }
         else
         {
            Debug("ResignFaction miscounted number of faction members!");
         }
      }
      
      Send(self,@ResetFaction,#faction=FACTION_NEUTRAL);

      if ptFactionTimer<>$
      {
         DeleteTimer(ptFactionTimer);
         ptFactionTimer=$;
      }
      
      piFactionTimeUpdated = 0;
      piFactionServiceUpdate = 0;
      
      if Send(SYS,@GetParliament) <> $ 
      {
         if Send(self,@PlayerIsIntriguing)
         {
            Send(Send(SYS,@GetParliament),@MoveToFaction,#who=self,#faction=piFaction);
         }
         else 
         {
            Send(Send(SYS,@GetParliament),@MoveToFaction,#who=self,#faction=(-1));
         }
         
         Send(Send(SYS,@GetParliament),@UpdateEffects,#who=self);
      }
      
      return;
   }

   PlayerIsHPIntrigue()
   "If player has over 40hp base."
   {
      return (piBase_Max_health >= INTRIGUE_ENABLE_HP);
   }

   PlayerIsAdept()
   "If player has 5th level spell over the enabling percent, then true"
   {
      local i, sid, ospell;

      for i in plSpells
      {
         sid = abs(i/100);
         ospell = Send(SYS,@FindSpellByNum,#num=sid);
         if IsClass(ospell,&Spell) AND Send(ospell,@GetLevel) = 5
            AND (i mod 100) >= INTRIGUE_ENABLE_SPELL
         {
            return TRUE;
         }
      }
      
      return FALSE;
   }

   CheckTokenInNewRoom(what=$)
   "If we are carrying a token, lets drop it"   
   {
      local i;

      if what = $
         OR NOT ((IsClass(poOwner,&GuildHall)
                 OR IsClass(poOwner,&OutofGrace)))
      {
         return;
      }
      
      for i in plPassive
      {
         if IsClass(i,&Token)
         {
            Send(self,@MsgSendUser,#message_rsc=player_lost_token);
            Send(i,@NewUnused,#where=what); 
         }
      }
      
      return TRUE;
   }

   GetFactionService()
   {
      return piFactionServiceUpdate;
   }

   GetFactionEffect()
   {
      return piFactionEffect;
   }

   SetFactionEffect(effect=0)
   {
      piFactionEffect = effect;
      
      return;
   }

   TokenDeliveryReward(mob=$)
   {
      local tobj,classes;

      classes = Send(Send(SYS,@GetLibrary),@GetQuestRewardList);
      if classes = $
      {
         return;
      }

      if IsClass(mob,&Council)
         OR (IsClass(mob,&Factions) AND Send(mob,@GetFaction) = piFaction)
         OR (IsClass(mob,&ShalillePriestess) AND piFaction = FACTION_NEUTRAL)
      {
         tobj = Create(Nth(classes,Random(1,Length(classes))));
         if Send(self,@ReqNewHold,#what=tobj)
         {
            Send(self,@NewHold,#what=tobj);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                 #string=player_token_reward,#parm1=Send(tobj,@GetDef),
                 #parm2=Send(tobj,@GetName));
         } 
         else
         {
            Send(poOwner,@NewHold,#what=tobj,#new_row=piRow,#new_col=piCol);
            Post(poOwner,@SomeoneSaid,#what=mob,#type=SAY_RESOURCE,
                 #string=player_token_reward_heavy,#parm1=Send(tobj,@GetDef),
                 #parm2=Send(tobj,@GetName));
         }
      }
      
      return;
   }

   GetInstrumentLevel()
   "Returns the power of the instrument we are holding."
   {
      local i, iPower;

      iPower = 0;

      % Search through for the instrument of the highest power.
      %  We could have a necklace and a lute.  Let the lute contribute
      %  its power, rather than the necklace.
      for i in plUsing
      {
         if IsClass(i,&Instrument)
         {
            if Send(i,@GetInstrumentLevel) > iPower
            {
               iPower = Send(i,@GetInstrumentLevel);
            }
         }
      }

      return iPower;
   }

   ZeroMods()
   "Should NOT be called before removing all potential stat-modifying things"
   {
      piMightMod = 0;
      piIntellectMod = 0;
      piMysticismMod = 0;
      piAgilityMod = 0;
      piStaminaMod = 0;
      piAimMod = 0;

      return;
   }

   CheckLog()
   {
      return (Send(self,@CheckPlayerFlag,#flag=PFLAG_LOG));
   }

   DecayPKillCount()
   {
      % 50% chance to reduce the kill count.  This is to eliminate the people
      %  who attempt to exploit this system for gain.
      if random(1,100) > 50
      {
         piKill_count_decay = piKill_count_decay - 1;
         piKill_count_decay = bound(piKill_count_decay,0,$);
      }
     
      return;     
   }

   GetUnjustifiedKills()
   {
      return piKill_count;
   }

   GetDecayedUnjustifiedKills()
   {
      return piKill_count_decay;
   }

   GetJustifiedKills()
   {
      return piJustified_kill_count;
   }
   
   UserReqNewOwner(RID=0)
   {
      local oRoom;
      
      if RID = 0
      {
         return;
      }
      
      oRoom = Send(SYS,@FindRoomByNum,#num=RID);
      if oRoom = $
      {
         Debug("Got an invalid room!");
         return FALSE;
      }
      
      if IsClass(oRoom,&GuildHall)
         AND NOT Send(self,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE)
      {
         Send(self,@MsgSendUser,#message_rsc=player_no_enter);

         return FALSE;
      }
      
      return TRUE;
   }

   GivePlayerAllSpells(school = 0, level = -1, upto = TRUE, iability = 99,
                       override = FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints, iMaxLevel, iMaxLearnPoints;

      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(Send(SYS, @GetSettings), @GetMaxLearnPoints) + 
            (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints + Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;
               
               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      for i in Send(SYS,@GetSpells)
      {
         if not IsClass(i,&Spell)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSpell,#num=Send(i,@GetSpellNum),#iability=iAbility);
            }
         }
      }

      % Set Karma enough for them to cast their highest level spell.
      if school = SS_SHALILLE
      {
         %  Need 10 Karma per spell level (+10 for fudge).
         piKarma = level * 1000;
      }

      if school = SS_QOR
      {
         %  Need -10 Karma per spell level (-10 for fudge).
         piKarma = level * -1000;
      }
      
      return TRUE;
   }
   
   GivePlayerAllSkills(school = 0, level = -1, upto = TRUE, iability = 99, override = FALSE)
   "Used only for testing."
   {
      local i, iStartingLearnPoints, iTotalLearnPoints, iMaxLevel, iMaxLearnPoints;
      
      if level = -1 OR level > 6
      {
         upto = TRUE;
         level = 6;
      }

      % Limit gains by intellect
      if NOT (IsClass(self,&DM) OR override)
      {
         iMaxLevel = 0;
         iMaxLearnPoints = Send(Send(SYS, @GetSettings), @GetMaxLearnPoints) + 
            (Send(self,@GetRawIntellect) * 2) / 5;

         iStartingLearnPoints = Send(self,@GetTotalLearnPoints,#except=school);
         iTotalLearnPoints = iStartingLearnPoints;

         while iMaxLevel < level
         {
            iMaxLevel = iMaxLevel + 1;
            iTotalLearnPoints = iStartingLearnPoints + Send(SYS,@GetLevelLearnPoints,#level=iMaxLevel);

            if iTotalLearnPoints > iMaxLearnPoints
            {
               % Oops!  Trying to learn too much!
               iMaxLevel = iMaxLevel - 1;
               
               break;
            }
         }
      }
      else
      {
         iMaxLevel = level;
      }

      if iMaxLevel = 0
      {
         % nothing to do here
         return FALSE;
      }

      for i in Send(SYS,@GetSkills)
      {
         if not IsClass(i,&Skill)
         {
            continue;
         }

         if school = 0 OR Send(i,@GetSchool) = school
         {
            if iMaxLevel >= Send(i,@Getlevel)
            {
               Send(self,@AddSkill,#num=Send(i,@GetSkillNum),#iability=iAbility);
            }
         }
      }
      
      return TRUE;
   }
   
   StripSpellsOfSchool(school = 0, All = FALSE)
   {
      local i;

      for i in plSpells
      {
         if All OR Send(Send(SYS,@FindSpellByNum,#num=i),@GetSchool) = school
         {
            Send(self,@RemoveSpell,#num=Send(self,@DecodeSpellNum,#compound=i));
         }
      }
      
      return;      
   }

   IsWizard()
   {
      local i, iSpell;
      
      for i in plSpells
      {
         iSpell = Send(self,@DecodeSpellNum,#compound=i);
         if Send(Send(SYS,@FindSpellByNum,#num=iSpell),@GetLevel) = 5
         {
            return TRUE;
         }
      }
      
      return FALSE;     
   }
    
   ClearSpellList()
   {
      plSpells = $;
      return;
   }

   GetMaster()
   {
      return $;
   }

   IsInvisible()
   {
      return Send(self,@CheckPlayerFlag,#flag=PFLAG_INVISIBLE);
   }

   IsShadowForm()
   {
      return (piDrawFX & DRAWFX_BLACK);
   }

   IsMorphed()
   {
      return Send(self,@CheckPlayerFlag,#flag=PFLAG_MORPHED);
   }

   %%% Get Color Routines

   GetSkinColor()
   {
      return (piBody_translations & PLAYER_TRANSLATION_Skin_MASK)/PLAYER_TRANSLATION_Skin_MUL;
   }
   
   GetHairColor()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_HAIR_MASK)/PLAYER_TRANSLATION2_HAIR_MUL;
   }
   
   GetLegsTranslation()
   {
      % This returns the whole translation, including skin color.
      return (piBody_translations & PLAYER_TRANSLATION_LEGS_MASK)/PLAYER_TRANSLATION_LEGS_MUL;
   }

   GetArmsTranslation()
   {
      return (piBody_translations2 & PLAYER_TRANSLATION2_ARMS_MASK)/PLAYER_TRANSLATION2_ARMS_MUL;
   }
   
   GetBodyTranslation()
   {
      % This returns the armor/shirt torso (not arms) color.  note that skin is
      %  included in this, in the case of a low-cut dress, for example.
      return (piBody_translations & PLAYER_TRANSLATION_BODY_MASK)/PLAYER_TRANSLATION_BODY_MUL;
   }

   GetDefaultShirtTranslation()
   "This includes skin tones - important for the arms."
   {
      return ((piDefault_Clothes & SHIRT_MASK) / SHIRT_MUL);
   }

   GetDefaultShirtColor()
   "This does not include skin tones."
   {
      local iXlat;
      
      iXlat = Send(self,@GetDefaultShirtTranslation);
      
      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   GetCurrentShirtColor()
   {
      local i;
      
      for i in plUsing
      {
         if IsClass(i,&shirt)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }
      
      return Send(self,@GetDefaultShirtTranslation);
   }

   GetDefaultPantsTranslation()
   "This includes skin tones."
   {
      return (((piDefault_Clothes & PANTS_MASK) / PANTS_MUL));
   }

   GetDefaultPantsColor()
   "This does not include skin tones."
   {
      local iXlat;
      
      iXlat = Send(self,@GetDefaultPantsTranslation);
      
      return Send(SYS,@DecodePrimaryColor,#Xlat=iXlat);
   }

   SetSkinColor(color = 1)
   {
      local iColor, i, oRoom;

      % Arms (hands) and face are the only default things that need to
      %  have skin colors associated with it.  Other items in use
      %  may need to, though (low cut dress).
      
      Send(self,@SetSkinTranslation,#translation=color);
      iColor = Send(self,@GetDefaultShirtColor);
      Send(self,@SetDefaultClothes,#shirt_color = iColor);
      for i in plUsing
      {
         Send(i,@DoPlayerArt);
      }

      oRoom = Send(self,@GetOwner);
      if oRoom <> $
      {    
         Send(oRoom,@SomethingChanged,#what=self);
      }
      
      return;
   }

   SetHead(head=$)
   {
      if head = $
      {
         return;
      }

      prHead = head;
   
      return;
   }

   SetEyes(eyes=$)
   {
      if eyes = $
      {
         return;
      }

      prEyes = eyes;
   
      return;
   }

   SetNose(Nose=$)
   {
      if Nose = $
      {
         return;
      }

      prNose = Nose;
   
      return;
   }

   SetMouth(Mouth=$)
   {
      if Mouth = $
      {
         return;
      }

      prMouth = Mouth;
   
      return;
   }

   GetHeadRsc()
   {
      return prHead;
   }
   
   GetEyesRsc()
   {
      return prEyes;
   }
   
   GetMouthRsc()
   {
      return prMouth;
   }
   
   GetNoseRsc()
   {
      return prNose;
   }

   GetHairRsc()
   {
      return prToupee;
   }

   GetLeftArmRsc()
   {
      return prLeft_arm;
   }

   GetRightArmRsc()
   {
      return prRight_arm;
   }

   GetLegsRsc()
   {
      return prLegs;
   }

   GetExpression()
   {
      return piAction;
   }

   GetShieldRsc()
   {  
      local i;
      
      for i in plOverlays
      {
         if IsClass(i,&Shield)
         {
            return Send(i,@GetOverlay);
         }
      }
      
      return $;
   }
   
   GetShieldTranslation()
   {  
      local i;
      
      for i in plOverlays
      {
         if IsClass(i,&GuildShield)
         {
            return Send(i,@GetPaletteTranslation);
         }
      }
      
      return 0;
   }

   IsLoggedOn()
   {
      return pbLogged_on;
   }

   ClearQuestHistory()
   "Stubbed here, since variable is defined in user - DOH!"
   "(real function is also in user.kod)"
   {
      return;
   }

   ResetMonsterChasers()
   {
      piMonsterChasers = 0;
      
      return;
   }

   AddToMonsterChasers(level=0)
   {      
      piMonsterChasers = piMonsterChasers + level;
      
      return;
   }

   SubtractFromMonsterChasers(level=0)
   {
      piMonsterChasers = piMonsterChasers - level;
      
      return;
   }

   GetMonsterChasers()
   {
      return piMonsterChasers;
   }

   %
   % Investigative tools.
   %

   SomeoneSaid(what = $,type = $,string = $,parm1 = $,parm2 = $,parm3 = $,parm4 = $,
                                            parm5 = $,parm6 = $,parm7 = $,parm8 = $)
   {
      local oSnoop;

      if type = SAY_NORMAL and what <> self and IsClass(what,&Player)
      {
         oSnoop = Send(self,@FindHolding,#class=&ShrunkenHead);
         if oSnoop <> $
         {
            Send(oSnoop,@SomeoneOverheard,#from=what,#to=self,#string=string);
         }
      }

      if NOT Send(SYS,@IsSuspect,#who=self)
      {
         propagate;
      }

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop = $
      {
         propagate;
      }
      
      if not Send(oSnoop,@IsLoggedOn)
      {
         propagate;
      }

      if (type = SAY_GROUP) or (type = SAY_GROUP_ONE)
      {
         Send(oSnoop,@SomeoneOverheard,#from=what,#to=self,
              #format=player_eavesdrop_str,#string=string);
      }

      propagate;
   }

   UserSayGroup(users = $,string = $,no_tell=False)
   "<no_tell> = True means always Send the 'Sends' message, not 'tells'"
   {
      local oSnoop, user;

      if not Send(SYS,@IsSuspect,#who=self)
      {
         return;
      }

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop = $
      {
         return;
      }
      
      if not Send(oSnoop,@IsLoggedOn)
      {
         return;
      }

      for user in users
      {
         Send(oSnoop,@SomeoneOverheard,#from=self,#to=user,
              #format=player_eavesdrop_str,#string=string);
      }

      return;
   }

   UserSayGuild(users = $,string = $,no_tell=False)
   "<no_tell> = True means always Send the 'Sends' message, not 'tells'"
   {
      local oSnoop, user;

      if not Send(SYS,@IsSuspect,#who=self)
      {
         return;
      }

      oSnoop = Send(SYS,@GetInvestigator);
      if oSnoop = $
      {
         return;
      }
      
      if not Send(oSnoop,@IsLoggedOn)
      {
         return;
      }

      for user in users
      {
         Send(oSnoop,@SomeoneOverheard,#from=self,#to=user,
              #format=player_eavesdrop_str,#string=string);
      }

      return;
   }

   SomeoneOverheard(from=$,to=$,type=$,string=$)
   {
      return;
   }

   RemoveInaccessibleSpells()
   {
      local num, i, oSpell, iability;
      
      for i in plSpells
      {
         num = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=num);
         if NOT Send(oSpell,@IsAccessible)
         {
            iAbility = Send(self,@DecodeSpellAbility,#compound=i);
            Send(self,@RemoveSpell,#num=num);
         }
      }
      
      Send(self,@ToCliStats,#group=3);
      Send(self,@RefigureSchoolsLists,#informlore=TRUE);
      
      return;
   }

   ResetPlayerView()
   {
      AddPacket(1,BP_RESET_VIEW);
      SendPacket(poSession);
      
      return;
   }

   SetPlayerView(what = $, iFlags = 0, iHeight = 0, iLight = 0)
   {
      if what = $
      {
         Send(self,@ResetPlayerView);
      }
      else
      {
         AddPacket(1,BP_SET_VIEW, 4,what, 4,iFlags, 4,iHeight, 1,iLight);
         
         SendPacket(poSession);
      }

      return;
   }

   % Removes the shirt.  Used by the WarEvent event.
   RemoveShirt()
   {
      local i;
      
      for i in plUsing
      {
         if IsClass(i,&Shirt)
            OR IsClass(i,&LightRobe)
            OR IsClass(i,&Robe)
         {
            Send(self,@UnuseItem,#what=i);
         }
      }

      return;
   }
   
   BondItem(what=$)
   {
      if what = $ OR NOT IsClass(what,&Item)
      {
         Debug("Tried to bond to invalid item.");
      }

      if Send(what,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         %  this should only be possible through Admin fiddling
         return Send(SYS,@GetFailureRsc);
      }

      if poBondedItem <> $
      {
         Send(self,@ClearBondedItem);
      }
      
      poBondedItem = what;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@AddtoItem,
           #oItem=poBondedItem,#oPlayer=self);
      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }
      
      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);
      
      return;
   }

   ClearBondedItem()
   {
      local oldBondedItem;

      if ptBondedItemReport <> $
      {
         DeleteTimer(ptBondedItemReport);
         ptBondedItemReport = $;
      }
      
      if poBondedItem = $
      {
         return;
      }

      oldBondedItem = poBondedItem;
      poBondedItem = $;
      Send(Send(SYS,@FindItemAttByNum,#num=IA_BONDED),@RemoveFromItem,
           #oItem=oldBondedItem);
      
      return;
   }
   
   BondedItemReport()
   {
      ptBondedItemReport = $;
      if poBondedItem = $
      {
         Debug("trying to report location with no bonded item!");

         return;
      }
      
      ptBondedItemReport = CreateTimer(self,@BondedItemReport,
                                       BOND_REPORT_INTERVAL);

      Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),
           @BondedItemReport,#BondedItem=poBondedItem,#BondedPlayer=self);

      return;
   }

   IsUndead()
   {
      return Send(self,@IsUsingA,#class=&NecromancerAmulet);
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing "
   "server time."
   {
      local time;

      % Reset our attack timer, a traditional use of this function when attack
      %  time was a timestamp instead of a timer.
      if ptAttackTimer <> $
      {
         DeleteTimer(ptAttackTimer);
         ptAttackTimer = $;
      }

      time = GetTime();
   
      piLastDeathTime = time;
      piGuildRejoinTimestamp = time;
      piLast_restart_time = time;
      piTimeLastStomachUpdate = time;

      return;
   }

   SendLightingInformation()
   {
      if poIllusion_set <> $
      {
         if NOT Send(poIllusion_set,@IllusionGetLightingInformation,#who=self)
         {
            % No lighting information
            propagate;
         }

         return;
      }
      else
      {
         % A bit of a kludge.  Ideally, we should query the objects we are using
         %  to find out if any want to add lighting information to us.
         if (piDrawFX & FLICKERING_YES)
         {
            AddPacket(2,(LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC));
            % 75 out of 255 intensity of light
            AddPacket(1,60);
            % Color
            AddPacket(2,LIGHT_FIRE);

            return;
         }
      }

      propagate;
   }

   AddDonationYear(year = $)
   "Add to the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      local y;

      % Already in the list?
      for y in plDonationYears
      {
         if y = year
         {
            return;
         }
      }

      plDonationYears = Cons(year, plDonationYears);
      return;
   }
   
   RemoveDonationYear(year = $)
   "Remove from the list of years the player has donated to the game. "
   "Meant for use from admin mode only."
   {
      plDonationYears = DelListElem(plDonationYears, year);
      return;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
