% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
User is Player

constants:

   include blakston.khd
   include protocol.khd

   % parameter to ToCliObject

   SHOW_NORMAL = 1
   SHOW_LOOK = 2
   SHOW_INVENTORY = 3
   SHOW_ENCHANTMENT = 4
   SHOW_CHANGE = 5

   EXERTION_PER_MOVE = 2

   GOOD_COLOR = 82
   BAD_COLOR =  83

   % How much wait between suicides?  Curently 10 minutes.
   SUICIDE_REPEAT_TIME = 600 

   % What's the length of the Posting timer check? Currently 30 mins.
   NEWS_POSTING_DELAY = 30 * 60
   % How many times can we Post during the delay?
   NEWS_POSTING_LIMIT = 2
   % how long can news messages be
   NEWS_POSTING_MAX_LENGTH = 4096
   % Max subject length client can handle.
   NEWS_POSTING_MAX_SUBJECT_LENGTH = 50

   % how long a mail message may be (the client currently can;t handle > 4096)
   MAIL_MESSAGE_MAX_LENGTH = 4096
   
   % How long since last login before someone is considered "inactive"?
   %  This is measured in seconds.  Currently 60 days.
   %  This is used because the user objects have no concept of suspended
   %  accounts.
   USER_INACTIVE_TIME = 60 * 60 * 24 * 60

   % What's the "speed" of movement for the client?
   USER_WALKING_SPEED = 25
   USER_RUNNING_SPEED = 50

   % How many packets incoming per second do we allow?
   INCOMING_PACKET_THROTTLE = 20

   % What's the lower threshold for being able to run?  Below this, we can't
   %  run.
   VIGOR_RUN_THRESHOLD = 10

   % Speedhack/cheating detection:
   % What's the maximum number of times we should log a violation?
   MAX_LOGGED_THRESHOLD = 50

resources:

   include user.lkod

   user_name_rsc = "user name"

   user_garbage_collecting = "System is saving; please wait."
   user_garbage_collecting_done = "System save completed; resume play."
   user_saving_wav_rsc = system_save.wav

   user_err_get_unk = "You can't pick up %s%s; it is no longer accessible."
   user_err_get_dist = "You can't pick up %s%s; it's too far away."
   user_disallow_get = "You're unable to pick up %s%s."
   user_got_some = "You can't pick up all the %s."
   user_cant_pickup_item_wav_rsc = player_cannot_carry.wav
   user_disallow_drop = "You are unable to drop %s%s."
   user_err_drop = "You're not holding that."
   user_err_put = "You can't put %s%s in %s%s; %s%s can't hold things!"
   user_disallow_put = "You're unable to put %s%s in %s%s."
   user_err_get_contents = "You can't look inside %s%s!"

   user_err_activate_unk = \
      "You can't activate %s%s; it is no longer accessible."
   user_activate_failed = "You can't activate %s%s."

   user_cap_Someone_string = "Someone"
   user_Someone_string = "someone"
   user_blank_string = ""
   admin_icon_blank = blank.bgf

   user_said_str = "%s says, \"%q~n\""
   user_said_echo_str = "You say, \"%q~n\""
   user_yelled_str = "%s yells, \"%q~n\""
   user_yelled_nearby_str = "You hear %s yelling, \"%q~n\""
   user_yelled_echo_str = "You yell, \"%q~n\""
   user_broadcast_str = "%s broadcasts, \"%q~n\""
   user_broadcast_echo_str = "You broadcast, \"%q~n\""
   user_send_str = "%s sends, \"%q~n\""
   user_send_one_str = "%s tells you, \"%q~n\""
   user_said_resource_str = "%s%s says, \"%s~n\""
   user_emote_str = "%s %q"
   user_echo_str = "%q"

   user_send_echo_str = "You send, \"%q~n\""
   user_send_single_echo_str = "You tell %s, \"%q~n\""

   user_no_respond = \
      "~IDue to your state, this user may not be able to respond to you."

   user_said_str_morphed = "~n%s%s says, \"%q~n\""
   user_yelled_str_morphed = "~n%s%s yells, \"%q~n\""
   user_emote_str_morphed = "~n%s%s %q" 

   user_no_cast = "You find yourself unable to cast a spell."
   user_no_fight = "You find yourself unable to lift your weapon."
   user_cant_mail_to = "Can't mail to nonexistent user %s."
   user_mail_to = "Sending mail."
   user_new_mail = "You have new mail from %s."
   user_new_nested_mail = "You have new mail."
   user_show_mail = "%q"
   user_show_nested_mail = "%s"
   user_logon_one_mail = "You have %i piece of new mail."
   user_logon_many_mail = "You have %i pieces of new mail."
   user_mail_toobig = \
      "Sorry, that message was so large the courier died trying to carry it, "
      "delivery failed."
 
   user_was_killed = \
      "You are dead, poor soul.  Go now, and take revenge on %s%s!"
   user_was_killed_bridge_faith = "Ouch, that last step was a doozy."

   user_is_resting = "You are sitting and resting."
   user_is_standing = "You are standing."

   user_stat_might = "Might"
   user_stat_intellect = "Intellect"
   user_stat_stamina = "Stamina"
   user_stat_agility = "Agility"
   user_stat_mysticism = "Mysticism"
   user_stat_aim = "Aim"
   user_stat_karma = "Karma"
   user_stat_capacity = "Weight Carried"
   user_stat_bulk = "Bulk Carried"
   user_stat_offense = "Offense"
   user_stat_defense = "Defense"
   user_stat_armor = "Armor"
   user_stat_training = "Training Pts"
   user_stat_hpgainchance = exp.bgf
   user_resist_magic = "Magic Resist"
   user_resist_fire = "Fire Resist"
   user_resist_shock = "Shock Resist"
   user_resist_cold = "Cold Resist"
   user_resist_holy = "Holy Resist"
   user_resist_unholy = "Unholy Resist"
   user_resist_acid = "Acid Resist"
   user_resist_quake = "Quake Resist"
   user_resist_nerudite = "Nerudite"
   user_resist_silver = "Silver"
   user_resist_unarmed = "Unarmed"
   user_resist_punch = "Punch"
   user_resist_kick = "Kick"
   user_resist_hunt = "Hunt Sword"
   user_resist_claw = "Claw"
   user_resist_bite = "Bite"
   user_resist_sting = "Sting"
   user_resist_ichor = "Ichor"
   user_resist_weapons = "Weapon Resist"
   user_resist_weapon_nonmagic = "Mundane"
   user_resist_weapon_magic = "Enchanted"
   user_resist_hit = "Hit"
   user_resist_bludgeon = "Bludgeon Resist"
   user_resist_pierce = "Pierce Resist"
   user_resist_thrust = "Thrust Resist"
   user_resist_slash = "Slash Resist"
   user_resist_whip = "Whip"
   
   user_shal_power = "Shal'ille"
   user_qor_power = "Qor"
   user_faren_power = "Faren"
   user_kraanan_power = "Kraanan"
   user_riija_power = "Riija"
   user_jala_power = "Jala"

   user_stat_health = heal.bgf
   user_stat_mana = ankh.bgf
   user_stat_vigor = bolticon.bgf  %stickman.bgf

   user_group_condition = "Condition"
   user_group_stats = "Stats"
   user_group_spells = "Spells"
   user_group_skills = "Skills"
   user_group_quests = "Quests"

   user_active_quests_header = "Active Quests: "
   user_no_active_quests_header = "No Active Quests"
   user_completed_quests_header = "Completed Quests: "
   user_no_completed_quests_header = "No Completed Quests"

   user_got_offer = "You have a trade offer from %s%s."
   user_cant_offer = "You can't offer to %s%s."
   user_cant_offer_arena = \
      "Trading is not permitted in gaming areas such as this."
   user_offer_busy = "%s%s can't deal with you now."
   user_cant_cancel_offer = "You can't cancel a nonexistent offer."
   user_canceled_offer = "%s%s canceled the offer."
   user_cant_counteroffer = "You can't counter a nonexistent offer."
   user_cant_acceptoffer = "You can't accept a nonexistent offer."
   user_dont_have_offer = \
      "Offer invalid, you don't have everything you offered."
   user_dont_have_number_offer = \
      "Offer invalid, you don't have enough of everything you offered."
   user_offer_too_many = "You can't offer that many %s!"
   user_cant_drop_offer = \
      "Realizing %s%s will not be given away, you cancel the offer."
   user_didnt_have_offer = \
      "Offer invalid, %s%s didn't have everything offered."
   user_didnt_drop_offer = \
      "%s%s tries to give you %s%s, but it doesn't seem to want to be given!"
   user_cant_offer_get = \
      "You can't take %s%s from the trade -- it is on the ground."
   user_offer_not_online = "%s%s is not online to accept your offer."
   user_offer_not_here = \
      "You try to offer your goods to %s%s, but %s is no longer here."
   user_couldnt_carry_offer = \
      "%s%s can't carry all the items you have offered."
   user_cant_carry_offer = \
      "You can't carry all the items that %s%s has offered you."
   user_not_item = "You cannot pick that up."

   user_not_have_number = "You don't have that amount of %s to drop."
   user_cant_deal_number = "You can't do anything with %i items."
   user_cant_attack_non_battler = "You can't attack %s%s."
   user_no_say_guild = \
      "You cannot Send a message to your guild, as you do not belong to a "
      "guild."
   user_no_guild_logged_on = "No one else from your guild is logged on."
   user_someone_logon = "~B~U~k[###]~n ~B~vPlease welcome %s."
   user_someone_logoff = "~B~U~k[###]~n ~B~vAu revoir to %s."
   user_guildmate_logon = "~IHail your guildmate %s!"
   user_guildmate_logoff = "~IYour guildmate %s has just departed."

   user_safety_on = \
      "~B~U~k[###]~n ~B~vYour safety is now ~I~gON~n~B:  You can no longer "
      "strike innocents."
   user_safety_off = \
      "~B~U~k[###]~n ~B~vYour safety is now ~B~rOFF~n~B:  Be careful, you are "
      "now able to hurt those around you."
   user_temp_safe_on = \
      "~B~U~k[###]~n ~B~vYou will receive a temporary guardian angel on death."
   user_temp_safe_off = \
      "~B~U~k[###]~n ~B~vYou will no longer receive a temporary guardian "
      "angel on death."
   user_temp_safe_invalid = \
      "~B~U~k[###]~n ~B~vYour guardian angel can no longer protect you."
   user_grouping_on = \
      "~B~U~k[###]~n ~B~vYou will now join builder groups."
   user_grouping_off = \
      "~B~U~k[###]~n ~B~vYou will no longer join builder groups."
   user_autocombine_on = \
      "You decide to combine spell items as you get them."
   user_autocombine_off = \
      "You decide to stop combining spell items as you get them."
   user_autoloot_on = "You decide to pick up treasure as it drops."
   user_autoloot_off = "You stop picking up treasure as it drops."

   user_cant_go = "You are unable to go anywhere."
   user_cant_go_wav_rsc = cant_go_anywhere_louder.wav
   user_blocked_send = "%s is ignoring messages from you."

   user_cant_suicide = \
      "You just can't bear to kill yourself because you have too much to live "
      "for.  You must abdicate the leadership of your guild before you can "
      "commit suicide."

   user_cant_suicide_justicar = \
      "It would be unseemly for such a high official to take his own life!"

   user_cant_suicide_yet = \
      "You can't seem to kill yourself, you feel you've only just begun this "
      "life. Give it a day."

   user_cant_suicide_token = \
      "You can't kill yourself now, not when you're the sacred guardian of a "
      "Meridian token!"

   user_cant_suicide_hp = \
      "You've accomplished much so far in your time here, and you can't quite "
      "stomach the thought of ending your journey now.  If you have a good "
      "reason for suiciding, perhaps one of the Gods will assist you."

   user_cant_suicide_OOG = \
      "Somehow, even though you deserve it, you are unable to bear the "
      "thought of killing yourself now."

   user_no_seller = "You can't buy anything here."

   user_no_guild = "You do not belong to a guild."
   user_no_guild_broke = \
      "Come back when you have enough money to create a guild."
   user_no_guildhall_broke = \
      "Come back when you have enough money to put a payment down on the "
      "guildhall."
   user_duplicate_guildname = \
      "There is already a guild with that name.  Please choose another."
   user_duplicate_guild_username = \
      "Your guild name cannot have the name of a player.  Please choose "
      "another."

   user_couldnt_replace = \
      "You could not be restored to your previous location."

   user_logon = \
      "Welcome to the world of Meridian 59! (type \"help\" to see the manual)."
   user_goto_lastsaferoom = "You have been sent to the last safe place you visited."
   user_goto_safety = "You have been sent to a safe place."
   user_goto_object = "You have been sent to %s%s."
   user_goto_jail = "You have been thrown in the Barloque Jail!"
   user_last_known = "the last known location of "

   user_school_shallile = "School of Shal'ille"
   user_school_qor = "School of Qor"
   user_school_kraanan = "School of Kraanan"
   user_school_faren = "School of Faren"
   user_school_riija = "School of Riija"
   user_school_jala = "School of Jala"
   user_school_dm = "DM spells"

   user_admin_message = "%q"

   user_doesnt_know_stroke = "You do not know how to %s!"
   user_doesnt_know_spell = "You have not yet learned the spell '%s'!"

   user_wave_welcome = welcome.wav
   user_wave_killed = killed.wav

   user_midi_killed = killed.mp3

   user_interface_module = merintr.dll
   user_mailnews_module = mailnews.dll
   user_statchange_module = stats.dll

   user_cant_withdraw = "You can't withdraw anything here!"
   user_cant_withdraw_items = "You can't withdraw items here!"
   user_cant_deposit = "You can't deposit anything here!"
   user_cant_deposit_items = "You can't deposit items here!"
   user_cant_balance = "You can't check any balance here!"

   user_appeal = "%s appeals, \"%q~n\""
   user_first_time_appeal = "~B~U~k[###]~n ~B~v%s has just logged on for the first time."
   user_did_appeal = "You appeal, \"%q~n\""

   user_kill_zone = \
      "Your guardian angel whispers to you, \"I cannot defend you here.\""
   user_angel_rejoins = "Your guardian angel rejoins you."

   user_fumble = "You fumble and drop your %s."     

   user_wait_for_news_posting = \
      "You must wait a while before you can post to a news globe again."
   user_news_squelched = \
      "Your news posting privileges have been revoked."
   user_news_toobig = \
      "WHOA BUDDY!  Take a breath, that message was WAY too big!"
   user_news_subject_toobig = \
      "Your newsglobe subject length was too long."

   user_guild_rsc = "guild"
   user_guildofficer_rsc = "guildofficer"

   user_default_url = "http://openmeridian.org/"

   user_safety_on_wav_rsc = safety_on.wav
   user_safety_off_wav_rsc = safety_off.wav

   % Guild MOTD user say commands.
   user_say_guild_motd = "motd"
   guild_motd_command = "set motd "
   guild_clear_motd_command = "clear motd"

   % Inventory sorting user say commands.
   user_say_inventory = "inventory"
   user_say_inv_sort_clear = "inventory sort clear"
   user_say_inv_sort_report = "inventory sort report"
   user_say_inv_sort_add = "inventory sort add "
   user_say_inv_sort_help = "inventory sort help"
   user_say_inv_sort = "sort inventory"

   % Survival arena user say commands.
   user_say_survival = "survival"
   user_say_start_solo_survival = "start solo survival"
   user_say_start_pub_survival = "start public survival"
   user_say_join_pub_survival = "join public survival"
   user_say_start_guild_survival = "start guild survival"
   user_say_join_guild_survival = "join guild survival"
   % Extra survival arena options for DMs.
   user_say_survival_opt_unnatural = "--unnatural"
   user_say_survival_opt_pvpon = "--pvpon"
   user_say_survival_opt_starthere = "--thisbase"

   guild_survival_too_late = \
      "Your guild is already running a survival room. You will have to wait."
   public_survival_too_late = \
      "A public survival room is already running. You will have to wait."
   
   survival_err_not_safe = \
      "You have to be somewhere safe to join a survival arena!"
   survival_err_no_guild = \
      "You don't have a guild!"
   survival_err_already_guild = \
      "There is already a guild survival arena running."
   survival_err_already_public = \
      "There is already a public survival arena running."
   survival_no_public_rooms = \
      "There are no public survival rooms currently running."
   survival_no_guild_rooms = \
      "Your guild has no survival rooms running at this time."
      
   survival_err_cant_join = \
      "That survival arena has already begun, and you cannot join."

   phased_out_cant_drop = "You can't drop items while phased out of existence."
                               
   user_reagentbag_on = "You start putting new reagents in your bag."
   user_reagentbag_off = "You stop putting new reagents in your bag."
   user_spellpower_on = \
      "You will now see the power at which your spells are cast."
   user_spellpower_off = \
      "You will no longer see the power at which your spells are cast."

   user_logon_delay = \
      "You take a moment to recollect your senses."
   
   inventory_sort_cleared = \
      "Your sort preferences have been cleared."
   inventory_class_added = \
      "You add %s to your sort preferences."
   inventory_sort_no_item = \
      "There is no item or type of item with that name."
   inventory_sort_help = \
      "Say 'inventory sort add scimitar' to add a scimitar, for example, to "
      "your preferences. Any item will work; you may also use item types, "
      "such as weapons, armors, helmets, shields, rings, potions, scrolls, "
      "wands, rods, reagents, ammo, and food. Say 'sort inventory' to "
      "instantly sort your inventory at any time. Say 'inventory sort clear' "
      "to delete your current preferences. Say 'inventory sort report' to "
      "see your current preferences."
   inventory_sort_report_header = \
      "Your inventory will sort with this order:"
   inventory_sort_report = \
      "%s"
   inventory_already_in_list = \
      "That is already in your list."

   user_time_string =  \
   "The time in Meridian is %i:00.  It is the %q day of the year %i."

   user_tell_wav = imp.wav

classvars:

   viIndefinite = ARTICLE_NONE
   viDefinite = ARTICLE_NONE
   viDM = FALSE

properties:

   vrName = user_name_rsc

   piHomeroom

   piLastSafeRoom = $

   plNew_mail = $

   poOffer_who = $
   plOffer_items = $
   pbOffer_OtherAccepted = FALSE

   piSave_room = $
   piSave_row = 0
   piSave_col = 0
   piSave_angle = 0
   piSave_fine_row = 0
   piSave_fine_col = 0

   % default to never logged on
   piLastLoginTime = 0
   % counts total time logged in
   piTimeLoggedIn = 0

   psURL = $

   plQuestHistory = $
   plActiveQuests = $

   piLogoffPenaltyCount = 0

   piTimeNewsPosted = 0
   piNumberOfNewsPosts = 0

   piLastPacketTime = 0
   piPacketsPerSecond = 0

   % The ms tick we received last position update from user
   piLastMoveUpdateTime = 0

   % The ms tick we last drained vigor
   piLastVigorDrainTime = 0

   % This is a token-bucket to limit speedhacking.
   % Moves are accepted unless there is not enough tokens in the bucket left.
   piMovementBucket = 0

   piCheaterLogs = 0

   ptLogonDelayTimer = $

   % What order do you want your inventory sorted in?
   plClassOrderPreferences = $

   % keep track of how much this player triggers flood protection
   piFloodCount = 0

messages:

   Constructor(name = $,icon = $)
   {
      local oRoom,lPos;

      if name <> $
      {
         vrName = name;
      }

      if icon <> $
      {
         vrIcon = icon;
      }

      Send(SYS,@SystemUserCreate,#what=self);

      Send(self,@AdminGoToSafety);

      propagate;
   }

   Delete()
   {
      Send(SYS,@SystemUserDelete,#what=self);

      propagate;
   }

   %%% Naming convention:
   % GetTrueName returns what an object's name IS, regardless of any way that
   %  that is modified.  This is especially important for users, esp mail,
   %  and it should be used for most all cross-server events (such as tells).
   % GetApparentName returns what the player sees in look description boxes and
   %  what other players see over his head.
   % GetName returns the modified version of a name for use in text.  Thus, a 
   %  anonymous player returns 'someone' and a morphed player returns the name
   %  of his morph target.

   GetUserName()
   "This function is now redundant.  However, since the server and/or client "
   "calls this directly, we leave this in."
   {
      return vrName;
   }

   % GetTrueName() - Defined in class above

   GetApparentName()
   "Returns a blank string for look and overhead purposes."
   {
      % Send a blank string if we're anonymous, if we're a blank or if we're
      %  a hidden admin.
      if (piFlags & PFLAG_ANONYMOUS)
         OR vrIcon = admin_icon_blank
         OR (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         return Send(self,@GetBlankName);
      }

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetName,#who=self);
      }

      propagate;
   }

   GetDef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetDef,#who=self);
      }

      propagate;
   }

   GetCapDef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetCapDef,#who=self);
      }

      propagate;
   }

   GetIndef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetIndef,#who=self);
      }

      propagate;
   }

   GetHisHer()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetHisHer,#who=self);
      }

      propagate;
   }

   GetCapIndef()
   {
      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetCapIndef,#who=self);
      }

      propagate;
   }

   GetName(cap=FALSE)
   {
      local rName;

      if (piFlags & PFLAG_MORPHED)
         AND poIllusion_set <> $
      {
         return Send(poIllusion_set,@IllusionGetName,#who=self);
      }

      if (piFlags & PFLAG_ANONYMOUS)
      {
         if cap
         {
            rName = user_cap_someone_string;
         }
         else
         {
            rName = user_someone_string;
         }

         return rName;
      }

      propagate;
   }

   GetUserIcon()
   {
      % Convenience function for the server to send list of char choices
      return vrIcon;
   }

   GetAction()
   {
      return piAction;
   }

   SetAction(action=$)
   "Used to set facial expression."
   {
      if action <> $
         AND action <> piAction
         AND action >= UA_NORMAL
         AND action <= UA_WRY
      {
         piAction = action;

         if poOwner <> $
         {
            Send(poOwner,@SomethingDidAction,#what=self,#action=action);
         }
      }

      return;
   }

   GetBlankName()
   {
      return user_blank_string;
   }

   IsFirstTime()
   {
      return piLastLoginTime = 0;
   }

   GetLastLoginTime()
   "Used by the assassin's game to see if the player is spending enough "
   "time online to remain part of the proceedings."
   {
      return piLastLoginTime;
   }

   IsUserInactive()
   "Returns TRUE if player hasn't logged on in a very long time."
   {
      % Has it been longer since USER_INACTIVE_TIME since we last logged in?
      return ((GetTime() - piLastLoginTime) > USER_INACTIVE_TIME);
   }

   % Returns a running count of player's logged in time, across sessions
   %  Used by quest engine to check how much time a player has spent online
   %  since performing a quest
   GetTimeLoggedIn()
   {
      if piLastLoginTime = 0
      {
         return 0;
      }

      if pbLogged_on
      {
         return (GetTime() - piLastLoginTime + piTimeLoggedIn);
      }

      return piTimeLoggedIn;
   }

   SendFirstTimeAppeal()
   {
      Send(self,@UserAppeal,#first_time=TRUE);

      return;
   }

   FirstLogon()
   "Sets the last login time and sends an appeal "
   "when a new character is created."
   {
      if piLastLoginTime = 0 AND piLast_Restart_Time = 0
      {
         Debug("Sending first time appeal");
         Send(self,@SendFirstTimeAppeal);
      }

      piLastLoginTime = GetTime();

      return;
   }

   UserLogon(session_id = $)
   {
      local i, sGuild, oBRoom, oHRoom;

      poSession = session_id;
      pbLogged_on = TRUE;

      piLastLoginTime = GetTime();
      % Gotta load interface early!
      Send(self,@UserLoadModule,#module=user_interface_module);

      Send(self,@MsgSendUser,#message_rsc=user_logon);

      Send(SYS,@SystemUserLogon,#what=self);

      % Let the user know whether safety is on or off.
      if piPreferences & CF_SAFETY_OFF
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_off);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_on);
      }

      if NOT (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         % Advertise as normally.
         Send(SYS,@SystemUserLogonAdvertise,#what=self);
      }
      else
      {
         % We don't want to be seen, except by admins
         foreach i in Send(SYS,@GetUsersLoggedOn)
         {
            % Only do this for admins
            if IsClass(i,&Admin)
            {
               Send(i,@SomeoneLogon,#what=self);
            }
         }
      }

      Send(self,@ToCliPlayers);

      % Enchantments are told to 'freeze' until a player logs back on.
      %   Must do this before they enter room.
      Send(self,@ReactivateAllEnchantments);

      Send(self,@UserLogonSetPosition);

      if plNew_mail <> $
      {
         if Length(plNew_mail) = 1
         {
            Send(self,@MsgSendUser,#message_rsc=user_logon_one_mail,
                 #parm1=Length(plNew_mail));
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_logon_many_mail,
                 #parm1=Length(plNew_mail));
         }
      }

      Send(self,@ToCliSpellSchools);
      Send(self,@UserLogonHook);

      % Give user the logon delay
      Send(self,@LogonDelay);

      if (poEvilTwin <> $)
      {
         Send(poEvilTwin,@PlaceEvilTwin,#who=self);
      }

      % Update vigor drain time as 'now' so we drain vigor correctly
      piLastVigorDrainTime = GetTickCount();

      oHRoom = $;
      if piHomeroom <> $
      {
         oHRoom = Send(SYS,@FindRoomByNum,#num=abs(piHomeroom));
      }

       if piBound_Room <> $
      {
         oBRoom = Send(SYS,@FindRoomByNum,#num=abs(piBound_Room));
      }
      else
      {
         oBRoom = oHRoom;
      }

      sGuild = $;

      if poGuild <> $
      {  
         sGuild = Send(poGuild,@GetName);

         if Send(poGuild,@GetGuildHall) <> $
         {
            RecordStat(STAT_GUILD, sGuild, Send(Send(poGuild,@GetGuildMaster),@GetName), Send(Send(poGuild,@GetGuildHall),@GetName) );
         }
         else
         {
            RecordStat(STAT_GUILD, sGuild, Send(Send(poGuild,@GetGuildMaster),@GetName), system_blank_resource );
         }
      }

      RecordStat(STAT_PLAYER, poSession, Send(self,@GetTrueName), Send(oHRoom,@GetName), Send(oBRoom,@GetName), 
                  sGuild, Send(self,@GetBaseMaxHealth), piMax_mana, Send(self,@GetRawMight), 
                  Send(self,@GetRawIntellect), Send(self,@GetRawMysticism), Send(self,@GetRawStamina), Send(self,@GetRawAgility), 
                  Send(self,@GetRawAim));

      return;
   }

   LogonDelay()
   {
      local iLogonDelay, oSpell;

      oSpell = Send(SYS,@FindSpellByNum,#num=SID_HOLD);

      if NOT Send(self,@IsEnchanted,#what=oSpell)
         AND NOT Send(poOwner,@CheckDefaultRoomFlag,#flag=ROOM_SAFELOGOFF)
         AND NOT (IsClass(self,&DM) AND Send(self,@PlayerIsImmortal))
      {
         if ptLogonDelayTimer <> $
         {
            DeleteTimer(ptLogonDelayTimer);
         }
         Send(self,@EffectSendUser,#what=self,#effect=EFFECT_PARALYZE_ON);
         Send(self,@SysMsgSendUser,#message_rsc=user_logon_delay);
         iLogonDelay = Send(SETTINGS_OBJECT,@GetLogonDelay);
         ptLogonDelayTimer = CreateTimer(self,@LogonHoldOff,iLogonDelay);
      }

      return;
   }

   LogonHoldOff()
   {
      Send(self,@EffectSendUser,#what=self,#effect=EFFECT_PARALYZE_OFF);
      ptLogonDelayTimer = $;

      return;
   }

   UserLogoff()
   {
      local theTime, iPenaltyTime, i, j;

      piTimeLoggedIn = Send(self,@GetTimeLoggedIn);
      Send(self,@BreakTrance);
      pbLogged_on = FALSE;

      Send(self,@CancelIfOffer);
      Send(self,@UserLogoffHook);

      % If player logs off somewhere other than an inn or inside a guildhall
      % they can normally enter (but not just in the foyer), create a ghost.
      if (NOT Send(poOwner,@CheckDefaultRoomFlag,#flag=ROOM_SAFELOGOFF))
         AND NOT IsClass(self,&DM)
         AND Send(SYS,@GetLogoffPenaltyEnable)
         AND piLogoffPenaltyCount >= 0
         AND NOT (IsClass(poOwner,&GuildHall)
                  AND Send(poOwner,@GetGuildOwner) <> $
                  AND Send(poOwner,@CanEnter,#who=self)
                  AND NOT Send(poOwner,@InFoyer,#who=self))
      {
         Create(&LogoffGhost,#GhostedPlayer=self,
               #iPenaltyTime=Send(self,@GetRemainingPhaseTime));

         % Add phase time remaining to piTimeAttackedPlayer if it is currently
         % preventing the player from casting escape spells.
         if Send(self,@GetLastPlayerAttackTime)
               + Send(SETTINGS_OBJECT,@TeleportAttackDelaySec)
               > GetTime()
         {
            piTimeAttackedPlayer = piTimeAttackedPlayer
                                   + (Send(self,@GetRemainingPhaseTime) / 1000);
         }
      }
      else
      {
         % Reset our logoff penalty time since we're logging safely.
         Send(self,@RefreshPhaseTimeToBase);

         % If enabled and and a player logs off in a safe zone he will lose
         % half his mana and all buffs
         if Send(SETTINGS_OBJECT,@LogSafePenaltyEnable)
            AND Send(SYS,@GetLogoffPenaltyEnable)
         {
            Send(self,@LoseMana,#amount=(piMana/2));
            Send(Send(SYS,@FindSpellByNum,#num=SID_PURGE),@DoPurge,
                  #who=self,#iChance=100);
         }
      }

      if piLogoffPenaltyCount < 0
      {
         piLogoffPenaltyCount = 0;
      }

      piSave_room = Send(poOwner,@GetRoomNum);
      piSave_row = piRow;
      piSave_col = piCol;
      piSave_angle = Send(self,@GetAngle);
      piSave_fine_row = piFine_row;
      piSave_fine_col = piFine_col;

      Send(poOwner,@LeaveHold,#what=self);
      if poOwner <> $
         AND Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
         AND Send(self,@GetDeathRiftProtection)
      {
         % Don't let players stay in the Underworld with Death Rift
         Post(self,@AdminGoToSafety);
      }
      poOwner = $;

      % If we still have an evil twin at this stage, tell it to delete itself.
      if poEvilTwin <> $
      {
         Send(poEvilTwin,@SomethingLeft,#what=self);
      }

      % Check for phase out
      foreach j in plEnchantments
      {
         if IsClass(Nth(j,2),&Phase)
         {
            Send(self,@FreezePhaseTimer);
            Send(self,@RemoveEnchantment,#what=Nth(j,2),#report=FALSE);

            break;
         }
      }

      % Have to put here so room enchantments are removed first.
      Send(self,@FreezeAllEnchantments);

      Send(SYS,@SystemUserLogoff,#what=self);

      if NOT (IsClass(self,&DM) AND Send(self,@IsHidden))
      {
         % Advertise normally.
         Send(SYS,@SystemUserLogoffAdvertise,#what=self);
      }
      else
      {
         % We've already faked our own logoff.  Don't advertise to non-admins.
         foreach i in Send(SYS,@GetUsersLoggedOn)
         {
            % Only do this for admins
            if IsClass(i,&Admin)
            {
               Send(i,@SomeoneLogoff,#what=self);
            }
         }
      }

      poSession = $;

      return;
   }

   PhaseMinions()
   "Deletes reflections, phases any ETs attacking us."
   {
      Send(SYS,@DeletePlayerReflections,#who=self);
      if (poEvilTwin <> $
         AND poOwner <> $)
      {
         Send(poEvilTwin,@OriginalPhased);
         Send(poOwner,@SomethingChanged,#what=poEvilTwin);
      }

      return;
   }

   UnphaseMinions()
   "Unphases any ETs attacking us."
   {
      if (poEvilTwin <> $)
      {
         Send(poEvilTwin,@OriginalUnphased,#who=self);
         Send(poOwner,@SomethingChanged,#what=poEvilTwin);
      }

      return;
   }

   DecayLogoffPenaltyCount()
   {
      piLogoffPenaltyCount = Bound(piLogoffPenaltyCount - 1,0,$);

      return;
   }

   GetLogoffPenaltyCount()
   {
      return piLogoffPenaltyCount;
   }

   IncrementLogoffPenaltyCount()
   {
      local iAmount;

      iAmount = 1;

      % This tracks to see if the player has attacked anyone recently.
      % If they have, then increase the penalty.
      if NOT Send(self,@CanHelpPlayer)
      {
         ++iAmount;
      }

      piLogoffPenaltyCount = piLogoffPenaltyCount + iAmount;

      return;
   }

   ResetLogoffPenaltyTime()
   {
      Send(self,@RefreshPhaseTimeToBase);

      return;
   }

   AdminSystemMessage(string = $)
   {
      Send(self,@SysMsgSendUser,#message_rsc=user_admin_message,#parm1=string);

      return;
   }

   SomeoneLogon(what = $)
   {
      local rName;

      % don't inform non-DM clients of Escaped Convict
      if (NOT IsClass(self,&DM) AND IsClass(what,&EscapedConvict)
         AND NOT IsClass(self,&EscapedConvict) AND IsClass(what,&EscapedConvict))
      {
         return;
      }

      rName = Send(what,@GetTrueName);

      if pbLogged_on
      {
         AddPacket(1,BP_PLAYER_ADD);
         AddPacket(4,what,4,rName);
         AddPacket(STRING_RESOURCE,rName);
         AddPacket(4,Send(what,@GetObjectFlags));
         AddPacket(1,Send(what,@GetDrawingEffects) & ~DRAWFX_INVISIBLE);
         AddPacket(4,0); % minimapflags, don't need the value here.
         AddPacket(4,Send(what,@GetPlayerNameColor));
         AddPacket(1,Send(what,@GetClientObjectType));
         AddPacket(1,0); % MoveOn type, don't need it here.
         SendPacket(poSession);

         if IsClass(self,&Admin) AND IsClass(what,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=user_someone_logon,#
                  parm1=rName);
         }

         if what <> self AND poGuild <> $ AND poGuild = Send(what,@GetGuild)
         {
            Send(self,@MsgSendUser,#message_rsc=user_guildmate_logon,
                 #parm1=rName);
         }
      }

      return;
   }

   SomeoneLogoff(what = $)
   {
      local rName;

      rName = Send(what,@GetTrueName);

      if pbLogged_on
      {
         if IsClass(self,&Admin) AND IsClass(what,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=user_someone_logoff,
                 #parm1=rName);
         }

         if what <> self AND poGuild <> $ AND poGuild = Send(what,@GetGuild)
         {
            Send(self,@MsgSendUser,#message_rsc=user_guildmate_logoff,
                 #parm1=rName);
         }

         AddPacket(1,BP_PLAYER_REMOVE,4,what);
         SendPacket(poSession);
      }

      return;
   }

   DisconnectSession()
   {
      Send(self,@UserLogoff);

      return;
   }

   ReceiveClient(client_msg = $,number_stuff = $,type = $)
   "Sent by the server when the client has a message.  The client_msg "
   "is the permanent list created by AllocateCommCli in the server, "
   "so we can't store list fragments!  Also, number_stuff has number "
   "parameters for any of the client_msg things that are number objects.  "
   "It is dynamically allocated each time (wasting list nodes)."
   {
      local liClient_cmd, oWhat, oWhere, oRoom, iRow, iCol, iSay_type,
            sStr_said, sStr_mailed, lDest_mail, iAttack_type, iGroup, lItems,
            lUsers, oApply_on, iNid, sTitle, iAngle, sBody, iNum, iSpeed,
            lTargets, i;

      % This checks to see if the user is trying to Send too many packets
      %  per second.  If they are, then we mark them as a spammer and
      %  don't process the message
      if piLastPacketTime <> GetTime()
      {
         piLastPacketTime = GetTime();
         piPacketsPerSecond = 1;
      }
      else
      {
         piPacketsPerSecond = piPacketsPerSecond + 1;
         if piPacketsPerSecond > INCOMING_PACKET_THROTTLE
            AND NOT Send(self,@PlayerIsImmortal)
         {
            piFloodCount++;

            % Don't go on if marked as spammer
            return;
         }
      }

      if type = 1
      {
         Send(self,@UserCommand,#client_msg=client_msg,
              #number_stuff=number_stuff);

         return;
      }

      liClient_cmd = First(client_msg);

      % NOTE: Should arrange in decreasing order of frequency

      if liClient_cmd = BP_REQ_MOVE
      {
         % Fix: speed, row, col, room
         iRow = Nth(client_msg,2);
         iCol = Nth(client_msg,3);
         iSpeed = Nth(client_msg,4);
         oRoom = Nth(client_msg,5);

         % Check if it's an outdated message, from a person going off side of
         %  room multiple times before they got their new room.
         if oRoom <> poOwner 
         {
            return;
         }

         Send(self,@UserMove,#new_row=iRow/FINENESS,#new_col=iCol/FINENESS,
              #fine_row=(iRow mod FINENESS),#fine_col=(iCol mod FINENESS),
              #speed=iSpeed);

         return;
      }

      if liClient_cmd = BP_REQ_TURN
      {
         oWhat = Nth(client_msg,2);
         iAngle = Nth(client_msg,3);
         Send(self,@UserTurn,#what=oWhat,#new_angle=iAngle);

         return;
      }

      if liClient_cmd = BP_SEND_PLAYER
      {
         Send(self,@ToCliPlayer);

         return;
      }

      if liClient_cmd = BP_SEND_PLAYERS
      {
         Send(self,@ToCliPlayers);

         return;
      }

      if liClient_cmd = BP_SEND_ROOM_CONTENTS
      {
         Send(self,@ToCliRoomContents);

         return;
      }

      if liClient_cmd = BP_REQ_INVENTORY
      {
         Send(self,@ToCliInventory);
         Send(self,@ToCliUseList);

         return;
      }

      if liClient_cmd = BP_REQ_QUIT
      {
         Send(self,@UserLogoff);

         return;
      }

      if liClient_cmd = BP_REQ_GET
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Item)
         {
            Send(self,@UserGet,#what=oWhat);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_item);
         }

         return;
      }

      if liClient_cmd = BP_REQ_DROP
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserDrop,#what=oWhat,#number=number_stuff);

         return;
      }

      if liClient_cmd = BP_REQ_INVENTORY_MOVE
      {
         oWhat = Nth(client_msg,2);
         oWhere = Nth(client_msg,3);
         Send(self,@UserMoveInventoryItem,#what=oWhat,#where=oWhere);

         return;
      }

      if liClient_cmd = BP_REQ_PUT
      {
         oWhat = Nth(client_msg,2);
         oWhere = Nth(client_msg,3);
         Send(self,@UserPut,#what=oWhat,#where=oWhere,#number=number_stuff);

         return;
      }

      if liClient_cmd = BP_SEND_OBJECT_CONTENTS
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserObjectContents,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_SAY_TO
      {
         iSay_type = Nth(client_msg,2);
         sStr_said = Nth(client_msg,3);
         Send(self,@UserSay,#type=iSay_type,#string=sStr_said);

         return;
      }

      if liClient_cmd = BP_SAY_GROUP
      {
         lUsers  = Nth(client_msg,2);
         sStr_said = Nth(client_msg,3);
         Send(self,@UserSayGroup,#users=lUsers,#string=sStr_said);

         return;
      }

      if liClient_cmd = BP_REQ_LOOK
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserLook,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_SEND_MAIL
      {
         lDest_mail = Nth(client_msg,2);
         sStr_mailed = Nth(client_msg,3);
         Send(self,@UserMail,#dest_list=lDest_mail,#string=sStr_mailed);

         return;
      }

      if liClient_cmd = BP_REQ_GET_MAIL
      {
         Send(self,@UserGetNewMail);

         return;
      }

      if liClient_cmd = BP_DELETE_MAIL
      {
         Send(self,@UserDeleteMail,#index=Nth(client_msg,2));

         return;
      }

      if liClient_cmd = BP_REQ_USE
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserUseItem,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_REQ_UNUSE
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserUnuseItem,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_REQ_ATTACK
      {
         iAttack_type = Nth(client_msg,2);
         oWhat = Nth(client_msg,3);
         Send(self,@UserAttack,#type=iAttack_type,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_SEND_STATS
      {
         iGroup = Nth(client_msg,2);
         Send(self,@ToCliStats,#group=iGroup);

         return;
      }

      if liClient_cmd = BP_REQ_OFFER
      {
         oWhat = Nth(client_msg,2);
         lItems = Nth(client_msg,3);
         Send(self,@UserOffer,#what=oWhat,#item_list=lItems,
              #number_list=number_stuff);

         return;
      }

      if liClient_cmd = BP_CANCEL_OFFER
      {
         Send(self,@UserCancelOffer);

         return;
      }

      if liClient_cmd = BP_REQ_COUNTEROFFER
      {
         lItems = Nth(client_msg,2);
         Send(self,@UserCounterOffer,#item_list=lItems,
              #number_list=number_stuff);

         return;
      }

      if liClient_cmd = BP_ACCEPT_OFFER
      {
         Send(self,@UserAcceptOffer);

         return;
      }

      if liClient_cmd = BP_REQ_GO
      {
         Send(self,@UserGo);

         return;
      }

      if liClient_cmd = BP_REQ_BUY
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserBuy,#what=oWhat);
         }

         return;
      }

      if liClient_cmd = BP_REQ_BUY_ITEMS
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            lItems = Nth(client_msg,3);
            Send(self,@UserBuyItems,#what=oWhat,#item_list=lItems,
               #number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_WITHDRAWAL
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            Send(self,@UserWithdrawal,#what=oWhat);
         }

         return;
      }

      if liClient_cmd = BP_REQ_WITHDRAWAL_ITEMS
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            lItems = Nth(client_msg,3);
            Send(self,@UserWithdrawalItems,#what=oWhat,#item_list=lItems,
               #number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_DEPOSIT
      {
         oWhat = Nth(client_msg,2);
         if IsClass(oWhat,&Monster)
         {
            lItems = Nth(client_msg,3);
            Send(self,@UserDeposit,#what=oWhat,#item_list=lItems,
               #number_list=number_stuff);
         }

         return;
      }

      if liClient_cmd = BP_REQ_APPLY
      {
         oWhat = Nth(client_msg,2);
         oApply_on = Nth(client_msg,3);
         Send(self,@UserApply,#what=oWhat,#apply_on=oApply_on);

         return;
      }

      if liClient_cmd = BP_SEND_SPELLS
      {
         Send(self,@ToCliSpells);

         return;
      }

      if liClient_cmd = BP_SEND_SKILLS
      {
         Send(self,@ToCliSkills);

         return;
      }

      if liClient_cmd = BP_REQ_CAST
      {
         oWhat = Nth(client_msg,2);  % Spell type
         lTargets = Nth(client_msg,3); % Targets of spell (if any)
         Send(self,@UserCast,#oSpell=oWhat,#lTargets=lTargets);

         return;
      }

      if liClient_cmd = BP_POST_ARTICLE
      {
         iNid = Nth(client_msg,2);
         sTitle = Nth(client_msg,3);
         sBody = Nth(client_msg,4);
         Send(self,@UserPost,#nid=iNid,#title=sTitle,#body=sBody);

         return;
      }

      if liClient_cmd = BP_REQ_ARTICLES
      {
         iNid = Nth(client_msg,2);
         Send(self,@UserGetNewsTitles,#nid=iNid);

         return;
      }

      if liClient_cmd = BP_REQ_ARTICLE
      {
         iNid = Nth(client_msg,2);
         iNum = Nth(client_msg,3);
         Send(self,@UserGetNewsArticle,#nid=iNid,#num=iNum);

         return;
      }

      if liClient_cmd = BP_ACTION
      {
         iNum = Nth(client_msg, 2);
         Send(self,@UserAction,#action=iNum);

         return;
      }

      if liClient_cmd = BP_SEND_STAT_GROUPS
      {
         Send(self,@ToCliStatGroups);

         return;
      }

      if liClient_cmd = BP_SAY_BLOCKED
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserBlockedSend,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_REQ_LOOKUP_NAMES
      {
         Send(self,@UserLookupNames,#amount=Nth(client_msg,2),
              #string=Nth(client_msg,3));

         return;
      }

      if liClient_cmd = BP_CHANGE_DESCRIPTION
      {
         % oWhat = who's editing.
         oWhat = Nth(client_msg,2);
         sBody = Nth(client_msg,3);

         if oWhat = $
         {
            Debug("Tried setting description of nil object.");

            return;
         }

         % Editing our own description.
         % Or, an admin editing a player's description.
         if oWhat = self
            OR (IsClass(oWhat,&Player) AND IsClass(self,&Admin))
         {
            sBody = Send(SYS,@CleanseString,#string=sBody);
            Send(oWhat,@UserChangeDescription,#string=sBody);

            return;
         }

         oWhere = Send(oWhat,@GetOwner);
         if Send(oWhat,@CanEditInscription)
            AND ((oWhere = self) or (oWhere = poOwner))
         {
            sBody = Send(SYS,@CleanseString,#string=sBody);
            Send(oWhat,@SetInscription,#string=sBody);

            return;
         }

         Debug("Tried setting description of ",oWhat);

         return;
      }

      if liClient_cmd = BP_REQ_ACTIVATE
      {
         oWhat = Nth(client_msg,2);
         Send(self,@UserTryActivate,#what=oWhat);

         return;
      }

      if liClient_cmd = BP_SEND_ENCHANTMENTS
      {
         if Nth(client_msg,2) <> ENCHANTMENT_PLAYER
         {
            return;
         }

         Send(self,@SendEnchantmentIcons);

         return;
      }

      if liClient_cmd = BP_CHANGED_STATS
      {
      
         if Length(client_msg) <> 14
         {
            return;
         }

         foreach i in client_msg
         {
            if i = $
            {
               return;
            }
         }

         Send(self,@UserChangedStats, #might=Nth(client_msg,2),
                                       #intellect=Nth(client_msg,3),
                                       #stamina=Nth(client_msg,4),
                                       #agility=Nth(client_msg,5),
                                       #mysticism=Nth(client_msg,6),
                                       #aim=Nth(client_msg,7),
                                       #shallile_lvl=Nth(client_msg,8),
                                       #qor_lvl=Nth(client_msg,9),
                                       #kraanan_lvl=Nth(client_msg,10),
                                       #faren_lvl=Nth(client_msg,11),
                                       #riija_lvl=Nth(client_msg,12),
                                       #jala_lvl=Nth(client_msg,13),
                                       #weaponcraft_lvl=Nth(client_msg,14));
         return;
      }

      Debug(Send(self,@GetTrueName),
            self,"sent unknown command from client",liClient_cmd);

      return;
   }

   PerformGuildDisband()
   "Admin supported.\n"
   "UserCommand() will check to stop a player from disbanding when not "
   "appropriate.  This function will force a disband and clean up anything, "
   "ignoring game rules."
   {
      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         Send(self,@UserGuildCommand,#command_num=GCID_DISBAND);
         return Send(SYS,@GetSuccessRsc);
      }
      
      return Send(SYS,@GetFailureRsc);
   }

   PerformSuicide()
   "Admin supported.\n"
   "UserCommand() will check to stop a player from suiciding when not "
   "appropriate. This function will force a suicide and clean up anything, "
   "ignoring game rules."
   {
      local sName;

      Send(self,@CancelIfOffer);

      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         % guild master must disband guild if forced to suicide
         Send(self,@PerformGuildDisband);
      }

      piLast_Restart_time = getTime();
      piLastLoginTime = 0;
      psUrl = $;
      psHonor = $;
      plHonor = $;
      piLogoffPenaltyCount = -1;

      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND,1,UC_SEND_QUIT);
         SendPacket(poSession);
      }

      RecordStat(STAT_PLAYERSUICIDE, poSession, Send(self,@GetTrueName));

      % Change the name to a unique placeholder one.
      ClearTempString();
      AppendTempString("Suicide");
      AppendTempString(GetTime());
      AppendTempString(GetTickCount() MOD 1000);
      sName = SetString($,GetTempString());
      Debug("Character",Send(self,@GetTrueName),self,"was suicided.");
      Send(SYS,@ChangeUserName,#oUser=self,#sName=sName);

      Send(self,@ResetCharacter);

      return Send(SYS,@GetSuccessRsc);
   }

   UserCommandSuicide()
   {
      if poGuild <> $
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide);

         return;
      }

      if IsClass(poOwner,&OutOfGrace)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_OOG);

         return;
      }

      if GetTime() < piLast_restart_time + SUICIDE_REPEAT_TIME
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_yet);

         return;
      }

      if Send(self,@FindHolding,#class=&Token)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_token);

         return;
      }

      if Send(SETTINGS_OBJECT,@GetMaxSuicideHP) <= piBase_Max_health
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_suicide_hp);

         return;
      }

      % Successful SUICIDE.
      Send(self,@PerformSuicide);

      return;
   }

   UserCommandSetSafety(value = 0)
   {
      Send(self,@SetPlayerPreference,#flag=CF_SAFETY_OFF,#value=value);
      if value
      {
         if Send(SYS,@IsPKAllowed)
         {
            Send(self,@MsgSendUser,#message_rsc=user_safety_off);
            Send(self,@WaveSendUser,#what=self,
                  #wave_rsc=user_safety_off_wav_rsc);
         }
      }
      else
      {
         if Send(SYS,@IsPKAllowed)
         {
            Send(self,@MsgSendUser,#message_rsc=user_safety_on);
            Send(self,@WaveSendUser,#what=self,
                  #wave_rsc=user_safety_on_wav_rsc);
         }

      }

      return;
   }

   UserCommandSetTempSafe(value = 0)
   {
      if piBase_max_health > 99
         OR (piFlags & PFLAG_MURDERER)
         OR (piFlags & PFLAG_OUTLAW)
         OR Send(self,@FindUsing,#class=&SoldierShield) <> $
      {
         if value
         {
            piPreferences = piPreferences | CF_TEMPSAFE;
         }
         else
         {
            piPreferences = piPreferences & ~CF_TEMPSAFE;
         }
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_invalid);

         return;
      }

      if value
      {
         piPreferences = piPreferences | CF_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_TEMPSAFE;
         Send(self,@MsgSendUser,#message_rsc=user_temp_safe_off);
      }

      return;
   }

   UserCommandSetGrouping(value = 0)
   {
      if value
      {
         piPreferences = piPreferences | CF_GROUPING;
         Send(self,@MsgSendUser,#message_rsc=user_grouping_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_GROUPING;
         Send(self,@MsgSendUser,#message_rsc=user_grouping_off);
      }

      return;
   }

   UserCommandSetAutoLoot(value = 0)
   {
      if value
      {
         piPreferences = piPreferences | CF_AUTOLOOT;
         Send(self,@MsgSendUser,#message_rsc=user_autoloot_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_AUTOLOOT;
         Send(self,@MsgSendUser,#message_rsc=user_autoloot_off);
      }

      return;
   }

   UserCommandSetAutoCombine(value = 0)
   {
      if value
      {
         piPreferences = piPreferences | CF_AUTOCOMBINE;
         Send(self,@MsgSendUser,#message_rsc=user_autocombine_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_AUTOCOMBINE;
         Send(self,@MsgSendUser,#message_rsc=user_autocombine_off);
      }

      return;
   }

   UserCommandSetReagentBag(value = 0)
   {
      if value
      {
         piPreferences = piPreferences | CF_REAGENTBAG;
         Send(self,@MsgSendUser,#message_rsc=user_reagentbag_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_REAGENTBAG;
         Send(self,@MsgSendUser,#message_rsc=user_reagentbag_off);
      }

      return;
   }

   UserCommandSetSpellpowerDisplay(value = 0)
   {
      if value
      {
         piPreferences = piPreferences | CF_SPELLPOWER;
         Send(self,@MsgSendUser,#message_rsc=user_spellpower_on);
      }
      else
      {
         piPreferences = piPreferences & ~CF_SPELLPOWER;
         Send(self,@MsgSendUser,#message_rsc=user_spellpower_off);
      }

      return;
   }

   UserCommandSetPreferences(value = 0)
   {
      % Check each possible preference, improvement over sending 7 messages
      % from client to server with each preference.
      if (value & CF_SAFETY_OFF) <> (piPreferences & CF_SAFETY_OFF)
      {
         Send(self,@UserCommandSetSafety,#value=value & CF_SAFETY_OFF);
      }

      if (value & CF_TEMPSAFE) <> (piPreferences & CF_TEMPSAFE)
      {
         Send(self,@UserCommandSetTempSafe,#value=value & CF_TEMPSAFE);
      }

      if (value & CF_GROUPING) <> (piPreferences & CF_GROUPING)
      {
         Send(self,@UserCommandSetGrouping,#value=value & CF_GROUPING);
      }

      if (value & CF_AUTOLOOT) <> (piPreferences & CF_AUTOLOOT)
      {
         Send(self,@UserCommandSetAutoLoot,#value=value & CF_AUTOLOOT);
      }

      if (value & CF_REAGENTBAG) <> (piPreferences & CF_REAGENTBAG)
      {
         Send(self,@UserCommandSetReagentBag,#value=value & CF_REAGENTBAG);
      }

      if (value & CF_AUTOCOMBINE) <> (piPreferences & CF_AUTOCOMBINE)
      {
         Send(self,@UserCommandSetAutoCombine,#value=value & CF_AUTOCOMBINE);
      }

      if (value & CF_SPELLPOWER) <> (piPreferences & CF_SPELLPOWER)
      {
         Send(self,@UserCommandSetSpellpowerDisplay,#value=value & CF_SPELLPOWER);
      }

      % Send the preferences back to client, in case a flag couldn't be set.
      Send(self,@UserSendPreferences);

      return;
   }

   UserSendPreferences()
   "Sends the player's stored preferences to the client."
   {
      AddPacket(1,BP_USERCOMMAND, 1,UC_RECEIVE_PREFERENCES, 4,piPreferences);
      SendPacket(poSession);

      return;
   }

   UserCommand(client_msg=$, number_stuff=$)
   {
      local iClient_cmd, oWhat;

      iClient_cmd = First(client_msg);

      % Arranged in decreasing order of frequency.
      switch(iClient_cmd)
      {
         case UC_REST:
            Send(self,@StartResting);
            return;
         case UC_STAND:
            Send(self,@StopResting);
            return;
         case UC_SEND_PREFERENCES:
            Send(self,@UserCommandSetPreferences,#value=Nth(client_msg,2));
            return;
         case UC_REQ_PREFERENCES:
            Send(self,@UserSendPreferences);
            return;
         case UC_REQ_GUILDINFO:
            Send(self,@UserGuildSendInfo);
            return;
         case UC_SUICIDE:
            Send(self,@UserCommandSuicide);
            return;
         case UC_INVITE:
            Send(self,@UserGuildCommand,#command_num=GCID_INVITE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_RENOUNCE:
            Send(self,@UserGuildCommand,#command_num=GCID_RENOUNCE);
            return;
         case UC_EXILE:
            Send(self,@UserGuildCommand,#command_num=GCID_EXILE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_ABDICATE:
            Send(self,@UserGuildCommand,#command_num=GCID_ABDICATE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_VOTE:
            Send(self,@UserGuildCommand,#command_num=GCID_VOTE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_SET_RANK:
            Send(self,@UserGuildCommand,#command_num=GCID_SET_RANK,
                  #oTarget=Nth(client_msg,2),#data=Nth(client_msg,3));
            return;
         case UC_GUILD_CREATE:
            Send(self,@UserCommandCreateGuild,#client_msg=client_msg);
            return;
         case UC_DISBAND:
            Send(self,@UserGuildCommand,#command_num=GCID_DISBAND);
            return;
         case UC_MAKE_ALLIANCE:
            Send(self,@UserGuildCommand,#command_num=GCID_FORGE_ALLIANCE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_END_ALLIANCE:
            Send(self,@UserGuildCommand,#command_num=GCID_END_ALLIANCE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_MAKE_ENEMY:
            Send(self,@UserGuildCommand,#command_num=GCID_DECLARE_ENEMY,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_END_ENEMY:
            Send(self,@UserGuildCommand,#command_num=GCID_PEACE,
                  #oTarget=Nth(client_msg,2));
            return;
         case UC_REQ_GUILD_LIST:
            Send(self,@UserGuildSendList);
            return;
         case UC_GUILD_SHIELDS:
            Send(self,@UserGuildSendShieldSamples);
            return;
         case UC_GUILD_SHIELD:
            Send(self,@UserGuildSendShieldInfo,#oGuild=poGuild);
            return;
         case UC_CLAIM_SHIELD:
            Send(self,@UserCommandClaimShield,#client_msg=client_msg);
            return;
         case UC_GUILD_RENT:
            Send(self,@UserCommandGuildRent,#oHall=Nth(client_msg,2),
                  #sPassword=Nth(client_msg,3));
            return;
         case UC_ABANDON_GUILD_HALL:
            Send(self,@UserGuildCommand,#command_num=GCID_ABANDON_HALL);
            return;
         case UC_GUILD_SET_PASSWORD:
            Send(self,@UserGuildCommand,#command_num=GCID_SET_PASSWORD,
                  #data=Nth(client_msg,2));
            return;
         case UC_CHANGE_URL:
            oWhat = Nth(client_msg,2);

            if oWhat <> self
               AND NOT IsClass(oWhat,&Admin)
            {
               Debug(self,"tried to change url of",Nth(client_msg,2));

               return;
            }
            Send(self,@UserChangeURL,#string=Nth(client_msg,3));

            return;
         case UC_DEPOSIT:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_DEPOSIT,#data=Nth(client_msg,2))
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_deposit);
            }

            return;
         case UC_WITHDRAW:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_WITHDRAW,#data=Nth(client_msg,2))
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_withdraw);
            }

            return;
         case UC_BALANCE:
            if NOT Send(poOwner,@SomeoneTryUserCommand,#who=self,
                        #command=UC_BALANCE)
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_balance);
            }

            return;
         case UC_APPEAL:
            Send(self,@UserAppeal,#string=Nth(client_msg,2));
            return;
         case UC_REQ_RESCUE:
            if poOwner <> $
               AND Send(poOwner,@GetRoomNum) = Send(self,@GetHomeroom)
            {
               AddPacket(1,BP_USERCOMMAND,1,UC_SEND_QUIT);
               SendPacket(poSession);

               return;
            }

            Send(self,@AdminGotoSafety);
            Debug(self,"was just sent to safety because their client had a "
                  "broken room",poOwner);

            return;
         case UC_MINIGAME_STATE:
            Send(Nth(client_msg,2),@GotNewState,#who=self,
                 #state=Nth(client_msg,3));
            return;
         case UC_MINIGAME_RESET_PLAYERS:
            Send(Nth(client_msg,2),@ResetPlayers,#who=self);
            return;
         case UC_REQ_TIME:
               ClearTempString();
               Send(SYS,@AppendOrdinalToTempString,#number=Send(SYS,@GetDay));
               Send(self,@MsgSendUser,
                  #message_rsc=user_time_string,
                  #parm1=Send(SYS,@GetHour),
                  #parm2=GetTempString(),
                  #parm3=Send(SYS,@GetYear)
                  );
         return;

         default:
            Debug("User.kod got unknown UserCommand command from client",
               iClient_cmd);
            return;
      }

      return;
   }

   UserCommandGuildRent(oHall = $, sPassword = $)
   {
      local iCost, oMoney;

      if poGuild = $
         OR oHall = $
         OR sPassword = $
      {
         return;
      }

      iCost = Send(oHall,@GetPurchaseValue,#who=self);
      oMoney = Send(self,@GetMoneyObject);

      if oMoney = $ OR Send(oMoney,@GetNumber) < iCost
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guildhall_broke);
         
         return FALSE;
      }

      if Send(oHall,@ClaimGuildHall,#oGuild=poGuild,#rep=self,
               #password=sPassword)
      {
          Send(oMoney,@SubtractNumber,#number=iCost);
      }

      return;
   }

   UserCommandClaimShield(client_msg = $)
   {
      local oGuild;

      if client_msg = $
      {
         return;
      }

      % Check if they have a guild.
      if poGuild = $
      {
         return;
      }

      % Find the guild from the color info.
      oGuild = Send(SYS,@FindGuildByShield,#color1=Nth(client_msg,2),
                     #color2=Nth(client_msg,3),#shape=Nth(client_msg,4));

      if oGuild = $
         AND Nth(client_msg,5) <> FALSE
         AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         Send(poGuild,@SetGuildColors,#color1=Nth(client_msg,2),
               #color2=Nth(client_msg,3),#shape=Nth(client_msg,4));
      }

      Send(self,@UserGuildSendShieldInfo,#oguild=oGuild,
            #color1=Nth(client_msg,2),#color2=Nth(client_msg,3),
            #shape=Nth(client_msg,4));

      return;
   }

   UserCommandCreateGuild(client_msg = $)
   {
      local i, oMoney, iCost;

      if client_msg = $
      {
         return;
      }

      oMoney = Send(self,@GetMoneyObject);

      % Secret guild?
      if Nth(client_msg,13)
      {
         iCost = Send(SYS,@GetGuildSecretPrice);
      }
      else
      {
         iCost = Send(SYS,@GetGuildPrice);
      }

      if oMoney = $
         OR Send(oMoney,@GetNumber) < iCost
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild_broke);

         return FALSE;
      }

      if Send(SYS,@FindGuildByString,#string=Nth(client_msg,2)) <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_duplicate_guildname);

         return FALSE;
      }

      % Check if equal to a user name.
      if Send(SYS,@FindUserByString,#string=Nth(client_msg,2)) <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_duplicate_guild_username);

         return FALSE;
      }

      % Validate string lengths
      if StringLength(Nth(client_msg, 2)) < 1
      {
         Debug(self, "had guild name too short");

         return FALSE;
      }
      if StringLength(Nth(client_msg, 2)) > MAX_GUILD_NAME_LEN
      {
         Debug(self, "had guild name too long");

         return FALSE;
      }
      i = 3;
      while (i <= 12)
      {
         if StringLength(Nth(client_msg, i)) > MAX_GUILD_RANK_LEN
         {
            Debug(self, "had guild rank too long");

            return FALSE;
         }
         ++i;
      }

      Create(&Guild,#master=self,#guildname=Nth(client_msg,2),
                    #secret=Nth(client_msg,13),
                    #rApprentice_male=Nth(client_msg,3),
                    #rApprentice_female=Nth(client_msg,4),
                    #rSir=Nth(client_msg,5),#rMadame=Nth(client_msg,6),
                    #rLord=Nth(client_msg,7),#rLady=Nth(client_msg,8),
                    #rLieutenant_male=Nth(client_msg,9),
                    #rLieutenant_female=Nth(client_msg,10),
                    #rMaster=Nth(client_msg,11),
                    #rMistress=Nth(client_msg,12));

      Send(oMoney,@SubtractNumber,#number=iCost);

      return;
   }

   UserGuildSendInfo()
   {
      local i,lRank_names,lMembers,lHall;

      if poGuild = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild);
         return;
      }

      AddPacket(1,BP_USERCOMMAND,1,UC_GUILDINFO);
      AddPacket(6,Send(poGuild,@GetName));
      lHall = Send(poGuild,@GetGuildHall);
      if lHall <> $ AND Send(poGuild,@GetRank,#who=self) = RANK_MASTER
      {
         AddPacket(1,1);
         AddPacket(6,Send(poGuild,@GetPassword));
      }
      else
      {
         AddPacket(1,0);
      }

      AddPacket(4,piGuild_commands);
      AddPacket(4,poGuild);

      lRank_names = Send(poGuild,@GetRankNames);
      foreach i in lRank_names
      {
         AddPacket(STRING_RESOURCE,i);
      }

      % member list is list of lists--first item of sublist is object id
      lMembers = Send(poGuild,@GetMemberList);

      % Need to find ourself in here to get our vote
      foreach i in lMembers
      {
         if First(i) = self
         {
            if Nth(i,3) = $
            {
               % not supporting anyone
               AddPacket(4,0);
            }
            else
            {
               AddPacket(4,Nth(i,3));
            }
         }
      }

      AddPacket(2,Length(lMembers));
      foreach i in lMembers
      {
         AddPacket(4,First(i));
         AddPacket(STRING_RESOURCE,Send(First(i),@GetTrueName));
         AddPacket(1,Nth(i,2));
         AddPacket(1,Send(First(i),@GetGender));
      }

      SendPacket(poSession);

      return;
   }

   UserGuildSendList()
   {
      local lGuilds, i;

      % Must be guilded to receive guild list.
      if poGuild = $
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND,1,UC_GUILD_LIST);

         lGuilds = Send(SYS,@GetGuilds);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i,6,Send(i,@GetName));
         }

         lGuilds = Send(poGuild,@GetAllyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetEnemyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetDeclaredAllyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         lGuilds = Send(poGuild,@GetDeclaredEnemyList);
         AddPacket(2,Length(lGuilds));
         foreach i in lGuilds
         {
            AddPacket(4,i);
         }

         SendPacket(poSession);
      }

      return;
   }

   UserGuildSendShieldSamples()
   {
      local lSamples,i;

      % Only do this if the user is guilded.
      if poGuild <> $
      {
         if pbLogged_on
         {
            AddPacket(1,BP_USERCOMMAND,1,UC_GUILD_SHIELDS);

            lSamples = Send(SYS,@GetGuildShieldSamples);
            AddPacket(2,length(lSamples));
            foreach i in lSamples
            {
               AddPacket(4,i);
            }

            SendPacket(poSession);
         }
      }

      return;
   }

   UserGuildSendShieldInfo(oguild=$,color1=$,color2=$,shape=$)
   {
      local owner;

      owner = oguild;

      % If the user isn't guilded, don't show them this info.
      if poGuild = $
      {
         return;
      }

      if (oGuild = $) or (not IsClass(oGuild,&Guild))
      {
         oGuild = poGuild;
      }

      if color1 = $
      {
         color1 = Send(oguild,@GetPrimaryGuildColor);
         color2 = Send(oguild,@GetSecondaryGuildColor);
         shape = Send(oguild,@GetShieldShape);
      }

      % Note this is Sending THIS user some info about ANY guild's shield.
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND,1,UC_GUILD_SHIELD);
         if owner <> $
         {
            AddPacket(4,owner);
            AddPacket(6,Send(oGuild,@GetName));
         }
         else
         {
            % Unclaimed guild Sends 0 for guild id but MY guild's name to
            % fulfil protocol
            AddPacket(4,0);
            AddPacket(6,Send(oGuild,@GetName));
         }

         AddPacket(1,color1,1,color2,1,shape);

         SendPacket(poSession);
      }

      return;
   }

   GarbageCollecting()
   {
      Send(self,@CancelIfOffer);

      Send(self,@SysMsgSendUser,#message_rsc=user_garbage_collecting);
      Send(self,@WaveSendUser,#what=self,#wave_rsc=user_saving_wav_rsc);

      AddPacket(1,BP_WAIT);
      SendPacket(poSession);

      return;
   }

   InvalidateData()
   "Admin supported.\n"
   "Sends the client a BP_INVALIDATE_DATA, so they reacquire player & room "
   "info."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVALIDATE_DATA);
         SendPacket(poSession);
      }

      return Send(SYS,@GetSuccessRsc);
   }

   GarbageCollectingDone()
   {
      Send(self,@InvalidateData);

      Send(self,@SysMsgSendUser,#message_rsc=user_garbage_collecting_done);

      % Let the user know whether safety is on or off.
      if piPreferences & CF_SAFETY_OFF
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_off);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_safety_on);
      }

      AddPacket(1,BP_UNWAIT);
      SendPacket(poSession);

      Send(self,@SendUserAllWindowOverlays);

      return;
   }

   UserLogonSetPosition()
   {
      local i,oNew_room;

      if piSave_room <> $
      {
         oNew_room = Send(SYS,@FindRoomByNum,#num=piSave_room);
         if oNew_room <> $
         {
            Send(oNew_room,@NewHold,#what=self,
                  #new_row=piSave_row,#new_col=piSave_col,
                  #fine_row=piSave_fine_row,
                  #fine_col=piSave_fine_col,
                  #new_angle=piSave_angle);

            return;
         }
      }

      if piSave_room <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_couldnt_replace);
      }

      Send(self,@AdminGoToSafety);

      return;
   }

   UserLogonHook()
   {
      local i;

      foreach i in Send(SYS,@GetBackgroundObjects)
      {
         Send(i,@AddBackgroundObject,#who=self);
      }

      Send(self,@LoadMailNews);

      % Count right now as the last time we moved.
      piLastMoveUpdateTime = GetTickCount();

      propagate;
   }

   LoadMailNews()
   {
      Send(self,@UserLoadModule,#module=user_mailnews_module);

      return;
   }

   UserLoadModule(module = $)
   {
      AddPacket(1,BP_LOAD_MODULE,4,module);
      SendPacket(poSession);

      return;
   }

   UserUnloadModule(module = $)
   {
      if NOT pbLogged_on
      {
         return;
      }

      AddPacket(1,BP_UNLOAD_MODULE,4,module);
      SendPacket(poSession);

      return;
   }

   UserGameStart(game = $, player_num = 1)
   {
      AddPacket(1,BP_USERCOMMAND,1,UC_MINIGAME_START);
      AddPacket(4,game,1,player_num);
      SendPacket(poSession);

      return;
   }

   UserGotoDeadRoom()
   {
      local oNew_room, iRoom, oRoom;

      if pbLogged_On
      {
         iRoom = Send(poOwner,@GetRoomNum);
      
         if iRoom >= RID_NEWB_BASE AND iRoom <= RID_NEWB_MAX
         {
            Send(self,@TeleportTo,#RID=RID_NEWB1,#bAdminPort=FALSE);
         }
         else
         {
            oNew_room = Send(SYS,@FindRoomByNum,#num=RID_UNDERWORLD);
            if NOT Send(SYS,@UtilGoNearSquare,#what=self,#where=oNew_room,
                        #new_row=24,#new_col=10,
                        #fine_row=38,#fine_col=54,#new_angle=3072)
            {
               Debug("UserGotoDeadRoom unable to Send user to dead room",
                     self,vrName);
               return Send(SYS,@GetFailureRsc);
            }
         }
      }
      else if piSave_Room >= RID_NEWB_BASE AND piSave_Room <= RID_NEWB_MAX
      {
         Debug("Player died while offline, but in newbie area!  (how did "
                "a necromancer get there?):",Send(self,@GetName));
         piSave_Room = RID_NEWB1;
         oRoom = Send(SYS,@FindRoomByNum,#num=RID_NEWB1);
         piSave_Row = Send(oRoom,@GetTeleportRow);
         piSave_Col = Send(oRoom,@GetTeleportCol);
      }
      else
      {
         piSave_Room = RID_UNDERWORLD;
         piSave_Row = 24;
         piSave_Col = 10;
         piSave_Fine_Row = 38;
         piSave_Fine_Col = 54;
         piSave_Angle = 3072;
      }

      return Send(SYS,@GetSuccessRsc);
   }

   ToCliObject(what=$,show_type=SHOW_NORMAL,bShow_all=FALSE)
   "show_type is used to get the look or inventory animation and overlays "
   "instead of the normal animation and overlays."
   {
      local iFlags, iEnemyKarma, iSelfKarma, iMinimapFlags, iDrawingFlags;

      % Send given object's id number, name, icon, and animation info

      if IsClass(what,&NumberItem)
      {
         AddPacket(NUMBER_OBJECT,what, 4,Send(what,@GetNumber));
      }
      else
      {
         AddPacket(4, what);
      }

      AddPacket(4,Send(what,@GetIcon));

      % Used for the reveal spell.  Do we show the true name, or the apparent
      % name?
      if bShow_All
      {
         AddPacket(4,Send(what,@GetTrueName));
      }
      else
      {
         AddPacket(4,Send(what,@GetApparentName));
      }

      iDrawingFlags = Send(what,@GetDrawingEffects);
      iFlags = Send(what,@GetObjectFlags);
      % If we can see the invisible object, remove its invis drawing flag
      % and set it to flash instead (in object flags).
      if (piFlags2 & PFLAG2_DETECT_INVIS)
         AND (iDrawingFlags & DRAWFX_MASK) = DRAWFX_INVISIBLE
      {
         iDrawingFlags = (iDrawingFlags & (~DRAWFX_MASK));
         iFlags = (iFlags & (~OF_FLICKERING));
         iFlags = (iFlags | OF_FLASHING);
      }

      if IsClass(what,&Battler)
      {
         iEnemyKarma = Send(what,@GetKarma,#detect=TRUE);
         iSelfKarma = Send(self,@GetKarma);

         if (piFlags2 & PFLAG2_DETECT_EVIL)
            AND iSelfKarma > 0
            AND iEnemyKarma < -10
            AND (IsClass(what,&Player)
                 OR (IsClass(what,&Monster) AND abs(iEnemyKarma) > iSelfKarma))
         {
            iFlags = (iFlags & (~OF_FLICKERING));
            iFlags = (iFlags | OF_FLASHING);
         }

         if (piFlags2 & PFLAG2_DETECT_GOOD)
            AND iSelfKarma < 0
            AND iEnemyKarma > 10
            AND (IsClass(what,&Player)
                 OR (IsClass(what,&Monster) AND iEnemyKarma > abs(iSelfKarma)))
         {
            iFlags = (iFlags & (~OF_FLICKERING));
            iFlags = (iFlags | OF_FLASHING);
         }
      }

      iMinimapFlags = Send(self,@BuildMinimapDotFlag,#what=what);
      if iMinimapFlags = $
      {
         Debug("Got $ minimapflags for self ",self,Send(self,@GetTrueName),
            " for object ",what,Send(what,@GetTrueName));
         iMinimapFlags = 0;
      }

      AddPacket(4,iFlags);
      AddPacket(1,iDrawingFlags);
      AddPacket(4,iMinimapFlags);
      AddPacket(4,Send(what,@GetPlayerNameColor));
      AddPacket(1,Send(what,@GetClientObjectType));
      AddPacket(1,Send(what,@GetMoveOnType));

      % Send the lighting information.
      Send(what,@SendLightingInformation);

      if show_type = SHOW_LOOK
      {
         Send(what,@SendLookAnimation);
         Send(what,@SendLookOverlays);
      }
      else if show_type = SHOW_INVENTORY
      {
         Send(what,@SendInventoryAnimation);
         Send(what,@SendInventoryOverlays);
      }
      else if show_type = SHOW_NORMAL
      {
         Send(what,@SendAnimation);
         Send(what,@SendOverlays);
      }
      else if show_type = SHOW_ENCHANTMENT
      {
         Send(what,@SendEnchantmentAnimation);
         Send(what,@SendEnchantmentOverlays);
      }

      return;
   }

   BuildMinimapDotFlag(what=$)
   "This message builds the minimap dot flags for each object we can see, "
   "which is then sent to our client for drawing objects on the map/minimap."
   {
      local iBehavior, iFlags, oIllusion, oOtherGuild;

      if what = $
         OR poOwner <> Send(what,@GetOwner)
      {
         return MM_NONE;
      }

      if (what = self)
      {
         if (piFlags & PFLAG_TEMPSAFE)
         {
            return MM_TEMPSAFE;
         }

         return MM_NONE;
      }

      iFlags = MM_NONE;

      if IsClass(what,&Reflection)
         OR IsClass(what,&EvilTwin)
      {
         what = Send(what,@GetMaster);
         if what = $
            OR what = self
         {
            return MM_PLAYER;
         }
      }

      if IsClass(what,&Player)
      {
         if Send(what,@IsInCannotInteractMode)
         {
            return MM_NONE;
         }

         oIllusion = Send(what,@GetIllusionForm);

         if NOT Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
            OR oIllusion = $
            OR NOT IsClass(oIllusion,&Monster)
         {
            if Send(Send(SYS,@GetWarEvent),@IsActive)
            {
               if Send(Send(SYS,@GetWarEvent),@IsSameSide,#player1=self,#player2=what)
               {
                  return MM_PLAYER | MM_PLAYER_IS_FRIEND;
               }

               return MM_PLAYER | MM_PLAYER_IS_ENEMY;
            }

            % Standard player blue dot.
            if Send(what,@CheckPlayerFlag,#flag=PFLAG_TEMPSAFE)
            {
               iFlags = iFlags | MM_TEMPSAFE;
            }
            else
            {
               iFlags = iFlags | MM_PLAYER;
            }

            oOtherGuild = Send(what,@GetGuild);
            if poGuild <> $ AND oOtherGuild <> $
            {
               if poGuild = oOtherGuild
               {
                  iFlags = (iFlags | MM_PLAYER_IS_GUILDMATE);
               }

               if Send(poGuild,@IsAlly,#otherguild=oOtherGuild)
                  AND Send(oOtherGuild,@IsAlly,#otherguild=poGuild)
               {
                  iFlags = (iFlags | MM_PLAYER_IS_FRIEND);
               }

               if Send(poGuild,@IsMutualEnemy,#otherguild=oOtherGuild)
               {
                  iFlags = (iFlags | MM_PLAYER_IS_ENEMY);
               }
            }

            % Draw a red halo for any attackable player.
            if NOT IsClass(self,&DM)
               AND Send(self,@AllowPlayerAttack,#victim=what,
                        #report=FALSE,#actual=FALSE)
            {
               iFlags = (iFlags | MM_PLAYER_IS_ENEMY);
            }

            % Add builder group halo.
            if Send(poOwner,@AreGroupedHere,#who=self,#what=what)
            {
               iFlags = (iFlags | MM_BUILDER_GROUP);
            }
         }
         else
         {
            iFlags = (iFlags | MM_MONSTER);
         }
      }

      if IsClass(what,&Monster)
         AND NOT (IsClass(what,&Reflection)
            OR IsClass(what,&EvilTwin))
      {
         if Send(what,@GetMaster) <> $
         {
            if (Send(what,@GetMaster) = self)
            {
               return MM_MINION_SELF;
            }
            else
            {
               return MM_MINION_OTHER;
            }
         }
         if Send(what,@GetBehavior) & AI_NPC
         {
            % Draw dots for NPCs.
            return MM_NPC;
         }
         if IsClass(poOwner,&SurvivalRoom)
         {
            % Survival room specific dots.
            if Send(poOwner,@IsMiniBoss,#what=what)
            {
               return MM_MINIBOSS;
            }
            if Send(poOwner,@IsBoss,#what=what)
            {
               return MM_BOSS;
            }
         }

         return MM_MONSTER;
      }

      % Give masks a black dot.
      if IsClass(what,&FaceMask)
         AND IsClass(poOwner,&SurvivalRoom)
      {
         return MM_NPC;
      }

      return iFlags;
   }

   ToCliPlayer()
   {
      local rMusic, iLight, rBackground;

      AddPacket(1,BP_PLAYER,4,self,4,vrIcon,4,vrName,4,poOwner);
      AddPacket(4,Send(poOwner,@GetRoomResource),4,Send(poOwner,@GetName));
      AddPacket(4,Send(poOwner,@GetRoomSecurity));

      AddPacket(1,Send(poOwner,@GetRoomLight));
      AddPacket(1,bound(piLight,0,255));

      rBackground = Send(poOwner,@GetRoomBackground);
      if rBackground <> $
      {
         AddPacket(4,rBackground);
      }
      else
      {
         AddPacket(4,0);
      }

      Send(poOwner,@SendExtraRoomInfo);

      SendPacket(poSession);

      Send(poOwner,@SendLoopingSounds,#who=self);

      Send(self,@ToCliShading);
      Send(poOwner,@SendSectorChanges,#who=self);
      Send(poOwner,@SendSectorFlagChanges,#who=self);
      Send(poOwner,@SendSectorLightChanges,#who=self);
      Send(poOwner,@SendWallChanges,#who=self);
      Send(poOwner,@SendTextureChanges,#who=self);
      Send(self,@SendUserAllWindowOverlays);
      % Check weather here also.
      Send(self,@WeatherChanged);

      return;
   }

   ToCliShading()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_SHADING);
         AddPacket(1,Send(poOwner,@GetDirectionalLightIntensity));
         AddPacket(2,Send(poOwner,@GetDirectionalLightAngle));
         AddPacket(2,Bound(Send(poOwner,@GetDirectionalLightHeight),0,$));
         SendPacket(poSession);
      }

      return;
   }

   ToCliPlayers()
   "Sends client a list of all users logged on, including object id, "
   "resource id, and actual string of the resource (since it's a dynarsc)."
   {
      local i, lUsers, rName, bVisible;

      lUsers = $;

      foreach i in Send(SYS,@GetUsersLoggedOn)
      {
         bVisible = FALSE;

         % admins see everyone
         if (IsClass(self,&Admin))
         {
            bVisible = TRUE;
         }
         % escaped convict can see self and fellow convicts
         else if (IsClass(self,&EscapedConvict) AND IsClass(i,&EscapedConvict))
         {
            bVisible = TRUE;
         }
         else
         {
            % self is a regular user, here is where to start hiding special
            % players like escaped convict and hidden DMs
            if (IsClass(i,&EscapedConvict)
               OR (IsClass(i,&DM) AND Send(i,@IsHidden)))
            {
               bVisible = FALSE;
            }
            else
            {
               bVisible = TRUE;
            }
         }
            
         if (bVisible)
         {
            lUsers = Cons(i,lUsers);
         }
      }

      AddPacket(1,BP_PLAYERS,2,Length(lUsers));
      foreach i in lUsers
      {
         rName = Send(i,@GetTrueName);

         AddPacket(4,i, 4,rName, STRING_RESOURCE,rName);
         AddPacket(4,Send(i,@GetObjectFlags));
         AddPacket(1,Send(i,@GetDrawingEffects) & ~DRAWFX_INVISIBLE);
         AddPacket(4,0); % minimapflags, don't need the value here.
         AddPacket(4,Send(i,@GetPlayerNameColor));
         AddPacket(1,Send(i,@GetClientObjectType));
         AddPacket(1,0); % MoveOn type, don't need it here.
      }

      SendPacket(poSession);

      return;
   }

   ToCliRoomContents()
   {
      local i, objs, oThing;

      if NOT pbLogged_On
      {
         return;
      }

      objs = Length(Send(poOwner,@GetHolderPassive));

      % We might not include all passive.
      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         % Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         ++objs;
      }

      AddPacket(1,BP_ROOM_CONTENTS, 4,poOwner, 2,objs);

      foreach i in Send(poOwner,@GetHolderActive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);

         % Don't do stealthed DMs.
         if IsClass(oThing,&DM)
            AND Send(oThing,@IsDMStealthed)
            AND oThing <> self
         {
            continue;
         }

         Send(self,@ToCliObject,#what=oThing);
         AddPacket(2,Nth(i,3)*FINENESS+Nth(i,5), 2,Nth(i,4)*FINENESS+Nth(i,6));
         AddPacket(2,Send(oThing,@GetAngle));
         Send(oThing,@SendMoveAnimation);
         Send(oThing,@SendMoveOverlays);
      }

      foreach i in Send(poOwner,@GetHolderPassive)
      {
         oThing = Send(poOwner,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
         AddPacket(2,Nth(i,3)*FINENESS+Nth(i,5), 2,Nth(i,4)*FINENESS+Nth(i,6));
         AddPacket(2,Send(oThing,@GetAngle));
         Send(oThing,@SendMoveAnimation);
         Send(oThing,@SendMoveOverlays);
      }

      SendPacket(poSession);

      % the client resets room icons when it gets BP_ROOM_CONTENTS, so
      % add them back here

      Send(poOwner,@SendEnchantmentIcons,#what=self);

      return;
   }

   ToCliInventory()
   {
      local i,each_obj;

      AddPacket(1,BP_INVENTORY, 2,Length(plActive)+Length(plPassive));

      foreach i in plActive
      {
        Send(self,@ToCliObject,#what=i,#show_type=SHOW_INVENTORY);
      }

      i = Length(plPassive);
      while i > 0
      {
         each_obj = Nth(plPassive,i);
         Send(self,@ToCliObject,#what=each_obj,#show_type=SHOW_INVENTORY);
         --i;
      }

      SendPacket(poSession);

      return;
   }

   ToCliUseList()
   {
      local i;

      AddPacket(1,BP_USE_LIST, 2,Length(plUsing));

      foreach i in plUsing
      {
         AddPacket(4,i);
      }

      SendPacket(poSession);

      return;
   }

   ToCliStats(group = $)
   {
      local i, oSpell, oSkill, iCount, lCurrentResistances, iQLength;

      if NOT pbLogged_on
      {
         return;
      }

      if group = 1
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,4);
         Send(self,@SendStatHealth);
         Send(self,@SendStatMana);
         Send(self,@SendStatVigor);
         Send(self,@SendStatHPChance);
         SendPacket(poSession);

         return;
      }

      if group = 2
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,26);

         Send(self,@SendStatMight);
         Send(self,@SendStatIntellect);
         Send(self,@SendStatStamina);
         Send(self,@SendStatAgility);
         Send(self,@SendStatMysticism);
         Send(self,@SendStatAim);
         Send(self,@SendStatKarma);
         Send(self,@SendStatTraining);
         Send(self,@SendStatBulk);
         Send(self,@SendStatCapacity);
         Send(self,@SendStatOffense);
         Send(self,@SendStatDefense);
         Send(self,@SendStatArmor);

         i = 1;
         lCurrentResistances = Send(self,@GetCurrentResistances);

         while i < 14
         {
            Send(self,@SendStatResistances,#num=i,
                  #lCurrentResistances=lCurrentResistances);
            ++i;
         }

         SendPacket(poSession);

         return;
      }

      if group = 3
      {
         AddPacket(1,BP_STAT_GROUP, 1,group,1, Length(plSpells));
         iCount = 1;
         foreach i in plSpells
         {
            Send(self,@SendStatSpell,#index=iCount);
            iCount = iCount + 1;
         }

         SendPacket(poSession);

         return;
      }

      if group = 4
      {
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,Length(plSkills));
         iCount = 1;
         foreach i in plSkills
         {
            Send(self,@SendStatSkill,#index=iCount);
            iCount = iCount + 1;
         }

         SendPacket(poSession);

         return;
      }

      if group = 5
      {
         % Used for determining index in displayed quests.
         iCount = 1;
         % Need to know how many completed quests in quest history.
         iQLength = Send(self,@GetCompletedQuestLength);
         AddPacket(1,BP_STAT_GROUP, 1,group, 1,Length(plActiveQuests) + iQLength + 2);

         % Send active quests.
         if plActiveQuests <> $
         {
            % Send the "Active Quests" header.
            AddPacket(1,0, 4,user_active_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
            % Followed by all the active quests.
            iCount = Send(self,@SendActiveQuestData,#iCount=iCount);
         }
         else
         {
            % Send the "No Active Quests" header.
            AddPacket(1,0, 4,user_no_active_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
         }

         % Increment count past any active quests.
         iCount = iCount + 1;
         % Send completed quests.
         if plQuestHistory <> $
         {
            % Send the "Completed Quests" header.
            AddPacket(1,iCount, 4,user_completed_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
            % Followed by completed quests.
            Send(self,@SendCompletedQuestData,#iCount=iCount);
         }
         else
         {
            % Send the "No Completed Quests" header.
            AddPacket(1,iCount, 4,user_no_completed_quests_header,
                      1,STAT_LIST, 4,0, 4,0, 4,0);
         }

         SendPacket(poSession);

         return;
      }

      Debug("Invalid stat group number",group,"sent by client");

      return;
   }

   GetCompletedQuestLength()
   {
      local i, iCount, iQTemplate, oQObj, oQE;

      iCount = 0;

      oQE = Send(SYS,@GetQuestEngine);
      foreach i in plQuestHistory
      {
         if First(i) & QUEST_HISTORY_SUCCESS
         {
            iQTemplate = (First(i) & QUEST_HISTORY_MASK);
            oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

            if oQObj = $
            {
               continue;
            }

            if Send(oQObj,@ShowCompletedQuest,#who=self,#lHistory=i)
            {
               iCount = iCount + 1;
            }
         }
      }

      return iCount;
   }

   SendActiveQuestData(iCount=1)
   "Returns the current index count."
   {
      local i, iQTemplate, oQE, oQObj, rQuestName;

      oQE = Send(SYS,@GetQuestEngine);

      foreach i in plActiveQuests
      {
         iQTemplate = First(i);
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

         if oQObj = $
         {
            Debug("User ",Send(self,@GetTrueName),"couldn't get quest object for ",
                  "quest template ",iQTemplate," quest is active.");

            continue;
         }

         rQuestName = Send(oQObj,@GetName);

         % List index, quest name, statistic type, quest object, value (%), icon.
         AddPacket(1,iCount, 4,rQuestName, 1,STAT_LIST,
                   4,oQObj, 4,iQTemplate, 4,Send(oQObj,@GetIcon));
         iCount = iCount + 1;
      }

      % Need to return the current count.
      return iCount;
   }

   SendCompletedQuestData(iCount=1)
   "Returns the current index count."
   {
      local i, iQTemplate, oQE, oQObj, rQuestName;

      oQE = Send(SYS,@GetQuestEngine);

      foreach i in plQuestHistory
      {
         % Only send successfully completed quests for now.
         if NOT (First(i) & QUEST_HISTORY_SUCCESS)
         {
            continue;
         }

         iQTemplate = (First(i) & QUEST_HISTORY_MASK);
         oQObj = Send(oQE,@GetQuestTemplateObject,#index=iQTemplate);

         if oQObj = $
         {
            Debug("User ",Send(self,@GetTrueName),"couldn't get quest object for ",
                  "quest template ",iQTemplate," quest is completed.");

            continue;
         }

         if NOT Send(oQObj,@ShowCompletedQuest,#who=self,#lHistory=i)
         {
            continue;
         }

         rQuestName = Send(oQObj,@GetName);

         % List index, quest name, statistic type, quest object, value (%), icon.
         AddPacket(1,iCount, 4,rQuestName, 1,STAT_LIST,
                   4,oQObj, 4,iQTemplate, 4,Send(oQObj,@GetIcon));
         iCount = iCount + 1;
      }

      % Don't currently use the returned count, but we might one day.
      return iCount;
   }

   ToCliStatGroups()
   {
      AddPacket(1,BP_STAT_GROUPS);
      % 5 stat groups
      AddPacket(1,5);
      AddPacket(4,user_group_condition);
      AddPacket(4,user_group_stats);
      AddPacket(4,user_group_spells);
      AddPacket(4,user_group_skills);
      AddPacket(4,user_group_quests);
      SendPacket(poSession);

      return;
   }

   ToCliSpellSchools()
   {
      local num_schools;

      AddPacket(1,BP_USERCOMMAND, 1,UC_SPELL_SCHOOLS);
      num_schools = 6;
      if viDM
      {
         num_schools = num_schools + 1;
      }

      AddPacket(1,num_schools);
      AddPacket(4,user_school_shallile);
      AddPacket(4,user_school_qor);
      AddPacket(4,user_school_kraanan);
      AddPacket(4,user_school_faren);
      AddPacket(4,user_school_riija);
      AddPacket(4,user_school_jala); 

      if viDM
      {
         AddPacket(4,user_school_dm);
      }

      SendPacket(poSession);

      return;
   }

   ToCliSpells()
   {
      local i,oSpell;

      AddPacket(1,BP_SPELLS, 2,Length(plSpells));

      foreach i in plSpells
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                     #compound=i));
         Send(self,@ToCliObject,#what=oSpell);
         AddPacket(1,Send(oSpell,@GetNumSpellTargets));
         AddPacket(1,Send(oSpell,@GetSchool));
      }

      SendPacket(poSession);
      Send(self,@ToCliStats,#group=3);

      return;
   }

   ToCliSkills()
   {
      local i,oSkill;

      AddPacket(1, BP_SKILLS,2,Length(plSkills));
      foreach i in plSkills
      {
         oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                     #compound=i));
         Send(self,@ToCliObject,#what=oSkill);
      }

      SendPacket(poSession);
      Send(self,@ToCliStats,#group=4);

      return;
   }

   ToCliAddSpell(oSpell = $)
   {
      if pbLogged_on
      {
         AddPacket(1, BP_SPELL_ADD);
         
         Send(self,@ToCliObject,#what=oSpell);
         AddPacket(1,Send(oSpell,@GetNumSpellTargets));
         AddPacket(1,Send(oSpell,@GetSchool));
         SendPacket(poSession);

         Send(self,@ToCliStats,#group=3);
      }

      return;

   }

   ToCliRemoveSpell(oSpell = $)
   {
      if pbLogged_on
      {
         AddPacket(1, BP_SPELL_REMOVE);
         AddPacket(4, oSpell);
         SendPacket(poSession);
      }

      return;
   }

   ToCliAddSkill(oSkill = $)
   {
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=4);
      }

      return;
   }

   ToCliRemoveSkill(oSkill = $)
   {
      if pbLogged_on
      {
         Send(self,@ToCliStats,#group=4);
      }

      return;
   }

   ToCliAddBackgroundOverlay(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_ADD_BG_OVERLAY);
         Send(self,@ToCliBackgroundOverlay,#what=what);
      }

      return;
   }

   ToCliChangeBackgroundOverlay(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE_BG_OVERLAY);
         Send(self,@ToCliBackgroundOverlay,#what=what);
      }

      return;
   }

   ToCliBackgroundOverlay(what = $)
   {
      AddPacket(4,what);
      AddPacket(4,Send(what,@GetIcon));
      AddPacket(4,Send(what,@GetName));
      Send(what,@SendAnimation);
      AddPacket(2,Send(what,@GetBackgroundOverlayAngle));
      AddPacket(2,Send(what,@GetBackgroundOverlayHeight));
      SendPacket(poSession);

      return;
   }

   UserMove(new_row = 1, new_col = 1,
            fine_row = FINENESS/2, fine_col = FINENESS/2, speed = 0)
   {
      local iCurrentTime, iDelta, iDeltaVigor, iExertion, iHasteLevel,
         iAngle, iRow, iCol, iFineRow, iFineCol, iRoomNum,
         iDx, iDy, iMoveLength, iMaxMoveRun, 
         iQflags, iRflags, iHeightF, iHeightFWD, iHeightC, iServerID;

      %
      % 1.1 Get current position values
      %

      iRow = piRow;
      iCol = piCol;
      iFineRow = piFine_row;
      iFineCol = piFine_col;
      iAngle = Send(self,@GetAngle);

      % 
      % 1.2 Get sectorinfo of destination
      %
      iQflags = LIQ_GET_SECTORINFO;
			
      if NOT GetLocationInfoBSP(
                      Send(poOwner,@GetRoomData), iQflags, 
                      new_row, new_col, fine_row, fine_col,
                      *iRflags, *iHeightF, *iHeightFWD, *iHeightC, *iServerID)
      {
         debug("Failed to get location info in ", Send(poOwner,@GetRoomData));
         iRflags = 0;
      }

	  %
      % 2. Do not allow any moves if player is marked as not allowed to move or 
      %    if destination is outside of the map.
      %
      if (piFlags & PFLAG_NO_MOVE) OR NOT (iRflags & LIR_SECTOR_INSIDE)
      {
         % Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         return;
      }

      %
      % 3.1 Get current tick (ms resolution)
      %
      iCurrentTime = GetTickCount();

      %
      % 3.2 Get time-deltas
      %
      iDelta = iCurrentTime - piLastMoveUpdateTime;
      iDeltaVigor = iCurrentTime - piLastVigorDrainTime;

      %
      % 3.3 Bound time-deltas
      %   These must not be too big for the calculations below
      %
      iDelta = Bound(iDelta,0,2000);
      iDeltaVigor = bound(iDeltaVigor,0,2000);

      %
      % 4.1 Calculate the squared movesize for running in this dt.
      %   USER_RUNNING_SPEED is defined as # of big squares per 10000ms
      %   The unit here is fine upscaled by another *16 (same is done below in 4.5)
      %
      iMaxMoveRun = (Bound(speed,0,USER_RUNNING_SPEED) * FINENESS * 16 * iDelta) / 10000;
      iMaxMoveRun = (iMaxMoveRun * iMaxMoveRun);

      %
      % 4.2 Fill up the movement bucket with tokens
      %   for the squared distance one could have travelled at maximum.
      %
      piMovementBucket = piMovementBucket + iMaxMoveRun;

      %
      % 4.3 Bound the maximum bucketsize
      %
      piMovementBucket = Bound(piMovementBucket, 0, Send(SETTINGS_OBJECT,@GetMovementBucketMax));
      %Debug("Bucket before move:",piMovementBucket);

      %
      % 4.4 Get move-deltas in FINENESS units
      %
      iDy = ((new_row * FINENESS) + fine_row) - ((iRow * FINENESS) + iFineRow);
      iDx = ((new_col * FINENESS) + fine_col) - ((iCol * FINENESS) + iFineCol);

      %
      % 4.5 Scale them up a bit further for precision later
      % We did the same with iMaxMoveRun in 4.1
      %
      iDy = iDy * 16;
      iDx = iDx * 16;

      %
      % 4.6 Get squared move-vector length.
      %
      iMoveLength = (iDy * iDy) + (iDx * iDx);

      % DEBUG output
      %Debug(
      %  "iDelta:",iDelta,
      %  "iMaxMoveRun:",iMaxMoveRun,
      %  "iMoveLength:",iMoveLength,
      %  "iRow:",iRow,
      %  "iCol:",iCol,
      %  "iFineRow:",iFineRow,
      %  "iFineCol:",iFineCol,
      %  "new_row:",new_row,
      %  "new_col:",new_col,
      %  "fine_row:",fine_row,
      %  "fine_col:",fine_col);

      %
      % 5.1 This move would consume more tokens
      % than we have left -> deny
      %
      if (piMovementBucket - iMoveLength < 0)
      {
         % Reset position
         Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
               #new_row=iRow,
               #new_col=iCol,
               #fine_row=iFineRow,
               #fine_col=iFineCol,
               #new_angle=iAngle);

         % Make a log entry
         if piCheaterLogs < MAX_LOGGED_THRESHOLD
         {
            piCheaterLogs = piCheaterLogs + 1;
            Debug("ALERT!",Send(self,@GetTrueName),self,"was moving too fast");
         }

         return;
      }

      %
      % 5.2 Double check the user's speed. USER_WALKING_SPEED should
      % be 25, USER_RUNNING_SPEED should be 50. If the speed we've
      % received is less than 25, make it 50 and log that we've
      % changed it.
      %

      if speed < USER_WALKING_SPEED
         OR speed > USER_RUNNING_SPEED
      {
         % Make a log entry
         if piCheaterLogs < MAX_LOGGED_THRESHOLD
         {
            piCheaterLogs = piCheaterLogs + 1;
            Debug("ALERT! ",Send(self,@GetTrueName),self,
                  " had transmitted speed changed from ",speed, "to ",
                  USER_RUNNING_SPEED);
         }
         speed = USER_RUNNING_SPEED;
      }

      %
      % 5.3 This move is bigger than walking allows.
      %
      if (speed > USER_WALKING_SPEED)
      {
         % Disallow run with low vigor
         if piVigor < VIGOR_RUN_THRESHOLD
         {
            % Reset position
            Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
                  #new_row=iRow,
                  #new_col=iCol,
                  #fine_row=iFineRow,
                  #fine_col=iFineCol,
                  #new_angle=iAngle);

            % Make a log entry
            if piCheaterLogs < MAX_LOGGED_THRESHOLD
            {
               piCheaterLogs = piCheaterLogs + 1;
               Debug("ALERT!",Send(self,@GetTrueName),self,"was running with "
                     "no vigor.");
            }

            return;
         }

         % Break trance
         if (piFlags & PFLAG_TRANCE)
         {
            Send(self,@BreakTrance,#event=EVENT_RUN);
         }

         % Stop dance
         if (piFlags2 & PFLAG2_DANCING)
         {
            Send(self,@StopDancing);
         }
      }

      %
      % 5.4 Manual move checks in some rooms
      %
      iRoomNum = Send(poOwner,@GetRoomNum);
      if iRoomNum = RID_CAVE2
         OR iRoomNum = RID_ICE_CAVE1
         OR (iRoomNum >= RID_GUILDH_MIN
            AND iRoomNum <= RID_GUILDH_MAX)
         OR iRoomNum = RID_I9
      {
         if NOT Send(poOwner,@IsMoveOK,
                  #old_row=iRow,#old_col=iCol,#old_fine_row=iFineRow,
                  #old_fine_col=iFineCol,#new_row=new_row,#new_col=new_col,
                  #new_fine_row=fine_row,#new_fine_col=fine_col,#who=self)
         {
            % Rooms now handle logging, for customized debug messages.
            % Reset position
            Send(SYS,@UtilGoNearSquare,#what=self,#where=poOwner,
                  #new_row=iRow,
                  #new_col=iCol,
                  #fine_row=iFineRow,
                  #fine_col=iFineCol,
                  #new_angle=iAngle);

            return;
         }
      }

      %
      % 6. Drain vigor once per 1000 ms.
      %
      if iDeltaVigor >= 1000
      {
         % Reduce speed value to old value, 5/6ths current value, then
         % square it.
         iExertion = (speed * 3)/5;
         iExertion = iExertion * iExertion;
         iExertion = EXERTION_PER_MOVE * iExertion;

         if (piFlags2 & PFLAG2_HASTED)
         {
            iHasteLevel = Send(self,@GetEnchantedState,
                              #what=Send(SYS,@FindSpellByNum,#num=SID_HASTE));

            if iHasteLevel <> $
            {
               iExertion = (iExertion * (100 - iHasteLevel)) / 100;
            }
         }

         Send(self,@AddExertion,#amount=iExertion);

         % Save vigor drain tick
         piLastVigorDrainTime = iCurrentTime;
      }

      %
      % 7. Notify monsters about presence (bitflag check instead of function)
      %
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      %
      % 8. Save this move tick for next execution
      % and subtract the move tokens we have consumed.
      %
      piLastMoveUpdateTime = iCurrentTime;
      piMovementBucket = piMovementBucket - iMoveLength;
      %Debug("Bucket after:",piMovementBucket);

      %
      % 9. Process the move
      %
      Send(poOwner,@SomethingMoved,#what=self,
            #new_row=new_row,#new_col=new_col,
            #fine_row=fine_row,#fine_col=fine_col,
            #cause=CAUSE_USER_INPUT,#speed=speed);

      return;
   }

   NotifyMonstersOfPresence()
   % When a player first enters the room, the game will prevent AIs from
   %  attacking that player until that player takes an action.  This function
   %  is called when a player takes his first action in the room.  It should
   %  be accompanied by a bitcheck of PFLAG_MOVED_SINCE_ENTRY, which was
   %  previously done in a function call, but is now done in a raw bitcheck
   %  for performance reasons (as this needs to be checked pretty much before
   %  a player does anything).  See UserMove() for an example of the correct
   %  usage of this function.
   {
      % Sanity check, or if we want to call the function externally.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@SetPlayerFlag,#flag=PFLAG_MOVED_SINCE_ENTRY,#value=TRUE);  
         Send(poOwner,@FirstMove,#what=self,#new_row=piRow,#new_col=piCol);
      }

      return;
   }

   UserTurn(what = $, new_angle = 0)
   {
      if what <> self
      {
         Debug("User tried to turn object other than self: ",what);
         
         return;
      }

      % Do not allow angle changes while we are immobile.
      if (piFlags & PFLAG_NO_MOVE)
         AND ((NOT Send(self,@IsResting))
              OR Send(self,@IsEnchanted,#byClass=&Hold))
      {
         Send(poOwner,@SomethingTurned,#what=self,
              #new_angle=Send(self,@GetAngle));

         return;
      }

      if new_angle < 0 or new_angle > MAX_ANGLE 
      {
         Debug("Invalid turn angle: ",new_angle);

         return;
      }

      Send(poOwner,@SomethingTurned,#what=self,#new_angle=new_angle,
           #cause=CAUSE_USER_INPUT);

      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      return;
   }

   UserAppeal(string = $, first_time = FALSE)
   {
      local i, lUsers;

      lUsers = Send(SYS,@GetUsersLoggedOn);
      foreach i in lUsers
      {
         if IsClass(i,&DM) AND Send(i,@IsAppealOn)
         {
            if NOT first_time
            {
               Send(i,@MsgSendUser,#message_rsc=user_appeal,#parm1=vrName,
                    #parm2=string);
            }
            else
            {
               Send(i,@MsgSendUser,#message_rsc=user_first_time_appeal,
                    #parm1=vrName);
            }
         }
      }

      if IsClass(self,&DM) OR first_time
      {
         % Don't tell DMs and Admins that the appeal was heard,
         %  since this is always true.
         return;
      }

      Send(self,@MsgSendUser,#message_rsc=user_did_appeal,#parm1=string);

      return;
   }

   MsgSendUserCallback(what=$, sCallback=$, parm1=$, parm2=$, parm3=$, parm4=$)
   "Adds a BP_MESSAGE packet, calls the message in sCallback, then sends the "
   "packet to the user.  Used so other objects don't need to add the protocol "
   "message, or obtain the user's session.  sCallback is a string containing "
   "the message name to be called, 'what' is the calling object."
   {
      if sCallback <> $
         AND IsString(sCallback)
         AND what <> $
         AND pbLogged_on
      {
         AddPacket(1,BP_MESSAGE);

         % The called message should return TRUE to let us know building the
         % packet was successful, otherwise we clear the packet.
         if Send(what,sCallBack,#parm1=parm1,#parm2=parm2,
                  #parm3=parm3,#parm4=parm4)
         {
            SendPacket(poSession);
         }
         else
         {
            ClearPacket();
         }
      }

      return;
   }

   MsgSendUser(message_rsc = $,
               parm1 = $,parm2 = $,parm3 = $,parm4 = $,
               parm5 = $,parm6 = $,parm7 = $,parm8 = $,
               type1 = STANDARD_RESOURCE,type2 = STANDARD_RESOURCE,
               type3 = STANDARD_RESOURCE,type4 = STANDARD_RESOURCE,
               type5 = STANDARD_RESOURCE,type6 = STANDARD_RESOURCE,
               type7 = STANDARD_RESOURCE,type8 = STANDARD_RESOURCE,
               report = TRUE)
   {
      if pbLogged_on
         AND report
      {
         AddPacket(1,BP_MESSAGE,4,message_rsc);

         if parm1 <> $
         {
            AddPacket(type1,parm1);
         }
         if parm2 <> $
         {
            AddPacket(type2,parm2);
         }
         if parm3 <> $
         {
            AddPacket(type3,parm3);
         }
         if parm4 <> $
         {
            AddPacket(type4,parm4);
         }
         if parm5 <> $
         {
            AddPacket(type5,parm5);
         }
         if parm6 <> $
         {
            AddPacket(type6,parm6);
         }
         if parm7 <> $
         {
            AddPacket(type7,parm7);
         }
         if parm8 <> $
         {
            AddPacket(type8,parm8);
         }

         SendPacket(poSession);
      }

      return;
   }

   SysMsgSendUser(message_rsc = $,parm1 = $,parm2 = $,parm3 = $,parm4 = $,
                  parm5 = $,parm6 = $,parm7 = $,parm8 = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SYS_MESSAGE,4,message_rsc);
         if parm1 <> $
         {
            AddPacket(4,parm1);
         }
         if parm2 <> $
         {
            AddPacket(4,parm2);
         }
         if parm3 <> $
         {
            AddPacket(4,parm3);
         }
         if parm4 <> $
         {
            AddPacket(4,parm4);
         }
         if parm5 <> $
         {
            AddPacket(4,parm4);
         }
         if parm6 <> $
         {
            AddPacket(4,parm4);
         }
         if parm7 <> $
         {
            AddPacket(4,parm4);
         }
         if parm8 <> $
         {
            AddPacket(4,parm4);
         }

         SendPacket(poSession);
      }

      return;
   }

   WaveSendUser(wave_rsc = $, source_obj = 0, flags = 0, row = 0, col = 0,
                cutoff_radius = 0, max_volume = 0)
   %  If source_obj defined, use its location for source of sound
   %  if not, check row & col, and use that location if either or both are
   %  non-zero finally, default to sound originating at user
   %  Valid flags are:
   %   SOUND_LOOP to loop the sound til player leaves room
   %   SOUND_RANDOM_PITCH to choose a random pitch for the sound
   %  For looping sounds, cutoff_radius and max_volume are used set
   %  attenuation parameters
   {
      if (wave_rsc <> $) and (pbLogged_on)
      {
         AddPacket(1,BP_PLAY_WAVE, 4,wave_rsc, 4,source_obj, 1,flags,
                   4,row, 4,col, 4,cutoff_radius, 4,max_volume);
         SendPacket(poSession);
      }

      return;
   }

   WaveSendUserStop(wave_rsc = $, source_obj = 0)
   % Sends a message to the client to stop playing a wav using the resource ID.
   {
      if (wave_rsc <> $) and (pbLogged_on)
      {
         AddPacket(1,BP_STOP_WAVE, 4,wave_rsc, 4,source_obj);
         SendPacket(poSession);
      }

      return;
   }

   SendRoomMusic(music_rsc = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_PLAY_MUSIC);
         if music_rsc = $
         {
            AddPacket(4,0);
         }
         else
         {
            AddPacket(4,music_rsc);
         }

         SendPacket(poSession);
      }

      return;
   }

   MidiSendUser(midi_rsc = $)
   {
      if (midi_rsc <> $) AND (pbLogged_on)
      {
         AddPacket(1,BP_PLAY_MIDI);
         if midi_rsc = $
         {
            AddPacket(4,0);
         }
         else
         {
            AddPacket(4,midi_rsc);
         }

         SendPacket(poSession);
      }

      return;
   }

   GoodSpellFlashEffect()
   {
      Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
            #duration=100,#xlat=GOOD_COLOR);

      return;
   }

   BadSpellFlashEffect()
   {
      Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
            #duration=100,#xlat=BAD_COLOR);

      return;
   }

   DamageTypeFlashEffect(aspell=0, duration=800)
   {
      if aspell & ATCK_SPELL_QUAKE
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=65);
      }
      else if aspell & ATCK_SPELL_HOLY
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=116);
      }
      else if aspell & ATCK_SPELL_UNHOLY
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=112);
      }
      else if aspell & ATCK_SPELL_ACID
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=86);
      }
      else if aspell & ATCK_SPELL_COLD
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=85);
      }
      else if aspell & ATCK_SPELL_SHOCK
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=82);
      }
      else if aspell & ATCK_SPELL_FIRE
      {
         Send(self,@EffectSendUserDurationAndXlat,#effect=EFFECT_FLASHXLAT,
               #duration=duration,#xlat=81);
      }

      return;
   }

   SendEffectData()
   {
      return;
   }

   EffectSendUser(what = $,effect = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT,2,effect);
         Send(what,@SendEffectData,#what=self);

         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserXLat(what = $, xlat = 0)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT);
         AddPacket(2,EFFECT_XLATOVERRIDE,4,xlat);

         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserDuration(what = $, effect = $, duration = 1000)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT,2,effect);
         AddPacket(4,duration);
         SendPacket(poSession);
      }

      return;
   }

   EffectSendUserDurationAndXlat(what = $, effect = $, duration = 100,
                                 xlat = 0)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_EFFECT, 2,effect, 4,duration, 4,xlat);
         SendPacket(poSession);
      }

      return;
   }

   SectorSendUser(animation = $,sector = $,height = $,speed = $)
   "Sent by room when one of its sectors changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_MOVE,1,animation,2,sector,2,height,1,speed);
         SendPacket(poSession);
      }

      return;
   }

   SectorLightSendUser(sector = $,light_effect = $)
   "Sent by room when one of its sector lights changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_LIGHT,2,sector,1,light_effect);
         SendPacket(poSession);
      }

      return;
   }

   WallSendUser(wall = $, animation = $, first_group = $, second_group = $,
               end_group = $, speed = $, passable = $)
   "Sent by room when one of its walls changes.  <Passable> = $ means leave "
   "alone."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_WALL_ANIMATE,2,wall);

         AddPacket(1,animation);
         if animation = ANIMATE_NONE
         {
            AddPacket(2,first_group);
         }
         else if animation = ANIMATE_ONCE
         {
            AddPacket(4,speed, 2,first_group, 2,second_group, 2,end_group);
         }
         else if animation = ANIMATE_CYCLE
         {
            AddPacket(4,speed, 2,first_group, 2,second_group);
         }

         if passable = $
         {
            AddPacket(1,0);
         }
         else if passable
         {
            AddPacket(1,1);
         }
         else
         {
            AddPacket(1,2);
         }

         SendPacket(poSession);
      }

      return;
   }

   TextureSendUser(id = $,new_texture = $,flags = 0)
   "Sent by room when one of its textures changes."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE_TEXTURE,2,id,2,new_texture,1,flags);

         SendPacket(poSession);
      }

      return;
   }

   SectorChangeSendUser(sector=$, depth=$, scrollSpeed=$)
   "Sent by room when one of the sector's properties have changed. "
   "This handles scrolling and depth which rarely require changing, "
   "other protocols already handle animation and textures."
   {
      if pbLogged_on
      {
         AddPacket(1,BP_SECTOR_CHANGE,2,sector,1,depth,1,scrollSpeed);

         SendPacket(poSession);
      }

      return;
   }

   GameStateSendUser(game = $, state = $)
   "Sends game state to player"
   {
      if pbLogged_on
      {
         AddPacket(1, BP_USERCOMMAND, 1, UC_MINIGAME_MOVE);
         AddPacket(4, game);

         % Send default state if the game hasn't started yet
         if (state = $)
         {
            AddPacket(STRING_RESOURCE,Send(game,@GetDefaultState));
         }
         else
         {
            AddPacket(0, state);
         }

         SendPacket(poSession);
      }

      return;
   }

   GamePlayerSendUser(who = $, num = $)
   "Sends game player name to player (for minigames, like chess)"
   {
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND, 1,UC_MINIGAME_PLAYER, 1,num,
                   STRING_RESOURCE,Send(who,@GetTrueName));

         SendPacket(poSession);
      }

      return;
   }

   UserGet(what = $, report = TRUE)
   {
      local oOldOwner, i, lItem_pos, iRow, iCol, iRow_dist, iCol_dist,
            iCan_hold, oSplit, oCorpse, bFromReagentBag;

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,
               #wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      oOldOwner = Send(what,@GetOwner);

      % Make sure we're not trying to get something we've already got!
      if oOldOwner = self
      {
         return 0;
      }

      if oOldOwner <> $
         AND IsClass(oOldOwner,&ReagentBag)
      {
         bFromReagentBag = TRUE;
      }
      else
      {
         bFromReagentBag = FALSE;
      }

      % Make sure object still exists, etc, so we don't cause errors
      if Send(SYS,@UtilGetRoom,#what=what) <> poOwner
         OR IsClass(Send(what,@GetOwner),&User)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_unk,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      lItem_pos = Send(what,@GetPos);
      if lItem_pos = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_unk,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      iRow = First(lItem_pos);
      iCol = Nth(lItem_pos,2);

      iRow_dist = piRow - iRow;
      if iRow_dist < 0
      {
         iRow_dist = -1 * iRow_dist;
      }

      iCol_dist = piCol - iCol;
      if iCol_dist < 0
      {
         iCol_dist = -1 * iCol_dist;
      }

      if (iRow_dist + iCol_dist) > 7
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_dist,#report=report,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 2;
      }

      % This includes the corpse pointer, which prevents people
      % from looting each other's kills.
      if NOT Send(what,@ReqNewOwnerAttributes,#who=self)
      {
         return 0;
      }

      if oOldOwner <> $
         AND NOT Send(oOldOwner,@ReqTaker,#what=what,#taker=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      if NOT Send(what,@ReqNewOwner,#what=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         Send(self,@WaveSendUser,#what=self,#wave_rsc=user_cant_pickup_item_wav_rsc);

         return 0;
      }

      if NOT Send(self,@ReqNewHold,#what=what)
      {
         if IsClass(what,&NumberItem)
         {
            iCan_hold = Send(self,@GetNumberCanHold,#what=what);
            if iCan_hold > 0
            {
               oSplit = Send(what,@Split,#number=iCan_hold);
               if Send(what,@ReqNewOwner,#what=oSplit)
               {
                  Send(self,@MsgSendUser,#message_rsc=user_got_some,#report=report,
                       #parm1=Send(what,@GetName));
                  Send(self,@NewHold,#what=oSplit,#bFromReagentBag=bFromReagentBag);

                  return 3;
               }
               else
               {
                  Send(what,@AddNumber,#number=iCan_hold);
                  Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                       #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
                  Send(self,@WaveSendUser,#what=self,
                       #wave_rsc=user_cant_pickup_item_wav_rsc);

                  return 4;
               }
            }
            else
            {
               Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                    #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
               Send(self,@WaveSendUser,#what=self,
                    #wave_rsc=user_cant_pickup_item_wav_rsc);

               return 4;
            }
         }
         else
         {
            %  KLUDGE!!  -Asif
            if NOT IsClass(what,&HunterSword)
            {
               Send(self,@MsgSendUser,#message_rsc=user_disallow_get,#report=report,
                     #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
               Send(self,@WaveSendUser,#what=self,
                     #wave_rsc=user_cant_pickup_item_wav_rsc);
            }

            return 4;
         }
      }

      % shrunken head picked up
      if isClass(what,&ShrunkenHead)
      {
         Send(what,@PickedUp,#by=self);
      }

      Send(self,@NewHold,#what=what,#bFromReagentBag=bFromReagentBag);

      return 1;
   }

   UserBlockedSend(what = $)
   "Sent by client when they're blocking messages from a user, and that "
   "user Sends a message."
   {
      return;
   }

   UserDrop(what = $,number = $)
   {
      local i,Item_pos,oNumber;

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_drop);

         return;
      }

      if Send(self,@IsInCannotInteractMode)
      {
         Send(self,@MsgSendUser,#message_rsc=phased_out_cant_drop);
         return FALSE;
      }

      if IsClass(what,&NumberItem)
      {
         if number <= 0
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         oNumber = Send(what,@Split,#number=number);
         if oNumber = $
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_have_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         if Send(oNumber,@ReqNewOwner,#what=poOwner)
            AND Send(poOwner,@ReqNewHold,#what=oNumber,
                     #new_row=piRow,#new_col=piCol)
         {
            Send(poOwner,@NewHold,#what=oNumber,#new_row=piRow,#new_col=piCol,
                 #fine_row=piFine_row,#fine_col=piFine_col);
         }
         else
         {
            Send(what,@Join,#what=oNumber);

            Send(self,@MsgSendUser,#message_rsc=user_disallow_drop, 
                 #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
         }

         return;
      }

      if Send(what,@ReqNewOwner,#what=poOwner)
         AND Send(poOwner,@ReqNewHold,#what=what,#new_row=piRow,#new_col=piCol)
      {
         Send(poOwner,@NewHold,#what=what,#new_row=piRow,#new_col=piCol,
               #fine_row=piFine_row,#fine_col=piFine_col);

         % Shrunken head dropped by owner
         if IsClass(what, &ShrunkenHead)
         {
            Send(what,@Dropped,#by=self,#where=poOwner);
         }
      }

      return;
   }

   UserMoveInventoryItem(what=$,where=$)
   "User moved an item in their inventory. Assuming everything checks out, "
   "we move it in the plPassive list also."
   {
      local iWhere, lSafeList;

      if what = $
         OR where = $
         OR what = where
         OR plPassive = $
      {
         return;
      }

      if FindListElem(plPassive,what) = 0
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to move ",
               "inventory item ",what,Send(what,@GetName)," they didn't have!");

         return;
      }
      % Get list position for the drop location.
      iWhere = FindListElem(plPassive,where);
      if iWhere = 0
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to move ",
               "inventory item ",what,Send(what,@GetName)," to invalid location of ",
               where,Send(where,@GetName));

         return;
      }

      % MUST reassign this to plPassive, in case we're deleting the first
      % list node. Use a temp list to verify there were no issues.
      lSafeList = DelListElem(plPassive,what);
      if lSafeList <> $
      {
         plPassive = lSafeList;
      }
      else
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to set ",
               "plPassive to $ when deleting a list element! ",plPassive,
               what,Send(what,@GetName));
      }

      % MUST reassign this to plPassive, in case we're creating the first list node.
      lSafeList = InsertListElem(plPassive,iWhere,what);
      if lSafeList <> $
      {
         plPassive = lSafeList;
      }
      else
      {
         Debug("ALERT!  ",self,Send(self,@GetTrueName)," tried to set ",
               "plPassive to $ when adding a list element! ",plPassive,what,iWhere);
      }

      return;
   }

   UserPut(what = $,where = $,number = $)
   {
      local i, lObjects, lItem_pos, oNumber;

      % User took an action!  Wake any AIs in the room to the user's presence!
      %  bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)  
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      % Detect if someone's using an exploit to put items into another player.
      if IsClass(where,&User)
      {
         Debug("ALERT! ",Send(self,@GetTrueName),self," tried to 'put' items "
               "into player ",Send(where,@GetTrueName),where);

         return;
      }

      if NOT IsClass(where,&Holder)
         AND NOT IsClass(where,&ReagentBag)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_put,
               #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
               #parm3=Send(where,@GetDef),#parm4=Send(where,@GetName),
               #parm5=Send(where,@GetDef),#parm6=Send(where,@GetName));

         return;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_drop);

         return;
      }

      if Send(where,@IsHolding,#what=what)
      {
         Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to put a "
               "duplicate item in a chest.");

         return;
      }

      if IsClass(what,&NumberItem)
      {
         if number <= 0
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         oNumber = Send(what,@Split,#number=number);
         if oNumber = $
         {
            Send(self,@MsgSendUser,#message_rsc=user_not_have_number, 
                 #parm1=Send(what,@GetName));

            return;
         }

         if Send(oNumber,@ReqNewOwner,#what=where)
            AND Send(where,@ReqNewHold,#what=oNumber,#who=self)
         {
            Send(where,@NewHold,#what=oNumber);
         }
         else
         {
            Send(self,@NewHold,#what=oNumber); % rejoin, usually

            Send(self,@MsgSendUser,#message_rsc=user_disallow_drop, 
                 #parm1=Send(oNumber,@GetDef),#parm2=Send(oNumber,@GetName));
         }

         return;
      }

      if Send(what,@ReqNewOwner,#what=where)
         AND Send(where,@ReqNewHold,#what=what,#who=self)
      {
         Send(where,@NewHold,#what=what);
      }
      else
      {
         Send(self,@MsgSendUser,#message_rsc=user_disallow_put,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName),
              #parm3=Send(where,@GetDef),#parm4=Send(where,@GetName));
      }

      return;
   }

   UserObjectContents(what = $)
   {
      local i,iObjs,oThing,rName,rIcon,lHolding1,lHolding2;

      if NOT IsClass(what,&Holder)
         AND NOT IsClass(what,&ReagentBag)
         OR (IsClass(what,&Player)
             AND NOT (what = self OR IsClass(self,&Admin)))
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_get_contents,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return;
      }

      % Make sure object is in the same room as player
      if NOT Send(self, @IsInSameRoom, #what = what)
      {
         Debug("User ", self, vrName, "tried to look at object in another room");
         return;
      }

      if IsClass(what,&StorageBox)
         AND NOT Send(poOwner,@LineOfSight,#obj1=self,#obj2=what)
      {
         Debug("User ", self, vrName, "tried to look at storebox item they could not see!");
         return;
      }

      if IsClass(what,&Player)
      {
         lHolding1 = Send(what,@GetPlayerUsing);
         lHolding2 = $;
      }
      else if IsClass(what,&ReagentBag)
      {
         lHolding1 = Send(what,@GetReagentBagContents);
         lHolding2 = $;
      }
      else
      {
         lHolding1 = Send(what,@GetHolderActive);
         lHolding2 = Send(what,@GetHolderPassive);
      }

      iObjs = Length(lHolding1) + Length(lHolding2);
      AddPacket(1,BP_OBJECT_CONTENTS,4,what,2,iObjs);

      foreach i in lHolding1
      {
         oThing = Send(what,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
      }

      % passive are in lholding2
      foreach i in lHolding2
      {
         oThing = Send(what,@HolderExtractObject,#data=i);
         Send(self,@ToCliObject,#what=oThing);
      }

      SendPacket(poSession);

      return;
   }

   UserSay(type=$,string=$)
   {
      local i, oSpell, lEnchantData, bTranceBlocksSay;

      % A room can completely block a piece of communication if it chooses.
      % An excellent example is Out Of Grace, which blocks all tells to 
      % non-DMs, as well as Guild Tells and Broadcasts

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if type = SAY_NORMAL
      {
         if StringContain(string,user_say_survival)
            AND Send(poOwner,@GetRoomNum) <> RID_OUTOFGRACE
         {
            % If UserSaySurvival handles the string, don't keep checking.
            if Send(self,@UserSaySurvival,#string=string)
            {
               return;
            }
         }

         if StringContain(string,user_say_inventory)
         {
            % If UserSayInventory handles the string, don't keep checking.
            if Send(self,@UserSayInventory,#string=string)
            {
               return;
            }
         }
      }

      if NOT Send(poOwner,@RoomReqCommunication,#type=type,#string=string,
                  #who=self)
      {
         return;
      }

      if type = SAY_GUILD
      {
         if StringContain(string,user_say_guild_motd)
         {
            % If UserSayGuildMOTD handles the string, don't keep checking.
            if Send(self,@UserSayGuildMOTD,#string=string)
            {
               return;
            }
         }

         % If the user has tells squelched, block guild sends too.
         if NOT Send(self,@TrySayGroup)
         {
            return;
         }

         Send(self,@UserSayGuild,#string=string);

         return;
      }

      if type = SAY_NORMAL
         OR type = SAY_EMOTE
         OR type = SAY_DM
      {
         if (piFlags & PFLAG_TRANCE)
         {
            % See if the trance spell does anything special 
            %  with says.  Note that the 'say' will still go off.

            bTranceBlocksSay = FALSE;
            
            foreach i in plEnchantments
            {
               if IsClass(nth(i,2),&Trance)
               {
                  lEnchantData = nth(i,3);
                  oSpell = first(lEnchantData);
                  Post(oSpell,@SomethingSaidDuringTrance,
                       #who=self,#string=string,#lTargets=Nth(lEnchantData,3));
                  
                  if Send(oSpell,@TranceBlocksSay)
                  {
                     bTranceBlocksSay = TRUE;
                  }
               }

               if bTranceBlocksSay
               {
                  return;
               }
            }
         }

         % If the user has says squelched, don't let them speak.
         if Send(self,@TrySay)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,#string=string);
         }

         return;
      }

      if type = SAY_MESSAGE
      {
         if Send(self,@IsActor)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,
                 #string=user_echo_str,#parm1=string);
         }

         return;
      }

      if type = SAY_YELL
      {
         % Send to adjacent rooms
         % If the user has says squelched, don't let them speak.
         if Send(self,@TrySay)
         {
            Send(poOwner,@SomeoneSaidRoom,#what=self,#type=type,#string=string);
         }

         return;
      }

      if type = SAY_EVERYONE
      {
         if stringContain(string,"~r~B~g~r")
         {
            piCheaterLogs = piCheaterLogs + 1;
            if piCheaterLogs < 10
            {
               if StringContain(string,"More than 20 bad bio characters.")
               {
                  Debug("ALERT! ",Send(self,@GetTrueName),self," used more "
                        "than 20 bad chars in their bio.");
               }
               else
               {
                  piCheaterLogs = piCheaterLogs + 1;
                  Debug("ALERT! ",Send(self,@GetTrueName),self," used more "
                        "than 50 bad chars in their bio.");
               }
            }

            return;
         }

         % Send to everyone, if not squelched.
         if Send(self,@TryBroadcast)
         {
            Send(SYS,@SystemBroadcast,#what=self,#type=type,#string=string);
         }

         return;
      }

      Debug("Got unknown user say type",type);

      return;
   }

   UserSayGuildMOTD(string = $)
   {
      if poGuild = $
      {
         return FALSE;
      }

      if StringContain(string,guild_motd_command)
         AND (Send(poGuild,@GetRank,#who=self) = RANK_MASTER
            OR Send(poGuild,@GetRank,#who=self) = RANK_LIEUTENANT)
      {
         Send(poGuild,@SetGuildMOTD,#who=self,#string=string);

         return TRUE;
      }

      if StringContain(string,guild_clear_motd_command)
         AND Send(poGuild,@GetGuildMaster) = self
         AND (Send(poGuild,@GetRank,#who=self) = RANK_MASTER
            OR Send(poGuild,@GetRank,#who=self) = RANK_LIEUTENANT)
      {
         Send(poGuild,@SetGuildMOTD,#who=self,#string=$);

         return TRUE;
      }

      return FALSE;
   }

   UserSayInventory(string = $)
   {
      local i, lSortInfo, oTemplateItem, n, bFound;

      if StringEqual(string,user_say_inv_sort_clear)
      {
         plClassOrderPreferences = $;
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_cleared);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort_report)
      {
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_report_header);

         lSortInfo = Send(SYS,@GetSortInfo);

         foreach i in plClassOrderPreferences
         {
            bFound = FALSE;
            foreach n in lSortInfo
            {
               if Nth(n,2) = i
               {
                  Send(self,@MsgSendUser,#message_rsc=inventory_sort_report,
                        #parm1=Nth(n,1));
                  bFound = TRUE;

                  break;
               }
            }

            if bFound
            {
               continue;
            }

            oTemplateItem = Send(SYS,@FindTemplateItemByClass,#cClass=i);

            if oTemplateItem <> $
            {
               Send(self,@MsgSendUser,#message_rsc=inventory_sort_report,
                     #parm1=Send(oTemplateItem,@GetName));
            }
         }

         return TRUE;
      }

      if StringContain(string,user_say_inv_sort_add)
      {
         StringSubstitute(string,user_say_inv_sort_add,"");

         lSortInfo = Send(SYS,@GetSortInfo);

         foreach i in lSortInfo
         {
            if StringEqual(string,First(i))
            {
               if plClassOrderPreferences <> $
                  AND FindListElem(plClassOrderPreferences,Nth(i,2)) <> 0
               {
                  Send(self,@MsgSendUser,#message_rsc=inventory_already_in_list);

                  return TRUE;
               }

               plClassOrderPreferences =
                       AppendListElem(Nth(i,2),plClassOrderPreferences);

               Send(self,@MsgSendUser,#message_rsc=inventory_class_added,
                     #parm1=First(i));

               return TRUE;
            }
         }

         oTemplateItem = Send(SYS,@FindTemplateItemByName,#string=string);

         if oTemplateItem <> $
         {
            plClassOrderPreferences = AppendListElem(GetClass(oTemplateItem),
                                             plClassOrderPreferences);
            Send(self,@MsgSendUser,#message_rsc=inventory_class_added,
                  #parm1=Send(oTemplateItem,@GetName));

            return TRUE;
         }

         Send(self,@MsgSendUser,#message_rsc=inventory_sort_no_item);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort_help)
      {
         Send(self,@MsgSendUser,#message_rsc=inventory_sort_help);

         return TRUE;
      }

      if StringEqual(string,user_say_inv_sort)
      {
         plPassive = Send(SYS,@SortItemsByType,#lItems=plPassive,
                           #lClassOrder=plClassOrderPreferences);
         Send(self,@ToCliInventory);
         Send(self,@ToCliUseList);

         return TRUE;
      }

      return FALSE;
   }

   UserSaySurvival(string = $)
   {
      local lSurvivalOptions, oForceBaseRoom;

      if IsClass(poOwner,&SurvivalRoom)
      {
         % Can't start an arena from an existing one.
         return FALSE;
      }

      if StringContain(string,user_say_start_solo_survival)
      {
         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
               #who=self,#sString=string);

         return TRUE;
      }

      if StringEqual(string,user_say_join_pub_survival)
      {
         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindPublicRoom) = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_no_public_rooms);

            return TRUE;
         }

         if Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindPublicRoom),@GetAllowJoins)
         {
            Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindPublicRoom),@Teleport,#what=self);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=public_survival_too_late);
         }

         return TRUE;
      }

      if StringContain(string,user_say_start_pub_survival)
      {
         lSurvivalOptions = $;
         if (NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1)
            AND NOT IsClass(self,&Admin)
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         oForceBaseRoom = $;
         if IsClass(self,&DM)
         {
            if StringContain(string,user_say_survival_opt_unnatural)
            {
               lSurvivalOptions = Cons(OPT_NATURAL,lSurvivalOptions);
            }
            if StringContain(string,user_say_survival_opt_pvpon)
            {
               lSurvivalOptions = Cons(OPT_PVP_ON,lSurvivalOptions);
            }
            if StringContain(string,user_say_survival_opt_starthere)
            {
               oForceBaseRoom = poOwner;
            }
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindPublicRoom) = $
         {
            Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
                  #who=self,#iPublic=TRUE,#sString=string,
                  #lSurvivalOptions=lSurvivalOptions,
                  #oForceBaseRoom=oForceBaseRoom);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_already_public);
         }

         return TRUE;
      }

      if StringEqual(string,user_say_join_guild_survival)
      {
         if poGuild = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_no_guild);

            return TRUE;
         }

         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindRoomByGuild,
                  #oGuild=poGuild) = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_no_guild_rooms);

            return TRUE;
         }

         if Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindRoomByGuild,#oGuild=poGuild),@GetAllowJoins)
         {
            Send(Send(Send(SYS,@GetSurvivalRoomMaintenance),
                  @FindRoomByGuild,#oGuild=poGuild),@Teleport,#what=self);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=guild_survival_too_late);
         }

         return TRUE;
      }

      if StringContain(string,user_say_start_guild_survival)
      {
         lSurvivalOptions = $;
         if poGuild = $
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_no_guild);

            return TRUE;
         }

         if NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
            OR Send(poOwner,@GetRoomNum) = RID_UNDERWORLD
            OR Send(poOwner,@GetRoomNum) = RID_FIELD1
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_not_safe);

            return TRUE;
         }

         if Send(Send(SYS,@GetSurvivalRoomMaintenance),@FindRoomByGuild,
                  #oGuild=poGuild) = $
         {
            Send(Send(SYS,@GetSurvivalRoomMaintenance),@CreateRoom,
                  #who=self,#sString=string,#guild_survival=TRUE);
         }
         else
         {
            Send(self,@MsgSendUser,#message_rsc=survival_err_already_guild);
         }

         return TRUE;
      }

      return FALSE;
   }

   UserSayGuild(string = $)
   {
      local i,lUsers,each_obj;

      if poGuild = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_say_guild);

         return;
      }

      lUsers = $;
      foreach i in Send(poGuild,@GetMemberList)
      {
         each_obj = First(i);
         if each_obj <> self and Send(each_obj,@IsLoggedOn)
         {
            lUsers = Cons(each_obj,lUsers);
         }
      }

      if Length(lUsers) = 0
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_guild_logged_on);

         return;
      }

      Send(self,@UserSayGroup,#users=lUsers,#string=string,#no_tell=TRUE);

      return;
   }

   UserSayGroup(users = $,string = $,no_tell=FALSE)
   "<no_tell> = True means always Send the 'Sends' message, not 'tells'"
   {
      local i,type;

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }   

      % A bit hackish, no_tell is currently only used for guild Sends.  Don't
      %  do TrySayGroup on guild Sends to eliminate mana costs.
      if no_tell OR Send(self,@TrySayGroup,#users=users)
      {
         AddPacket(1,BP_SAID,4,self,4,vrName,1,SAY_GROUP);
         if Length(users) = 1 AND NOT no_tell
         {
            AddPacket(4,user_send_single_echo_str,
                      4,Send(First(users),@GetTrueName), 0,string);
         }
         else
         {
            AddPacket(4,user_send_echo_str, 0,string);
         }
         
         SendPacket(poSession);
         
         if IsClass(self,&DM)
            AND Send(self,@IsHidden)
            AND NOT IsClass(First(users),&Admin)
         {
            % The admin is hidden, warn them about that.
            Send(self,@MsgSendUser,#message_rsc=user_no_respond);
         }

         type = SAY_GROUP;
         if Length(users) = 1 AND NOT no_tell
         {
            type = SAY_GROUP_ONE;
         }

         if NOT Send(poOwner,@RoomReqCommunication,#type=type,#string=string,
                     #who=self,#users=users)
         {
            return;
         }

         foreach i in users
         {
            Send(i,@SomeoneSaid,#what=self,#type=type,#string=string);
         }
      }

      return;
   }

   UserLook(what = $)
   {
      % User took an action!  Wake any AIs in the room to the user's presence!
      % Use a bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      Send(what,@TryLook,#what=self);
%      Send(self,@SetPlayerView,#what=what,
%         #iFlags =   REMOTE_VIEW_CONTROL | REMOTE_VIEW_TURN  
%                   | REMOTE_VIEW_TILT | REMOTE_VIEW_MID
%                   | REMOTE_VIEW_VALID_LIGHT,
%         #iLight = LIGHT_MAX);
      return;
   }

   SendLook(what = $, bShow_All = FALSE)
   {
      local byInscription, oOwner;

      if pbLogged_on
      {
         if what <> $
            AND NOT IsObject(what)
         {
            % Log a debug message for this
            Debug("User ",self," tried to look at non-object ",
                  what);

            return;
         }

         if IsClass(what,&ReagentBag)
            AND Send(what,@GetReagentBagContents) <> $
         {
            Send(self,@UserObjectContents,#what=what);
            return;
         }

         AddPacket(1,BP_LOOK);
         Send(self,@ToCliObject,#what=what,#show_type=SHOW_LOOK,
              #bShow_All=bShow_All);

         byInscription = 0x00;
         oOwner = Send(what,@GetOwner);
         if Send(what,@HasInscription)
         {
            byInscription = byInscription | 0x02;
         }

         if Send(what,@CanEditInscription)
            AND (oOwner = self OR oOwner = poOwner)
         {
            byInscription = byInscription | 0x01;
         }

         AddPacket(1, byInscription);

         Send(what,@ShowDesc,#bShowAll = bShow_All,#who=self);

         if (byInscription)
         {
            Send(what,@ShowInscription);
         }

         SendPacket(poSession);
      }

      return;
   }

   SendLookNews(what = $)
   {
      if pbLogged_on
         AND (Send(what,@GetNewsPermission,#what=self) & NEWS_PERMISSION_READ)
      {
         AddPacket(1,BP_LOOK_NEWSGROUP);
         AddPacket(2,Send(what,@GetNewsNum));
         AddPacket(1,Send(what,@GetNewsPermission,#what=self));

         Send(self,@ToCliObject,#what=what);
         Send(what,@ShowDesc);

         SendPacket(poSession);
      }

      return;
   }

   SendLookPlayerIllusion(what = $)
   {
      local iIllusion_type,oIllusion,oSpell;

      oSpell = Send(SYS,@findspellbynum,#num=SID_MORPH);
      if Send(what,@IsEnchanted,#what=oSpell)
      {
         iIllusion_type = First(Send(what,@GetEnchantedState,#what=oSpell));
         if iIllusion_type = $
         {
            return;
         }

         oIllusion = Nth(Send(SYS,@GetMonsterTemplates),iIllusion_type);
      }

      else
      {
         oSpell = Send(SYS,@FindSpellByNum,#num=SID_FEIGN_DEATH);
         if Send(what,@IsEnchanted,#what=oSpell)
         {
            % The illusion is the first element of the list.
            oIllusion = first(Send(what,@GetEnchantedState,#what=oSpell));
         }
      }

      Send(self,@SendLook,#what=oIllusion);

      return;
   }

   SendLookPlayer(what = $)
   {
      if pbLogged_on
      {
         if Send(what,@checkplayerflag,#flag=PFLAG_MORPHED)
            OR Send(what,@IsEnchanted,
                    #what=Send(SYS,@FindSpellByNum,#Num=SID_FEIGN_DEATH))
         {
            Send(self,@SendLookPlayerIllusion,#what=what);

            return;
         }

         AddPacket(1,BP_USERCOMMAND,1,UC_LOOK_PLAYER);

         Send(self,@ToCliObject,#what=what,#show_type=SHOW_LOOK);

         % Can viewer edit description and web page?  Send 1 or 0.
         if what = self
            OR IsClass(self,&Admin)
         {
            AddPacket(1,1);
         }
         else
         {
            AddPacket(1,0);
         }

         Send(what,@ShowDesc);
         Send(what,@ShowExtraInfo);

         if Send(what,@GetURL) = $
         {
            AddPacket(STRING_RESOURCE,user_default_url);
         }
         else
         {
            AddPacket(0,Send(what,@GetURL));
         }

         SendPacket(poSession);
      }

      return;
   }

   TryLook(what = $)
   {
      if (piFlags & PFLAG_INVISIBLE)
         AND what <> self
         AND NOT Send(self,@PlayerIsImmortal)
      {
         return;
      }

      if NOT Send(self, @IsInSameRoom, #what = what)
      {
         Debug("User ", self, "tried to look at object in another room");
         return;
      }

      Send(what,@SendLookPlayer,#what=self);

      return;
   }

   UserLookupNames(amount = $,string = $)
   "Sent by client to resolve a string of mail destination into object IDs."
   {
      AddPacket(1,BP_LOOKUP_NAMES);
      AddPacket(2,amount);

      ParseString(string,",",@UserLookupEachName);
      SendPacket(poSession);

      return;
   }

   UserLookupEachName(string = $)
   "Used to find names for mail."
   {
      local oUser, lNames, oMailingList;

      if StringEqual(string,user_guild_rsc)
         AND poGuild <> $
      {
         AddPacket(4,poGuild);
      }
      else
      {
         % don't enable mailing lists yet
         if FALSE AND StringEqual(string,user_guildofficer_rsc)
            AND poGuild <> $
         {
            lNames = Send(poGuild,@GetOfficers);
            oMailingList = Create(&MailingList,#thePerson=lNames);
            AddPacket(4,oMailingList);
         }
         else
         {
            oUser = Send(SYS,@FindUserByString,#string=string);

            if oUser = $
            {
               AddPacket(4,0);
            }
            else
            {
               AddPacket(4,oUser);
            }
         }
      }

      return;
   }

   UserChangeDescription(string = $)
   {
      local iCount;

      if string = $
      {
         string = psPlayerDescription;
      }

      if StringContain(psPlayerDescription,"")
      {
         iCount = 0;
         while StringContain(psPlayerDescription,"")
         {
            StringSubstitute(psPlayerDescription,"","");
            iCount = iCount + 1;
            if iCount > 10
            {
               % At this point, it's malicious.
               Debug("ALERT! ",Send(self,@GetTrueName)," is trying to crash "
                     "the server via bad bio characters.");
               string = CreateString();

               break;
            }
         }
      }

      psPlayerDescription = string;

      return;
   }

   GetURL()
   {
      return psURL;
   }

   UserChangeURL(string = $)
   {
      if StringLength(string) > MAX_URL_LEN
      {
         Debug(self,Send(self,@GetTrueName),
               "tried to set URL larger than MAX_URL_LEN");

         return;
      }

      psURL = string;

      return;
   }

   UserTryActivate(what = $)
   {
      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if IsClass(what,&Sun) OR IsClass(what,&Moon)
      {
         % No message for background overlays.
         return;
      }

      if Send(what,@GetOwner) <> poOwner
      {
         Send(self,@MsgSendUser,#message_rsc=user_err_activate_unk,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
              
         return;
      }

      if NOT Send(what,@TryActivate,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_activate_failed,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return;
      }

      return;
   }

   UserMail(dest_list = $,string = $)
   {
      local i;

      % 11/21/2014 Keen - why is this even here?  commented out for now.
      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      %if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      %{
      %   Send(self,@NotifyMonstersOfPresence);
      %}

      if StringLength(string) > MAIL_MESSAGE_MAX_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_mail_toobig);

         return;
      }

      Send(self,@MsgSendUser,#message_rsc=user_mail_to);

      foreach i in dest_list
      {
         Send(i,@ReceiveMail,#from=Send(self,@GetTrueName),
              #dest_list=dest_list,#perm_string=string);
      }

      return;
   }

   UserGetNewMail()
   {
      local i, j, lNew_mail, iNum, iIndex, lMail_strings;

      if plNew_mail = $
      {
         AddPacket(1,BP_MAIL,4,0,4,0,2,0,4,0);
         SendPacket(poSession);

         return;
      }

      % Send one BP_MAIL message for each new mail message
      iNum = Length(plNew_mail);
      i = 0;

      while i < iNum
      {
         % take new mail from the end of the list,
         % so they are in order of arrival
         iIndex = Length(plNew_Mail) - i;

         % This is a list of [ from, time, list of to ]
         lNew_mail = Nth(plNew_mail, iIndex);

         AddPacket(1,BP_MAIL, 4,iIndex, STRING_RESOURCE,First(lNew_mail),
                   4,Nth(lNew_mail,2), 2,Length(Nth(lNew_mail,3)));
         foreach j in Nth(lNew_mail,3)
         {
            AddPacket(STRING_RESOURCE,Send(j,@GetTrueName));
         }

         lMail_strings = Nth(lNew_mail,4);
         if Length(lMail_strings) = 1
         {
            % standard string as mail
            AddPacket(4,user_show_mail);
            AddPacket(0,First(lMail_strings));
         }
         else
         {
            % nested % things as mail
            AddPacket(4,user_show_nested_mail);
            j = 1;
            while j <= Length(lMail_strings)
            {
               AddPacket(Nth(lMail_strings,j),Nth(lMail_strings,j+1));
               j = j + 2;
            }

         }

         SendPacket(poSession);
         i = i + 1;
      }

      return;
   }

   UserDeleteMail(index = $)
   {
      local lNew_Mail;

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)  
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if index <> $
         AND plNew_mail <> $
      {
         if Length(plNew_mail) < index
         {
            Debug(self,"Delete mail got invalid index",index);

            return;
         }

         lNew_mail = Nth(plNew_mail, index);
         plNew_mail = DelListElem(plNew_mail, lNew_mail);
      }

      return;
   }

   UserUseItem(what = $)
   {
      % check if valid, if item, if holding

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item)
      {
         return;
      }

      Send(self,@TryUseItem,#what=what);

      return;
   }

   UserUnuseItem(what = $)
   {
      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item)
      {
         return;
      }

      if NOT Send(self,@IsHolding,#what=what)
      {
         return;
      }

      Send(self,@TryUnuseItem,#what=what);

      return;
   }

   UserAttack(type=STROKE_NORMAL,what=$)
   {
      local i, use_weapon, stroke_id, stroke_obj, is_spell;

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_ATTACK);
      }

      if (piFlags & PFLAG_NO_FIGHT)
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_fight);

         return FALSE;
      }

      % Get use_weapon
      use_weapon = Send(self,@GetWeapon);

      % Convert type over to a stroke here.
      if type = STROKE_NORMAL
      {
         % Kludgeish (at least sloppy code): If we have a spell-weapon,
         %  we just use punch to pass the checks below.
         if (use_weapon = $) OR IsClass(use_weapon,&Spell)
         {
            stroke_id = SKID_PUNCH;
         }
         else
         {
            stroke_id = Send(use_weapon,@GetDefaultStrokeNumber);
         }
      }
      else
      {
         Debug("Non-normal stroke received.");

         return FALSE;
      }

      % except for punch and slash, a player cannot use an attack type he
      % doesn't have.  This in to prevent hacking.
      if stroke_id <> SKID_PUNCH
         AND stroke_ID <> SKID_SLASH
         AND stroke_ID <> SKID_FIRE 
      {
         if NOT Send(self,@HasSkill,#num=stroke_id)
         {
            stroke_obj = Send(SYS,@FindSkillByNum,#num=stroke_ID);
            Send(self,@MsgSendUser,#message_rsc=user_doesnt_know_stroke,
                 #parm1=Send(stroke_obj,@GetName));

            return FALSE;
         }
      }

      % Get what's possible
      if NOT IsClass(what,&Battler)
      {
         % tell 'em
         Send(self,@MsgSendUser,#message_rsc=user_cant_attack_non_battler,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));

         return FALSE;
      }

      % kludgish: If morphed, use punch as our stroke object, we use the
      %  monster's stats for combat.
      if Send(self,@IsEnchanted,#byClass=&Morph)
      {
         stroke_id = SKID_PUNCH;
         use_weapon = $;
      }

      if use_weapon = $ OR NOT IsClass(use_weapon,&Spell)
      {
         stroke_obj = Send(SYS,@FindSkillByNum,#num=stroke_id);
      }
      else
      {
         % Use the "weapon" (spell) as the stroke object.
         stroke_obj = use_weapon;
      }

      return Send(self,@TryAttack,#what=what,#use_weapon=use_weapon,
                  #stroke_obj=stroke_obj);
   }

   UserCast(oSpell=$,lTargets=$)
   {
      local i, bFound, iSpell, iSpellNum, iSpellPower, lFinalTargets;

      % Check for valid spell first. This is mainly an issue during
      % system saves where a user might cast something with the wrong
      % object ID.
      if oSpell = $
         OR NOT IsClass(oSpell,&Spell)
      {
         return;
      }

      % Command minions to aid in combat
      if lTargets <> $
         AND IsClass(oSpell,&AttackSpell)
      {
         Send(self,@CommandMinionAttack,#oMaster=self,#oTarget=First(lTargets));
      }

      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      if piFlags & PFLAG_TRANCE
      {
         Send(self,@BreakTrance,#event=EVENT_CAST,#what=oSpell);
      }

      if ((piFlags & PFLAG_NO_MAGIC)
         OR Send(self,@IsInCannotInteractMode))
         AND NOT IsClass(oSpell,&Phase)
         AND NOT IsClass(oSpell,&Spectate)
      {
         Send(self,@MsgSendUser,#message_rsc=user_no_cast);

         return;
      }

      iSpellNum = Send(oSpell,@GetSpellNum);

      bFound = FALSE;
      foreach i in plSpells
      {
         iSpell = Send(self,@DecodeSpellNum,#compound=i);
         if iSpellNum = iSpell
         {
            bFound = TRUE;

            break;
         }
      }

      if NOT bFound
      {
         % We don't know the spell.  Bail out.
         return;
      }

      % Do we need a specific set of targets?
      lFinalTargets = Send(oSpell,@GetTargets,#who=self,#lTargets=lTargets);

      if NOT Send(poOwner,@ReqSpellCast,#who=self,#oSpell=oSpell,
                  #lItems=lFinalTargets)
      {
         % A spell cannot be cast in this room.
         return;
      }

      % Get the spell power
      iSpellPower = Send(oSpell,@GetSpellPower,#who=self,
                          #lTargets=lFinalTargets);

      % First make sure user has enough magic points, reagents, etc.
      if NOT Send(oSpell,@CanPayCosts,#who=self,#lTargets=lFinalTargets,
                  #iSpellpower=iSpellpower)
      {
         % Player failed some sort of internal check
         return;
      }

      if Send(oSpell,@PayCosts,#who=self,#iSpellPower=iSpellPower,
              #lTargets=lFinalTargets)
      {
         Send(oSpell,@BeginCastingTrance,#who=self,#lTargets=lFinalTargets,
              #iSpellPower=iSpellPower);
      }

      return;
   }

   UserGuildCommand(Command_num = $, oTarget = $, data = $)
   "Used to perform a guild command - may need to be modified by Andrew to"
   "fit better with the needed client stuff."
   "Data varies with the command - currently used for setrank."
   {
      local oCommand;

      if poGuild = $
      {
         return;
      }

      oCommand = Send(SYS,@FindGuildCommandByNum,#num=Command_num);

      % If a player is in a trance, break it
      if piFlags & PFLAG_TRANCE
         AND (Command_num = GCID_RENOUNCE
            OR Command_num = GCID_DISBAND)
      {
         Send(self,@BreakTrance,#event=EVENT_CAST,#what=oCommand);
      }

      % Be sure player has guild command.
      if Send(self,@HasGuildCommand,#command_num=Command_num)
      {
         Send(oCommand,@DoCommand,#who=self,#oTarget=oTarget,#data=data);
      }

      return;
   }

   UserAction(action = $)
   {
      % User took an action!  Wake any AIs in the room to the user's presence!
      % bitflag check instead of function for speed.
      if NOT (piFlags & PFLAG_MOVED_SINCE_ENTRY)  
      {
         Send(self,@NotifyMonstersOfPresence);
      }

      % Make this count as an attack.  This prevents action spamming.
      % IsOkayAttackTime defaults to 1 second
      if NOT Send(self,@IsOkayAttackTime)
      {
         return;
      }

      if action = UA_WAVE
      {
         Send(self,@DoWave);

         return;
      }

      if action = UA_POINT
      {
         Send(self,@DoPoint);

         return;
      }

      if action = UA_DANCE
      {
         Send(self,@DoDance);

         return;
      }

      % All other actions above UA_WRY have been checked above.
      if action > UA_WRY
      {
         return;
      }

      piAction = action;

      if piAction < 1
      {
         piAction = 1;
      }

      Send(poOwner,@SomethingDidAction,#what=self,#action=action);

      return;
   }

   UserOffer(what = $,item_list = $,number_list = $)
   {
      local i, lObjects, lNumbers, oOffer_num;

      if Send(self,@IsInCannotInteractMode)
      {
         return FALSE;
      }

      % Must be holding things you're offering, and have no dupes.
      lObjects = $;
      foreach i in item_list
      {
         if lObjects <> $
            AND FindListElem(lObjects,i) <> 0
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to offer a "
                  "duplicate item to",Send(what,@GetTrueName),what,".");

            return FALSE;
         }

         if Send(i,@GetOwner) <> self
         {
            return FALSE;
         }

         lObjects = Cons(i,lObjects);
      }

      % Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad offer quantity", i, "from user", self);

            return FALSE;
         }
      }

      if poOffer_who <> $
         OR NOT Send(what,@CanAcceptOffer,#who=self)
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_offer,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetName));
              
         return FALSE;
      }

      if Send(poOwner,@IsArena)
         AND NOT Send(poOwner,@CanOffer,#who=self,#target=what)
      {
         return FALSE;
      }

      poOffer_who = what;
      plOffer_items = $;

      lNumbers = number_list;
      foreach i in item_list
      {
         if IsClass(i,&NumberItem)
         {
            oOffer_num = Create(GetClass(i),#number=Bound(First(lNumbers),
                                0,Send(i,@GetNumber)));
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }
      }

      if not Send(what,@ReqOffer,#what=self,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         return;
      }

      AddPacket(1,BP_OFFERED,2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      Send(what,@Offer,#what=self,#item_list=plOffer_items);

      return;
   }

   UserDeposit(what = $,item_list = $,number_list = $)
   {
      local i, lNumbers, oOffer_num, iNumber;

      % Only deposit to NPCs.
      if NOT IsClass(what,&Monster)
      {
         return FALSE;
      }

      % Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad deposit quantity", i, "from user", self);

            return FALSE;
         }
      }

      % must be holding things you're offering
      foreach i in item_list
      {
         if Send(i,@GetOwner) <> self
         {
            return;
         }
      }

      if poOffer_who <> $
         OR NOT (Send(what,@MobIsVaultman,#who=self)
                 OR (Send(what,@MobIsBanker,#who=self)
                     AND Length(item_list)=1
                     AND IsClass(First(item_list),&Money)) )
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_deposit_items);

         return FALSE;
      }

      poOffer_who = what;
      plOffer_items = $;

      lNumbers = number_list;
      foreach i in item_list
      {
         if IsClass(i,&NumberItem)
         {
            iNumber = Bound(First(lNumbers),0,Send(i,@GetNumber));
            oOffer_num = Create(GetClass(i),#number=iNumber);
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }
      }

      if NOT Send(what,@ReqOffer,#what=self,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         return;
      }

      AddPacket(1,BP_OFFERED,2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      Send(what,@Offer,#what=self,#item_list=plOffer_items);

      return;
   }

   RemoveNumberItemFromPossession(ToBeRemoved=$)
   "This is used with the offer setup, to remove number objects if you"
   "use number items as quest objects with ReqOffer."
   {
      local i, how_many;

      how_many = Send(ToBeRemoved,@GetNumber);
      foreach i in plPassive
      {
         if GetClass(i) = GetClass(ToBeRemoved)
         {
            if how_many > Send(i,@getnumber)
            {
               Debug("Not enough of those numberitems!");

               return FALSE;
            }
            else
            {
               Send(i,@SubtractNumber,#number=how_many);

               return TRUE;
            }
         }
      }

      Debug("player has none of this class!");

      return FALSE;
    }

   CanAcceptOffer(who=$)
   "Returns true, since all players can accept offers."
   {
      if poOffer_who <> $
      {
         Send(who,@MsgSendUser,#message_rsc=user_offer_busy,
              #parm1=Send(self,@GetCapDef),#parm1=Send(self,@GetName));

         return FALSE;
      }

      return TRUE;
   }

   ReqOffer(what = $,item_list = $)
   {
      local i, whatOwner;

      whatOwner = Send(what,@GetOwner);
      if whatOwner = $
      {
         return FALSE;
      }

      % If we're offline now, or in the process of going offline,
      % let the offering player know.
      if poOwner = $
         OR NOT pbLogged_on
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_not_online,
               #parm1=Send(self,@GetCapDef),#parm2=Send(self,@GetName));

         return FALSE;
      }

      % Different screens, let the offering player know.
      if whatOwner <> poOwner
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_not_here,
               #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
               #parm3=Send(self,@GetHeShe));

         % Perhaps we've just left the room as the offer is being made, in
         % which case this is a spurious log. The RIDs will determine whether
         % this is adjacent screens or an impossible offer.
         Debug("ALERT! ",Send(what,@GetTrueName),what," in RID ",
               Send(poOwner,@GetRoomNum)," offered items to ",
               Send(self,@GetTrueName),self," in distant RID ",
               Send(Send(what,@GetOwner),@GetRoomNum));

         return FALSE;
      }

      % Only one offer at a time.
      if poOffer_who <> $
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_busy,
              #parm1=Send(self,@GetCapDef),#parm1=Send(self,@GetName));

         return FALSE;
      }

      % Check if we can receive the items.
      foreach i in item_list
      {
         if NOT Send(i,@ReqNewOwnerAttributes,#who=self,#type=1)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   Offer(what = $, item_list = $)
   {
      local i;

      if poOffer_who <> $
      {
         Send(what,@MsgSendUser,#message_rsc=user_offer_busy,#parm1=vrName);
         Send(what,@OfferCanceled);

         return;
      }

      poOffer_who = what;

      Send(self,@SysMsgSendUser,#message_rsc=user_got_offer,
           #parm1=Send(poOffer_who,@GetDef),#parm2=Send(poOffer_who,@GetName));

      AddPacket(1,BP_OFFER);
      Send(self,@ToCliObject,#what=what);
      AddPacket(2,Length(item_list));

      foreach i in item_list
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      return;
   }

   UserCancelOffer()
   {
      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_cancel_offer);

         return;
      }

      Send(poOffer_who,@OfferCanceled);

      Send(self,@CleanupCancelOffer);

      return;
   }

   CleanupCancelOffer()
   {
      local i;

      poOffer_who = $;
      foreach i in plOffer_items
      {
         if IsClass(i,&NumberItem)
         {
            Send(i,@Delete);
         }
      }

      plOffer_items = $;

      return;
   }

   OfferCanceled()
   {
      if poOffer_who <> $
      {
         Send(self,@MsgSendUser,#message_rsc=user_canceled_offer, 
              #parm1=Send(poOffer_who,@GetCapDef),
              #parm2=Send(poOffer_who,@GetName));
      }

      Send(self,@CleanupCancelOffer);

      if pbLogged_on
      {
         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);
      }

      return;
   }

   CancelIfOffer()
   {
      if poOffer_who <> $
      {
         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);

         Send(poOffer_who,@OfferCanceled);

         Send(self,@CleanupCancelOffer);
      }

      return;
   }

   UserCounterOffer(item_list = $,number_list = $)
   {
      local i, lNumbers, lObjects, oOffer_num;

      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_counteroffer);

         return;
      }

      % Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad counteroffer quantity", i, "from user", self);

            return FALSE;
         }
      }

      plOffer_items = $;
      lNumbers = number_list;
      lObjects = $;
      foreach i in item_list
      {
         if lObjects <> $
            AND FindListElem(lObjects,i) <> 0
         {
            Debug("ALERT! ",Send(self,@GetTrueName),self,"tried to "
                  "counter-offer a duplicate item to",
                  Send(poOffer_who,@GetTrueName),poOffer_who,".");
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if Send(i,@GetOwner) <> self
         {
            return FALSE;
         }

         if IsClass(i,&NumberItem)
         {
            if First(lNumbers) <= 0 OR First(lNumbers) > Send(i,@GetNumber)
            {
               Send(self,@MsgSendUser,#message_rsc=user_cant_deal_number, 
                    #parm1=First(lNumbers));
               Send(self,@CancelIfOffer);

               return;
            }

            oOffer_num = Create(GetClass(i),#number=First(lNumbers));
            plOffer_items = Cons(oOffer_num,plOffer_items);
            lNumbers = Rest(lNumbers);
         }
         else
         {
            plOffer_items = Cons(i,plOffer_items);
         }

         lObjects = Cons(i,lObjects);
      }

      AddPacket(1,BP_COUNTEROFFERED, 2,Length(plOffer_items));
      foreach i in plOffer_items
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);
      if NOT Send(poOffer_who,@CounterOffer,#item_list=plOffer_items)
      {
         Send(self,@CleanupCancelOffer);

         AddPacket(1,BP_OFFER_CANCELED);
         SendPacket(poSession);

         % Send something here?
      }

      return;
   }

   CounterOffer(item_list = $)
   {
      local i;

      if poOffer_who = $
      {
         return FALSE;
      }

      AddPacket(1,BP_COUNTEROFFER,2,Length(item_list));
      foreach i in item_list
      {
         Send(self,@ToCliObject,#what=i);
      }

      SendPacket(poSession);

      pbOffer_OtherAccepted = TRUE;

      return TRUE;
   }

   CheckOfferStuff()
   {
      local i, j, bFound, iWeight, iBulk;

      iWeight = 0;
      iBulk = 0;

      foreach i in plOffer_items
      {
         if NOT Send(i,@ReqNewOwner,#what=poOffer_who)
         {
            Send(self,@MsgSendUser,#message_rsc=user_cant_drop_offer, 
                 #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));
            Send(poOffer_who,@MsgSendUser,#message_rsc=user_didnt_drop_offer, 
                 #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName),
                 #parm3=Send(i,@GetIndef),#parm4=Send(i,@GetName));
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if NOT Send(i,@ReqNewOwnerAttributes,#who=poOffer_who,#type=1)
         {
            Send(self,@CancelIfOffer);

            return FALSE;
         }

         if IsClass(i,&NumberItem)
         {
            bFound = FALSE;
            foreach j in plPassive
            {
               if GetClass(j) = GetClass(i)
               {
                  if Send(j,@GetNumber) < Send(i,@GetNumber)
                  {
                     Send(self,@MsgSendUser,
                          #message_rsc=user_dont_have_number_offer);
                     Send(poOffer_who,@MsgSendUser,
                          #message_rsc=user_didnt_have_offer, 
                          #parm1=Send(self,@GetDef),
                          #parm2=Send(self,@GetName));
                     Send(self,@CancelIfOffer);

                     return FALSE;
                  }

                  bFound = TRUE;

                  break;
               }
            }

            if NOT bFound
            {
               Send(self,@MsgSendUser,#message_rsc=user_dont_have_offer);
               Send(poOffer_who,@MsgSendUser,
                    #message_rsc=user_didnt_have_offer, 
                    #parm1=vrName);
               Send(self,@CancelIfOffer);

               return FALSE;
            }
         }
         else
         {
            if NOT Send(self,@IsHolding,#what=i)
            {
               Send(self,@MsgSendUser,#message_rsc=user_dont_have_offer);
               Send(poOffer_who,@MsgSendUser,
                    #message_rsc=user_didnt_have_offer, 
                    #parm1=vrName);
               Send(self,@CancelIfOffer);
               
               return FALSE;
            }
         }

         iWeight = iWeight + Send(i,@GetWeight);
         iBulk = iBulk + Send(i,@GetBulk);
      }

      % Can they carry the items?
      if NOT Send(poOffer_who,@CanHoldWeightAndBulk,#weight=iWeight,
                  #bulk=iBulk)
      {
         Send(self,@MsgSendUser,#message_rsc=user_couldnt_carry_offer,
              #parm1=Send(poOffer_who,@GetDef),
              #parm2=Send(poOffer_who,@GetName));
         Send(poOffer_who,@MsgSendUser,#message_rsc=user_cant_carry_offer,
              #parm1=Send(self,@GetDef),#parm2=Send(self,@GetName));
         Send(self,@CancelIfOffer);

         return FALSE;
      }

      return TRUE;
   }

   OfferSubtractNumberItems()
   {
      local i,j,bFound;

      foreach i in plOffer_items
      {
         if IsClass(i,&NumberItem)
         {
            foreach j in plPassive
            {
               if GetClass(j) = GetClass(i)
               {
                  Send(j,@SubtractNumber,#number=Send(i,@GetNumber));
               }
            }
         }
      }

      return;
   }

   UserAcceptOffer()
   {
      local i,oHolder,iLists,lTake_items;
      
      if poOffer_who = $
      {
         Send(self,@MsgSendUser,#message_rsc=user_cant_acceptoffer);

         return;
      }

      if NOT pbOffer_OtherAccepted
      {
         Debug("ALERT!  Player ",Send(self,@GetTrueName),self," tried "
               "complete an offer without the other person accepting.");
         Send(self,@CancelIfOffer);

         return FALSE;
      }
      else
      {
         pbOffer_OtherAccepted = FALSE;
      }

      if NOT Send(self,@CheckOfferStuff)
      {
         return;
      }

      if IsClass(poOffer_who,&User)
         AND NOT Send(poOffer_who,@CheckOfferStuff)
      {
         return;
      }

      Send(self,@OfferSubtractNumberItems);
      Send(poOffer_who,@OfferSubtractNumberItems);

      oHolder = Send(SYS,@GetSystemHolder1);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
      }

      Send(poOffer_who,@AcceptOffer);

      % take his stuff
      oHolder = Send(SYS,@GetSystemHolder2);
      iLists = 1;
      while iLists <= 2
      {
         if iLists = 1
         {
            lTake_items = Send(oHolder,@GetHolderActive);
         }
         if iLists = 2
         {
            lTake_items = Send(oHolder,@GetHolderPassive);
         }

         foreach i in lTake_items
         {
            if Send(self,@ReqNewHold,#what=i)
            {
               Send(self,@NewHold,#what=i);
            }
            else
            {
               if Send(poOwner,@ReqNewHold,#what=i,#new_row=piRow,
                       #new_col=piCol)
               {
                  % Send self warning
                  Send(poOwner,@NewHold,#what=i,#new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col);
               }
            }
         }

         iLists = iLists + 1;
      }

      poOffer_who = $;
      plOffer_items = $;

      return;
   }

   AcceptOffer()
   {
      local i,oHolder,iLists,lTake_items;

      % drop the stuff

      oHolder = Send(SYS,@GetSystemHolder2);
      foreach i in plOffer_items
      {
         Send(oHolder,@NewHold,#what=i);
      }

      % take his stuff

      oHolder = Send(SYS,@GetSystemHolder1);
      iLists = 1;
      while iLists <= 2
      {
         if iLists = 1
         {
            lTake_items = Send(oHolder,@GetHolderActive);
         }

         if iLists = 2
         {
            lTake_items = Send(oHolder,@GetHolderPassive);
         }

         foreach i in lTake_items
         {
            if Send(self,@ReqNewHold,#what=i)
            {
               Send(self,@NewHold,#what=i);
            }
            else
            {
               if Send(poOwner,@ReqNewHold,#what=i,
                       #new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col)
               {
                  Send(self,@MsgSendUser,#message_rsc=user_cant_offer_get, 
                       #parm1=Send(i,@GetDef),#parm2=Send(i,@GetName));
                  Send(poOwner,@NewHold,#what=i,#new_row=piRow,#new_col=piCol,
                       #fine_row=piFine_row,#fine_col=piFine_col);
               }
            }
         }

         iLists = iLists + 1;
      }

      poOffer_who = $;
      plOffer_items = $;

      % Send a "cancelled" to make dialog go away
      AddPacket(1,BP_OFFER_CANCELED);
      SendPacket(poSession);

      return TRUE;
   }

   UserGo()
   {
      local bCanGo;

      if (piFlags & PFLAG_NO_MOVE)
         OR Send(self,@IsEnchanted,#byClass=&Blind)
      {         
         Send(self,@MsgSendUser,#message_rsc=user_cant_go);
         Send(self, @WaveSendUser, #what = self,
              #wave_rsc = user_cant_go_wav_rsc);
         return;
      }

      bCanGo = Send(poOwner,@SomethingTryGo,#what=self,#row=piRow,#col=piCol,
                    #fine_row=piFine_row,#fine_col=piFine_col);

      if bCanGo = $ OR (NOT bCanGo)
      {
         if bCanGo = $
         {
            Debug("SomethingTryGo not properly set for room ",
                  Send(poOwner,@GetTrueName));
         }

         Send(self,@MsgSendUser,#message_rsc=user_cant_go);
         Send(self, @WaveSendUser, #what = self,
              #wave_rsc = user_cant_go_wav_rsc);

         return;
      }

      return;
   }

   UserBuy(what = $)
   {
      local i,lSaleItems;

      lSaleItems = $;
      lSaleItems = Send(what,@GetForSale,#who=self);
      if lSaleItems = $
      {
         return;
      }

      AddPacket(1,BP_BUY_LIST);

      Send(self,@ToCliObject,#what=what);
      AddPacket(2,Length(lSaleItems));

      if Send(what,@MobIsVaultman)
      {
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetVaultRetrievalFee,#what=i,#who=self));
         }
      }
      else
      {
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetPrice,#what=i,#who=self));
         }
      }

      SendPacket(poSession);

      return;
   }

   UserWithdrawal(what = $)
   {
      local i,lSaleItems;

      lSaleItems = $;
      lSaleItems = Send(what,@GetForSale,#who=self);
      if lSaleItems = $
      {
         return;
      }

      if Send(what,@MobIsVaultman)
      {
         AddPacket(1,BP_WITHDRAWAL_LIST);

         Send(self,@ToCliObject,#what=what);
         AddPacket(2,Length(lSaleItems));
         foreach i in lSaleItems
         {
            Send(self,@ToCliObject,#what=i);
            AddPacket(4,Send(what,@GetVaultRetrievalFee,#what=i,#who=self));
         }
      }

      SendPacket(poSession);

      return;
   }

   SendBuyGuildHall()
   {
      local i,lHalls,iAvailable;

      if pbLogged_on
      {
         lHalls = Send(SYS,@GetGuildHalls);
         iAvailable = 0;
         foreach i in lHalls
         {
            if Send(i,@GetPurchaseValue,#who=self) <> -1
            {
               iAvailable = iAvailable + 1;
            }
         }

         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_HALLS);
         AddPacket(2,iAvailable);
         foreach i in lHalls
         {
            if Send(i,@GetPurchaseValue,#who=self) <> -1
            {
               AddPacket(4,i, 4,Send(i,@GetName),
                         4,Send(i,@GetPurchaseValue,#who=self),
                         4,24*Send(i,@GetRentValue));
            }
         }

         SendPacket(poSession);
      }

      return;
   }

   SendCreateGuild()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_USERCOMMAND, 1,UC_GUILD_ASK,
                   4,Send(SYS,@GetGuildPrice),
                   4,Send(SYS,@GetGuildSecretPrice));
         SendPacket(poSession);
      }

      return;
   }

   UserBuyItems(what = $,item_list = $,number_list = $)
   {
      local i;

      % Check quantities; must be positive
      foreach i in number_list
      {
         if i < 1
         {
            Debug("Bad buy quantity", i, "from user", self);
            return;
         }
      }

      Send(what,@Buy,#what=self,#item_list=item_list,#number_list=number_list);

      return;
   }

   UserWithdrawalItems(what = $, item_list = $, number_list = $)
   {
      local i;

      % Check quantities; must be positive
      foreach i in number_list
      {
        if i < 1
        {
           Debug("Bad withdrawl quantity", i, "from user", self);
           return;
        }
      }

      Send(what,@Buy,#what=self,#item_list=item_list,#number_list=number_list);

      return;
   }

   UserApply(what = $,apply_on = $)
   {
      if (piFlags & PFLAG_TRANCE)
      {
         Send(self,@BreakTrance,#event=EVENT_USE);
      }

      if NOT IsClass(what,&Item) 
      {
         return;
      }

      Send(self,@TryApplyItem,#what=what,#apply_on=apply_on);

      return;
   }

   UserPost(nid = $,title = $,body = $)
   {
      local oNews;

      % Can't post if squelched
      if piFlags2 & PFLAG2_SQUELCHED_POSTS
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_squelched);

         return;
      }

      % There has to be SOME kind of length limit.
      if StringLength(body) > NEWS_POSTING_MAX_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_toobig);

         return;
      }

      % Check subject length.
      if StringLength(title) > NEWS_POSTING_MAX_SUBJECT_LENGTH
      {
         Send(self,@MsgSendUser,#message_rsc=user_news_subject_toobig);

         return;
      }

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      % Need to be in same room as news globe
      if (NOT Send(poOwner,@ContainsNewsID,#nid=Send(oNews,@GetNewsNum)))
      {
         Debug("Client request for posting news from another room, user = ",
               Send(self,@GetName));

         return;
      }

      if (piTimeNewsPosted + NEWS_POSTING_DELAY) > GetTime()
         AND NOT IsClass(self,&DM)
      {
         if piNumberOfNewsPosts >= NEWS_POSTING_LIMIT
         {
            Send(self,@MsgSendUser,#message_rsc=user_wait_for_news_Posting);

            return;
         }

         piNumberOfNewsPosts = piNumberOfNewsPosts + 1;
      }
      else
      {
         piTimeNewsPosted = GetTime();
         piNumberofNewsPosts = 1;
      }

      if (Send(oNews,@GetNewsPermission,#what=self) & NEWS_PERMISSION_WRITE)
      {
         Send(oNews,@PostNews,#what=self,#title=title,#body=body);
      }

      return;
   }

   UserGetNewsTitles(nid = $)
   {
      local oNews, plMessages, len, message, part, parts, count, max, article;

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      % Need to be in same room as news globe
      if (NOT Send(poOwner, @ContainsNewsID, #nid = Send(oNews, @GetNewsNum)))
      {
         Debug("Client request for reading news from another room, user = ",
               Send(self,@GetName));
         return;
      }

      plMessages = Send(oNews, @GetArticleList);
      len = Length(plMessages);
      part = 1;
      parts = (len - 1) / MAX_ARTICLES_PER_PART + 1;
      max = MAX_ARTICLES_PER_PART;
      message = plMessages;

      while (part <= parts)
      {
         % Figure out how many articles are in this part of the message
         if part = parts
         {
            max = len - (parts - 1) * MAX_ARTICLES_PER_PART;
         }

         AddPacket(1,BP_ARTICLES, 2,nid, 1,part, 1,parts, 2,max);
         count = 0;

         while count < max
         {
            % Article is of form: [ message number, time, Poster, title ]
            article = First(message);
            AddPacket(4,First(article), 4,Nth(article,3),
                      STRING_RESOURCE,Send(Nth(article,2),@GetTrueName),
                      0,Nth(article,4));
            count = count + 1;
            message = Rest(message);
         }

         SendPacket(poSession);
         part = part + 1;
      }

      return;
   }

   UserGetNewsArticle(nid = $,num = $)
   {
      local oNews,sBody;

      oNews = Send(SYS,@FindNewsByNum,#num=nid);
      if oNews = $
      {
         Debug("Can't find newsgroup id",nid);

         return;
      }

      % Need to be in same room as news globe
      if (NOT Send(poOwner, @ContainsNewsID, #nid = Send(oNews, @GetNewsNum)))
      {
         Debug("Client request for reading news from another room, user = ",
               Send(self,@GetName));
         return;
      }

      sBody = Send(oNews,@GetNewsBody,#num=num);
      if sBody = $
      {
         Debug("Client request for nonexistent news article",
               Send(oNews,@GetName),num);
         
         return;
      }

      AddPacket(1,BP_ARTICLE, 0,sBody);
      SendPacket(poSession);

      return;
   }

   NewHold(what = $, bFromReagentBag = FALSE, check_combine = TRUE)
   {
      local i, oLastSpellItem;

      if what = $
         OR what = self
      {
         Debug(Send(self,@GetTrueName),self," got newhold of ",what,
               ". Owner is ",Send(poOwner,@GetName));

         return;
      }

      if IsClass(what,&NumberItem)
         AND NOT IsClass(what,&Food)
         AND NOT IsClass(what,&Ammo)
         AND NOT IsClass(what,&Money)
         AND NOT bFromReagentBag
         AND Send(self,@GetReagentBag) <> $
         AND (piPreferences & CF_REAGENTBAG)
      {
         Post(Send(self,@GetReagentBag),@NewHold,#what=what,
               #where=Send(self,@GetReagentBag));

         return;
      }

      if IsClass(what,&SpellItem)
         AND (piPreferences & CF_AUTOCOMBINE)
         AND check_combine
      {
         foreach i in plPassive
         {
            if GetClass(i) = GetClass(what)
               AND i <> what
            {
               oLastSpellItem = i;
            }
         }

         if oLastSpellItem <> $
         {
            Post(oLastSpellItem,@CombineSpellItems,#what=what);
         }
      }

      propagate;
   }

   NewHoldObject(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVENTORY_ADD);
         Send(self,@ToCliObject,#what=what,#show_type=SHOW_INVENTORY);
         SendPacket(poSession);

         Post(self,@DrawCapacity);
         Post(self,@DrawBulk);
      }

      propagate;
   }

   LeaveHold(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_INVENTORY_REMOVE,4,what);
         SendPacket(poSession);
         Post(self,@DrawCapacity);
         Post(self,@DrawBulk);
      }

      propagate;
   }

   NewOwner(what = $)
   "A user has a new owner when they enter a new room."
   {
      local old;

      old = $;
      Send(self,@CancelIfOffer);

      % Count right now as the last time we moved.
      piLastMoveUpdateTime = GetTickCount();
      
      % This is here because it has to be done before poOwner is changed.

      % If newbie is entering a kill zone, warn him.  If he is leaving
      %  one, then tell him he's safe again.  Ignore during chaos night.

      if NOT Send(SYS,@GetChaosNight)
         AND NOT (piFlags & PFLAG_PKILL_ENABLE)
      {
         if Send(what,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
            AND (poOwner = $
                 OR NOT Send(poOwner,@CheckRoomFlag,#flag=ROOM_KILL_ZONE))
         {
            Send(self,@MsgSendUser,#message_rsc=user_kill_zone);
         }

         if NOT Send(what,@CheckRoomFlag,#flag=ROOM_KILL_ZONE)
            AND (poOwner <> $
                 AND Send(poOwner,@CheckRoomFlag,#flag=ROOM_KILL_ZONE))
         {
            Send(self,@MsgSendUser,#message_rsc=user_angel_rejoins);
         }
      }

      % This is stuff that would be executed on propagation, but we gotta
      % execute this stuff before Sending new info to client

      if Send(what,@GetRoomNum) = RID_UNDERWORLD
         AND Send(self,@GetDeathRiftProtection) = TRUE
      {
         % Deliverance people who somehow got to the Underworld already protected
         % Usually it's because they logged off in the Underworld while Death Rifting
         Post(self,@AdminGoToSafety);
      }

      if poOwner <> $
      {
        old = poOwner;
        Send(poOwner,@LeaveHold,#what=self);
      }

      poOwner = what;

      if poOwner <> $
      {
         if old <> $
         {
            Send(self,@CheckLeavingNewbieOrGuest,#leaving=old);
            Send(self,@CheckTokenInNewRoom,#what=old);
         }

         % If room is no combat and safe logoff, record it as the
         % player's last safe location
         if Send(poOwner,@CheckRoomFlag,#flag=ROOM_NO_COMBAT)
            AND Send(poOwner,@CheckRoomFlag,#flag=ROOM_SAFELOGOFF)
         {
            piLastSafeRoom = Send(poOwner,@GetRoomNum);
            Send(self,@RechargeAllRods);
         }

         piRow = First(Send(poOwner,@GetRoomPos,#what=self));
         piCol = Nth(Send(poOwner,@GetRoomPos,#what=self),2);

         if pbLogged_on
         {
            Send(self,@ToCliPlayer);
            Send(self,@ToCliRoomContents);
         }
      }

      % This is intended to protect players from wall spells stacked on
      % entrances. It will clear out a small space when they enter the zone,
      % so that they don't appear in the middle of a wall spell.
      if old <> $
         AND (piFlags & PFLAG_PKILL_ENABLE)
         AND Send(poOwner,@AllowGuildAttack,#what=self)
         AND NOT IsClass(self,&DM)
      {
         Send(poOwner,@DeleteWallsAroundBattler,#who=self);
      }

      % This removes Death Rift's protection when the user enters any
      % non-Underworld room
      if Send(poOwner,@GetRoomNum) <> RID_UNDERWORLD
         AND Send(self,@GetDeathRiftProtection) = TRUE
      {
         Send(self,@SetDeathRiftProtection,#value=FALSE);
      }

      propagate;
   }

   SomethingEntered(what = $)
   {
      local lPos;

      lPos = Send(what,@GetPos);

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_CREATE);
         Send(self,@ToCliObject,#what=what);
         AddPacket(2,First(lPos)*FINENESS+Nth(lPos,3),
                   2,Nth(lPos,2)*FINENESS+Nth(lPos,4),
                   2,Send(what,@GetAngle));
         Send(what,@SendMoveAnimation);
         Send(what,@SendMoveOverlays);
         SendPacket(poSession);
      }

      propagate;
   }

   SomethingLeft(what = $)
   {
      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         AddPacket(1,BP_REMOVE,4,what);
         SendPacket(poSession);
      }

      propagate;
   }

   SomethingMoved(what=$, new_row=$, new_col=$, fine_row = $, fine_col = $,
                  cause = $, speed = 0)
   {
      local iRow,iCol,lPos;

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         if what <> self OR cause <> CAUSE_USER_INPUT
         {
            AddPacket(1,BP_MOVE, 4,what,
                      2,new_row*FINENESS+fine_row, 2,new_col*FINENESS+fine_col,
                      1,speed);
            SendPacket(poSession);

            propagate;
         }
      }

      propagate;
   }

   BuildPacketSomethingMoved(what=$,new_row=$,new_col=$,fine_row = $,
                             fine_col = $,cause = $,speed = 0)
   {
      AddPacket(1,BP_MOVE, 4,what,
                2,new_row*FINENESS+fine_row, 2,new_col*FINENESS+fine_col,
                1,speed);

      return;
   }

   SomethingTurned(what = $,new_angle = 0,cause = $)
   {
      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if pbLogged_on
      {
         % Need to set new angle of object somewhere
         if (what <> self or cause <> CAUSE_USER_INPUT)
         {
            AddPacket(1,BP_TURN,4,what,2,new_angle);
            SendPacket(poSession);
         }
      }

      propagate;
   }

   BuildPacketSomethingTurned(what = $,new_angle = 0)
   {
      AddPacket(1,BP_TURN,4,what,2,new_angle);

      return;
   }

   SomethingShot(who=$, target=$, projectile=$, flags=PROJ_FLAG_NONE,
                 iLightIntensity=0, iLightColor=0)
   {
      local iValue;

      % This happened in the past.  Ignore this, because Sending nil in a
      %  packet is bad.
      if target = $
      {
         propagate;
      }

      AddPacket(1,BP_SHOOT,4,Send(projectile,@GetProjectileIcon));
      Send(projectile,@SendProjectileAnimation);

      % Send shooter and target.
      AddPacket(4,who, 4,target, 1,Send(projectile,@GetProjectileSpeed),
                2,(flags & 0x000F));

      if (flags & PROJ_FLAG_LIGHT_SOURCE)
      {
         % Lighting flags
         iValue = Send(projectile,@GetProjectileLightFlags);
         % Double-check for sanity
         if iValue <> LIGHT_FLAG_NONE
         {
            % Make sure projectiles are on and have the dynamic flag set.
            iValue = iValue | LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
            % Flags, Intensity, color
            AddPacket(2,iValue,
                      1,Send(projectile,@GetProjectileLightIntensity),
                      2,Send(projectile,@GetProjectileLightColor));
         }
         else
         {
            % No lighting info
            AddPacket(2,0);
         }
      }
      else
      {
         % No lighting info
         AddPacket(2,0);
      }

      SendPacket(poSession);

      propagate;
   }

   SomethingShotRadius(who=$,projectile=$,flags=PROJ_FLAG_NONE,
                 iLightIntensity=0,iLightColor=0,range=0,number=0,speed=0)
   {
      local iCount, iValue, iAngle;

      AddPacket(1,BP_RADIUS_SHOOT,4,Send(projectile,@GetProjectileIcon));
      Send(projectile,@SendProjectileAnimation);

      % Send shooter.
      AddPacket(4,who,1,speed,2,(flags & 0x000F),1,range,1,number);

      if (flags & PROJ_FLAG_LIGHT_SOURCE)
      {
         % Lighting flags
         iValue = Send(projectile,@GetProjectileLightFlags);
         % Double-check for sanity
         if iValue <> LIGHT_FLAG_NONE
         {
            % Make sure projectiles are on and have the dynamic flag set.
            iValue = iValue | LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
            % Flags, Intensity, color
            AddPacket(2,iValue,1,iLightIntensity,2,iLightColor);
         }
         else
         {
            % No lighting info
            AddPacket(2,0);
         }
      }
      else
      {
         % No lighting info
         AddPacket(2,0);
      }

      SendPacket(poSession);

      propagate;
   }

   SomethingDidAction(what = $, action = $)
   {
      % Someone changed facial expression--Send changed bitmap
      Send(self,@SomethingChanged,#what=what);

      return;
   }

   SomeoneSaid(what = $, type = $, string = $, parm1 = $, parm2 = $, parm3 = $,
               parm4= $, parm5 = $, parm6 = $, parm7 = $, parm8 = $)
   {
      local rSay_format,rName;

      if pbLogged_on
      {
         % if it's a say resource, it's from a monster or object probably.
         % otherwise, string is the tempstring.

         % Don't echo DM commands to the users.
         if type = SAY_DM
         {
            return;
         }

         % If we need a name for this say, and they're anonymous or disguised,
         %  don't look stupid.
         if what <> $
         {
            rName = Send(what,@GetName,#cap=TRUE);
         }

         if type = SAY_RESOURCE
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type,
                      4,user_said_resource_str,
                      4,Send(what,@GetCapDef), 4,rName, 4,string);

            % allow SAY_RESOURCE says to have parameters
            if parm1 <> $
            {
               AddPacket(4,parm1);
            }
            if parm2 <> $
            {
               AddPacket(4,parm2);
            }
            if parm3 <> $
            {
               AddPacket(4,parm3);
            }
            if parm4 <> $
            {
               AddPacket(4,parm4);
            }
            if parm5 <> $
            {
               AddPacket(4,parm5);
            }
            if parm6 <> $
            {
               AddPacket(4,parm6);
            }
            if parm7 <> $
            {
               AddPacket(4,parm7);
            }
            if parm8 <> $
            {
               AddPacket(4,parm8);
            }

            SendPacket(poSession);

            propagate;
         }

         if type = SAY_MESSAGE
         {
            AddPacket(1,BP_MESSAGE,4,string);
            if parm1 <> $
            {
               AddPacket(4,parm1);
            }
            if parm2 <> $
            {
               AddPacket(4,parm2);
            }
            if parm3 <> $
            {
               AddPacket(4,parm3);
            }
            if parm4 <> $
            {
               AddPacket(4,parm4);
            }
            if parm5 <> $
            {
               AddPacket(4,parm5);
            }
            if parm6 <> $
            {
               AddPacket(4,parm6);
            }
            if parm7 <> $
            {
               AddPacket(4,parm7);
            }
            if parm8 <> $
            {
               AddPacket(4,parm8);
            }

            SendPacket(poSession);

            propagate;
         }

         rSay_format = user_said_str;
         if what = self
         {
            rSay_format = user_said_echo_str;
         }

         if type = SAY_YELL
         {
            rSay_format = user_yelled_str;
            if what <> $ AND Send(what,@GetOwner) <> poOwner
            {
               rSay_format = user_yelled_nearby_str;
            }

            if what = self
            {
               rSay_format = user_yelled_echo_str;
            }
         }
         else if type = SAY_EVERYONE
         {
            % If a hidden admin is talking to us, use the GetName() above.
            %  This will give us a valid resource; we won't have the proper
            %  name in our name list.  Other admins are an exception.
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            if what <> self
            {
               rSay_format = user_broadcast_str;
            }
            else
            {
               rSay_format = user_broadcast_echo_str;
            }
         }
         else if type = SAY_GROUP
         {
            % If a hidden admin is talking to us, use the GetName() above.
            %  This will give us a valid resource; we won't have the proper
            %  name in our name list.  Other admins are an exception.
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            rSay_format = user_send_str;

            % Play a "tell sound" to the recipient
            Send(self,@WaveSendUser,#what=what,#wave_rsc=user_tell_wav);
         }
         else if type = SAY_GROUP_ONE
         {
            if (IsClass(what,&DM)
                AND NOT Send(what,@IsHidden))
               OR IsClass(self,&Admin)
            {
               rName = Send(what,@GetTrueName);
            }

            rSay_format = user_send_one_str;

            % Play a "tell sound" to the recipient
            Send(self,@WaveSendUser,#what=what,#wave_rsc=user_tell_wav);

            % this is what the client is expecting to hear
            type = SAY_GROUP;
         }
         else if type = SAY_EMOTE
         {
            rSay_format = user_emote_str;
         }

         if Send(what,@CheckPlayerFlag,#flag=PFLAG_MORPHED)
            AND (rSay_format = user_said_str
                 OR rSay_format = user_yelled_str
                 OR rSay_format = user_emote_str)
         {
            if rSay_format = user_said_str
            {
               rSay_format = user_said_str_morphed;
            }
            else if rSay_format = user_yelled_str
            {
               rSay_format = user_yelled_str_morphed;
            }
            else if rSay_format = user_emote_str
            {
               rSay_format = user_emote_str_morphed;
            }

            

            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      4,Send(what,@GetCapIndef), 4,rName, 0,string);

            SendPacket(poSession);

            propagate;
         }

         if what = self AND type <> SAY_EMOTE
            AND type <> SAY_GROUP AND type <> SAY_GROUP_ONE
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      0,string);
         }
         else
         {
            AddPacket(1,BP_SAID, 4,what, 4,rName, 1,type, 4,rSay_format,
                      4,rName, 0,string);
         }

         SendPacket(poSession);
      }

      propagate;
   }

   SomethingChanged(what = $)
   {
      local rName, rIcon;

      if IsClass(what,&DM)
         AND Send(what,@IsDMStealthed)
         AND what <> self
      {
         return;
      }

      if what = self
         AND (piFlags2 & PFLAG2_DANCING)
      {
         Send(self,@StopDancing);
      }

      if pbLogged_on
      {
         AddPacket(1,BP_CHANGE);
         if Send(what,@GetOwner) = self
         {
            % if in inventory
            Send(self,@ToCliObject,#what=what,#show_type=SHOW_INVENTORY);
            Post(self,@DrawCapacity);
            Post(self,@DrawBulk);
         }
         else
         {
            % in the room
            Send(self,@ToCliObject,#what=what);
         }

         Send(what,@SendMoveAnimation);
         Send(what,@SendMoveOverlays);

         SendPacket(poSession);
      }

      propagate;
   }

   NewUsing(what = $)
   {
      local rName,rIcon;

      if pbLogged_on
      {
         AddPacket(1,BP_USE,4,what);
         SendPacket(poSession);

         if IsClass(what,&Weapon)
         {
            Post(self,@DrawOffense);
         }
      }

      return;
   }

   NewUnusing(what = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_UNUSE,4,what);
         SendPacket(poSession);

         if IsClass(what,&Weapon)
         {
            Post(self,@DrawOffense);
         }
      }

      return;
   }

   ReceiveMail(from = $,dest_list = $,perm_string = $)
   "<from> is a resource."
   {
      if dest_list = $
      {
         dest_list = [self];
      }

      plNew_mail = Cons([from,GetTime(),dest_list,[perm_string]],plNew_mail);

      Send(self,@MsgSendUser,#message_rsc=user_new_mail,#parm1=from);

      return;
   }

   ReceiveNestedMail(from = $,dest_list = $,nest_list = $)
   "<from> is a resource."
   {
      if dest_list = $
      {
         dest_list = [self];
      }

      plNew_mail = Cons([from,GetTime(),dest_list,nest_list],plNew_mail);

      Send(self,@MsgSendUser,#message_rsc=user_new_nested_mail);

      return;
   }

   DrawHealth()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,1);
         Send(self,@SendStatHealth);
         SendPacket(poSession);
      }
      
      return;
   }

   SendStatHealth()
   {
      AddPacket(1,1, 4,user_stat_health, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetHealth), 4,0, 4,100, 4,piMax_health);

      return;
   }

   DrawMana()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,1);
         Send(self,@SendStatMana);
         SendPacket(poSession);
      }

      return;
   }

   SendStatMana()
   {
      AddPacket(1,2, 4,user_stat_mana, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,piMana, 4,0, 4,100, 4,piMax_mana);

      return;
   }

   DrawMight()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatMight);
         SendPacket(poSession);
      }

      return;
   }

   SendStatMight()
   {
      AddPacket(1,1, 4,user_stat_might, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetMight), 4,0, 4,50, 4,Send(self,@GetMight));

      return;
   }

   DrawIntellect()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatIntellect);
         SendPacket(poSession);
      }

      return;
   }

   SendStatIntellect()
   {
      AddPacket(1,2, 4,user_stat_intellect, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetIntellect), 4,0, 4,50,
                4,Send(self,@GetIntellect));

      return;
   }

   DrawAgility()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatAgility);
         SendPacket(poSession);
      }

      return;
   }

   SendStatAgility()
   {
      AddPacket(1,4, 4,user_stat_Agility, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetAgility), 4,0, 4,50, 4,Send(self,@GetAgility));

      return;
   }

   DrawStamina()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatStamina);
         SendPacket(poSession);
      }

      return;
   }

   SendStatStamina()
   {
      AddPacket(1,3,4,user_stat_Stamina,1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetStamina), 4,0, 4,50, 4,Send(self,@GetStamina));

      return;
   }

   DrawMysticism()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatMysticism);
         SendPacket(poSession);
      }

      return;
   }

   SendStatMysticism()
   {
      AddPacket(1,5,4,user_stat_Mysticism,1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetMysticism), 4,0, 4,50,
                4,Send(self,@GetMysticism));

      return;
   }

   DrawAim()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatAim);
         SendPacket(poSession);
      }

      return;
   }

   SendStatAim()
   {
      AddPacket(1,6, 4,user_stat_Aim, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,Send(self,@GetAim), 4,0, 4,50, 4,Send(self,@GetAim));

      return;
   }

   DrawKarma()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatKarma);
         SendPacket(poSession);
      }

      return;
   }

   SendStatKarma()
   {
      local iKarma_send;

      % internally we have karma in 1/100's of a point, -10000 to 10000.
      % scale to -100 to 100
      iKarma_send = piKarma/100;

      AddPacket(1,7, 4,user_stat_karma, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iKarma_Send, 4,-100, 4,100, 4,iKarma_Send);

      return;
   }

   DrawTraining()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatTraining);
         SendPacket(poSession);
      }

      return;
   }

   SendStatTraining()
   {
      local iTraining_send;

      iTraining_send = Send(self,@GetTrainingPoints);

      AddPacket(1,8, 4,user_stat_training, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iTraining_send, 4,0, 4,1000, 4,iTraining_send);

      return;
   }

   DrawCapacity()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatCapacity);
         SendPacket(poSession);
      }

      return;
   }

   SendStatCapacity()
   {
      local iCapacity_send, iMaxCapacity_send;

      iCapacity_send = Send(self,@GetWeightHold);

      % GetWeightMax returns NIL in dm.kod, 3100 is capacity at 70 might
      if IsClass(self,&DM)
      {
         iMaxCapacity_send = 3100;
      }
      else
      {
         iMaxCapacity_send = Send(self,@GetWeightMax);
      }

      AddPacket(1,9, 4,user_stat_capacity, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iCapacity_send, 4,0, 4,iMaxCapacity_send, 4,iCapacity_send);

      return;
   }
   
   DrawBulk()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatBulk);
         SendPacket(poSession);
      }

      return;
   }
   
   SendStatBulk()
   {
      local iBulk, iBulkMax;

      iBulk = Send(self,@GetBulkHold);

      % GetBulkMax returns NIL in dm.kod, 3100 is capacity at 70 might
      if IsClass(self,&DM)
      {
         iBulkMax = 3100;
      }
      else
      {
         iBulkMax = Send(self,@GetBulkMax);
      }

      AddPacket(1,10, 4,user_stat_bulk, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iBulk, 4,0, 4,iBulkMax, 4,iBulk);

      return;
   }

   DrawOffense()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatOffense);
         SendPacket(poSession);
      }

      return;
   }

   SendStatOffense()
   {
      local iOffense_send;

      iOffense_send = Send(self,@GetOffense);

      AddPacket(1,11, 4,user_stat_offense, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iOffense_send, 4,0, 4,1000, 4,iOffense_send);

      return;
   }

   DrawDefense()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatDefense);
         SendPacket(poSession);
      }

      return;
   }

   SendStatDefense()
   {
      local iDefense_send;

      iDefense_send = Send(self,@GetDefense);

      AddPacket(1,12, 4,user_stat_defense, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iDefense_send, 4,0, 4,1000, 4,iDefense_send);

      return;
   }
   
   DrawArmor()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,2);
         Send(self,@SendStatArmor);
         SendPacket(poSession);
      }

      return;
   }

   SendStatArmor()
   {
      local iArmor_send;

      iArmor_send = Send(self,@SumDamageReduction);

      AddPacket(1,13, 4,user_stat_armor, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iArmor_send, 4,0, 4,15, 4,iArmor_send);

      return;
   }

   SendStatResistances(num=1,lCurrentResistances=$)
   {
      local i, bWeaponAll, bWeaponThrust, bWeaponBludgeon, bWeaponSlash,
               bWeaponPierce, bSpellAll, bSpellFire, bSpellShock, bSpellCold,
               bSpellAcid, bSpellHoly, bSpellUnholy, bSpellQuake;

      bWeaponAll = FALSE;
      bWeaponThrust = FALSE;
      bWeaponBludgeon = FALSE;
      bWeaponSlash = FALSE;
      bWeaponPierce = FALSE;
      bSpellAll = FALSE;
      bSpellFire = FALSE;
      bSpellShock = FALSE;
      bSpellCold = FALSE;
      bSpellAcid = FALSE;
      bSpellHoly = FALSE;
      bSpellUnholy = FALSE;
      bSpellQuake = FALSE;

      if num = 1
      {
         foreach i in lCurrentResistances
         {
            if First(i) = ATCK_WEAP_ALL
            {
               AddPacket(1,14, 4,user_resist_weapons, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bWeaponAll = TRUE;
            }
         }
         if NOT bWeaponAll
         {
            AddPacket(1,14, 4,user_resist_weapons, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 2
      {
         foreach i in lCurrentResistances
         {
            if First(i) = ATCK_WEAP_THRUST
            {
               AddPacket(1,15, 4,user_resist_thrust, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bWeaponThrust = TRUE;
            }
         }
         if NOT bWeaponThrust
         {
            AddPacket(1,15, 4,user_resist_thrust, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 3
      {
         foreach i in lCurrentResistances
         {
            if First(i) = ATCK_WEAP_BLUDGEON
            {
               AddPacket(1,16, 4,user_resist_bludgeon, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bWeaponBludgeon = TRUE;
            }
         }
         if NOT bWeaponBludgeon
         {
            AddPacket(1,16, 4,user_resist_bludgeon, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 4
      {
         foreach i in lCurrentResistances
         {
            if First(i) = ATCK_WEAP_SLASH
            {
               AddPacket(1,17, 4,user_resist_slash, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bWeaponSlash = TRUE;
            }
         }
         if NOT bWeaponSlash
         {
            AddPacket(1,17, 4,user_resist_slash, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 5
      {
         foreach i in lCurrentResistances
         {
            if First(i) = ATCK_WEAP_PIERCE
            {
               AddPacket(1,18, 4,user_resist_pierce, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bWeaponPierce = TRUE;
            }
         }
         if NOT bWeaponPierce
         {
            AddPacket(1,18, 4,user_resist_pierce, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 6
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_ALL
            {
               AddPacket(1,19, 4,user_resist_magic, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellAll = TRUE;
            }
         }
         if NOT bSpellAll
         {
            AddPacket(1,19, 4,user_resist_magic, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 7
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_FIRE
            {
               AddPacket(1,20, 4,user_resist_fire, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellFire = TRUE;
            }
         }
         if NOT bSpellFire
         {
            AddPacket(1,20, 4,user_resist_fire, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 8
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_SHOCK
            {
               AddPacket(1,21, 4,user_resist_shock, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellShock = TRUE;
            }
         }
         if NOT bSpellShock
         {
            AddPacket(1,21, 4,user_resist_shock, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 9
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_COLD
            {
               AddPacket(1,22, 4,user_resist_cold, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellCold = TRUE;
            }
         }
         if NOT bSpellCold
         {
            AddPacket(1,22, 4,user_resist_cold, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 10
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_ACID
            {
               AddPacket(1,23, 4,user_resist_acid, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellAcid = TRUE;
            }
         }
         if NOT bSpellAcid
         {
            AddPacket(1,23, 4,user_resist_acid, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 11
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_HOLY
            {
               AddPacket(1,24, 4,user_resist_holy, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellHoly = TRUE;
            }
         }
         if NOT bSpellHoly
         {
            AddPacket(1,24, 4,user_resist_holy, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 12
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_UNHOLY
            {
               AddPacket(1,25, 4,user_resist_unholy, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellUnholy = TRUE;
            }
         }
         if NOT bSpellUnholy
         {
            AddPacket(1,25, 4,user_resist_unholy, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }
      else if num = 13
      {
         foreach i in lCurrentResistances
         {
            if First(i) = -ATCK_SPELL_QUAKE
            {
               AddPacket(1,26, 4,user_resist_quake, 1,STAT_VALUE, 1,STAT_INTEGER,4,Nth(i,2), 4,-30, 4,100, 4,0);
               bSpellQuake = TRUE;
            }
         }
         if NOT bSpellQuake
         {
            AddPacket(1,26, 4,user_resist_quake, 1,STAT_VALUE, 1,STAT_INTEGER,4,0, 4,-30, 4,100, 4,0);
         }
      }

      return;
   }
   
   DrawResistances()
   {
      local i, lCurrentResistances;
      
      i = 1;
      
      lCurrentResistances = Send(self,@GetCurrentResistances);
      
      if pbLogged_on
      {
         while i < 14
         {
            AddPacket(1,BP_STAT,1,2);
            Send(self,@SendStatResistances,#num=i,#lCurrentResistances=lCurrentResistances);
            SendPacket(poSession);
            i = i + 1;
         }
         
         return;
      }

      return;
   }

   SendStatHPChance()
   {
      local iHPChance_Send, highmark;

      highmark = Send(self,@GetHighMark);


      % (piGain_chance*100)/highmark = percent chance to gain HP

      if piGain_chance < 0
      {
        iHPChance_Send = piGain_chance;
      } 
      else 
      {
        iHPChance_Send = bound(((piGain_chance*100)/highmark),1,100);
      }    
      % user_stat_hpgainchance = "Tougher Chance"

      AddPacket(1,4, 4,user_stat_hpgainchance, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,iHPChance_Send, 4,-(piBase_Max_health/2), 4,30, 4,0);

      return;
   }
   
   DrawHPChance()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT, 1,1);
         Send(self,@SendStatHPChance);
         SendPacket(poSession);
      }

      return;
   }

   DrawVigor()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT, 1,1);
         Send(self,@SendStatVigor);
         SendPacket(poSession);
      }

      return;
   }

   SendStatVigor()
   {
      AddPacket(1,3, 4,user_stat_vigor, 1,STAT_VALUE, 1,STAT_INTEGER,
                4,piVigor, 4,0, 4,200, 4,piVigor_rest_threshold);

      return;
   }

   DrawStatSpell(index = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,3);
         Send(self,@SendStatSpell,#index=index);
         SendPacket(poSession);
      }

      return;
   }

   SendStatSpell(index = $)
   {
      local compound,oSpell;

      compound = Nth(plSpells,index);

      oSpell = Send(SYS,@FindSpellByNum,#num=Send(self,@DecodeSpellNum,
                                                  #compound=compound));
      AddPacket(1,index, 4,Send(oSpell,@GetName), 1,STAT_LIST, 4,oSpell,
                4,Send(self,@DecodeSpellAbility,#compound=compound),
                4,Send(oSpell,@GetIcon));

      return;
   }

   DrawStatSkill(index = $)
   {
      if pbLogged_on
      {
         AddPacket(1,BP_STAT,1,4);
         Send(self,@SendStatSkill,#index=index);
         SendPacket(poSession);
      }
      
      return;
   }

   SendStatSkill(index = $)
   {
      local compound,oSkill;

      compound = Nth(plSkills,index);

      oSkill = Send(SYS,@FindSkillByNum,#num=Send(self,@DecodeSkillNum,
                                                  #compound=compound));
      AddPacket(1,index, 4,Send(oSkill,@GetName), 1,STAT_LIST, 4,oSkill,
                4,Send(self,@DecodeSkillAbility,#compound=compound),
                4,Send(oSkill,@GetIcon));

      return;
   }

   Killed(what = $)
   {
      Send(self,@CancelIfOffer);

      if what = self
      {
         propagate;
      }

      if what <> $ AND IsClass(what,&TempleRiija)
      {
         Send(self,@MsgSendUser,#message_rsc=user_was_killed_bridge_faith);
         
         propagate;
      }

      if what <> $ AND IsClass(what,&Battler)
      {
         % Victim learns the real identity of a morphed/anonymous killer here.
         Send(self,@MsgSendUser,#message_rsc=user_was_killed,
              #parm1=Send(what,@GetDef),#parm2=Send(what,@GetTrueName));

         propagate;
      }

      % any other causes of death get no special messages.

      propagate;
   }

   SourceLightChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_PLAYER,1,bound(piLight,0,255));
         SendPacket(poSession);
      }
      
      return;
   }

   AmbientLightChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_LIGHT_AMBIENT);
         AddPacket(1,Send(poOwner,@GetRoomLight));
         SendPacket(poSession);
      }
      
      return;
   }

   BackgroundChanged()
   {
      if pbLogged_on
      {
         AddPacket(1,BP_BACKGROUND);
         AddPacket(4,Send(poOwner,@GetRoomBackground));
         SendPacket(poSession);
      }
      
      return;
   }

   WeatherChanged()
   {
      if pbLogged_on
      {
         % First clear whichever effect we have.
         AddPacket(1,BP_EFFECT,2,EFFECT_CLEARWEATHER);
         SendPacket(poSession);

         % If we came from a room with a sandstorm weather effect we
         % clear it here, unless we're affected by the Sandstorm spell.
         if NOT Send(self,@IsAffectedByRadiusEnchantment,
                     #byClass=&Sandstorm)
         {
            AddPacket(1,BP_EFFECT,2,EFFECT_CLEARSAND);
            SendPacket(poSession);
         }

         % Then send the needed effect.
         AddPacket(1,BP_EFFECT);
         AddPacket(2,Send(poOwner,@GetRoomWeather));
         SendPacket(poSession);
      }

      return;
   }

   ShowAddEnchantment(what = $,type = $)
   {
      if pbLogged_on
      {
         if Send(what,@ShowEnchantmentIcon,#type=type)
         {
            AddPacket(1,BP_ADD_ENCHANTMENT);
            AddPacket(1,type);
            Send(self,@ToCliObject,#what=what,#show_type=SHOW_ENCHANTMENT);
            SendPacket(poSession);
         }
      }
      
      return;
   }

   ShowRemoveEnchantment(what = $,type = $)
   {
      if pbLogged_on
      {
         if Send(what,@ShowEnchantmentIcon,#type=type)
         {
            AddPacket(1,BP_REMOVE_ENCHANTMENT);
            AddPacket(1,type);
            AddPacket(4,what);
            SendPacket(poSession);
         }
      }
      
      return;
   }

   SetInitialHomeroom()
   {
      % Get initial Homeroom from system settings.
      piHomeroom = Send(SETTINGS_OBJECT,@GetInitialRoomID);

      return;
   }

   SetRandomHomeroom()
   "This sets one of the many hometowns to be the initial hometown."
   {
      local rand;
      
      rand = random(1,10);    
      
      if rand < 4
      {
         piHomeroom = RID_MAR_INN;
      }   
      else
      {
         if rand > 7
         {
            piHomeroom = RID_JAS_INN;
         }
         else
         {
            piHomeroom = RID_COR_INN;
         }
      }
      
      return;
   }
   
   SetHomeroom(RID = 0, lock = FALSE)
   {
      if NOT lock
      {
         piHomeroom = (rid);
      }
      else
      {
         piHomeroom = -(rid);
      }
      
      return;
   }

   CanChangeHomeroom()
   {
      if piHomeRoom < 0
      {
         return FALSE;
      }
      
      return TRUE;
   }
   
   GetHomeRoom()
   {
      % A negative homeroom means you can't change it in the hall of
      %  genealogy.
      if piHomeRoom = $
      {
         return $;
      }
      
      return abs(piHomeRoom);
   }

   AdminGoToJail()
   "Admin supported.  "
   "Sends the user to the Barloque Jail, if they're logged in"
   {
      if pbLogged_on
      {
         Send(self,@TeleportTo,#RID=RID_BAR_JAIL);
         Send(self,@MsgSendUser,#message_rsc=user_goto_jail);
         return Send(SYS,@GetSuccessRsc);
      }

      return;
   }

   AdminGoToLastSafeRoom(from_special=FALSE)
   "Admin supported\n"
   "Sends the user to the last safe room they visited, whether they're logged in or not!\n"
   {
      local oCurrentRoom, iCurrentRegion, oLastSafeRoom, iLastSafeRegion, oTargetRoom;

      if piLastSafeRoom <> $
      {
         oLastSafeRoom = Send(SYS,@FindRoomByNum,#num=piLastSafeRoom);
         iLastSafeRegion = Send(oLastSafeRoom,@GetRegion);

         if pbLogged_on
         {
            oCurrentRoom = poOwner;
            iCurrentRegion = Send(oCurrentRoom,@GetRegion);

            if iCurrentRegion = iLastSafeRegion
               OR from_special
            {
               Send(oLastSafeRoom,@Teleport,#what=self);
               Send(self,@MsgSendUser,#message_rsc=user_goto_lastsaferoom);
            }
            else
            {
               % If the user is in a different region from their last safe room, use region default homeroom instead.
               % This can happen if a player goes to a new region but never stops in at a safe room.

               oTargetRoom = Send(SYS,@FindRoomByNum,#num=Send(oCurrentRoom,@GetCurrentRegionHomeroom));
               Send(oTargetRoom,@Teleport,#what=self);
               Send(self,@MsgSendUser,#message_rsc=user_goto_safety);
            }
         }
         else
         {
            % If the user is logged off, we can't teleport.
            % Instead, we update their saved logoff location.

            oCurrentRoom = Send(SYS,@FindRoomByNum,#num=piSave_Room);
            iCurrentRegion = Send(oCurrentRoom,@GetRegion);
            
            if iCurrentRegion = iLastSafeRegion
               OR from_special
            {
               piSave_room = piLastSafeRoom;
               piSave_row = Send(oLastSafeRoom,@GetTeleportRow);
               piSave_col = Send(oLastSafeRoom,@GetTeleportCol);
               piSave_fine_row = 32;
               piSave_fine_col = 32;
            }
            else
            {
               oTargetRoom = Send(SYS,@FindRoomByNum,#num=Send(oCurrentRoom,@GetCurrentRegionHomeroom));

               piSave_room = Send(oTargetRoom,@GetRoomNum);
               piSave_row = Send(oTargetRoom,@GetTeleportRow);
               piSave_col = Send(oTargetRoom,@GetTeleportCol);
               piSave_fine_row = 32;
               piSave_fine_col = 32;
            }
         }
      }

      return;
   }

   AdminGoToSafety()
   "Admin supported\n"
   "Sends the user to their hometown, whether they're logged in or not!\n"
   "Called by constructor for initial placement as well"
   {
      local oNew_Room,iRow,iCol,oRoom;

      oRoom = $;
      if piHomeroom <> $
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=abs(piHomeroom));
      }

      if oRoom = $ OR piHomeroom = $ OR NOT Send(oRoom,@IsHometown)
      {
         Send(self,@SetRandomHomeroom);
         oRoom = Send(SYS,@FindRoomByNum,#num=piHomeroom);
      }

      piSave_room = piHomeroom;
      piSave_row = Send(oRoom,@GetTeleportRow);
      piSave_col = Send(oRoom,@GetTeleportCol);
      piSave_fine_row = 32;
      piSave_fine_col = 32;

      if pbLogged_on
      {
         Send(oRoom,@Teleport,#what=self);
         Send(self,@MsgSendUser,#message_rsc=user_goto_safety);
      }

      return Send(SYS,@GetSuccessRsc);
   }

   AdminGoToOOG()
   "Admin Supported\n"
   "Sends the user to OOG, whether they're logged in or not!\n"
   {
      local oRoom,oSaveRoom,i,oGhost;

      if pbLogged_on
      {
         Send(self,@TeleportTo,#RID=RID_OOG);
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=RID_OOG);
         oSaveRoom = Send(SYS,@FindRoomByNum,#num=piSave_Room);
         foreach i in Send(oSaveRoom,@GetHolderActive)
         {
            oGhost = Send(oSaveRoom,@HolderExtractObject,#data=i);
            if IsClass(oGhost,&LogoffGhost)
               AND (Send(oGhost,@GetGhostedPlayer) = self)
            {
               Send(oRoom,@NewHold,#what=oGhost,
                     #new_row=Send(oRoom,@GetTeleportRow),
                     #new_col=Send(oRoom,@GetTeleportCol),
                     #fine_row=0,#fine_col=0,
                     #new_angle=Send(oRoom,@GetTeleportAngle));
            }
         }

         piSave_Room = RID_OOG;
         piSave_row = Send(oRoom,@GetTeleportRow);
         piSave_col = Send(oRoom,@GetTeleportCol);
         piSave_fine_row = 0;
         piSave_fine_col = 0;
         piSave_angle = Send(oRoom,@GetTeleportAngle);
         if piSave_angle = $
         {
            piSave_angle = ANGLE_SOUTH;
         }
      }

      return TRUE;
   }

   TeleportToInitialLocation()
   "Assertion:  you are NOT logged on"
   {
      local iInitialRoomID, oRoom;

      iInitialRoomID = Send(SETTINGS_OBJECT,@GetInitialRoomID);
      oRoom = Send(SYS,@FindRoomByNum,#num=iInitialRoomID);

      if oRoom = $
      {
         Debug("There is no initial room!");

         return;
      }

      % we're NOT logged on

      piSave_room = Send(oRoom,@GetRoomNum);
      piSave_row = Send(oRoom,@GetTeleportRow);
      piSave_col = Send(oRoom,@GetTeleportCol);
      piSave_fine_row = 0;
      piSave_fine_col = 0;
      piSave_angle = Send(oRoom,@GetTeleportAngle);
      if piSave_angle = $
      {
         piSave_angle = ANGLE_SOUTH;
      }

      return;
   }

   TeleportTo(RID = RID_TOS,foyer=TRUE,bAdminPort=TRUE)
   "Admin supported."
   "This will teleport the target person to the target room, by RID."
   {
      local oRoom;

      oRoom = Send(SYS,@FindRoombyNum,#num=RID);
      if oRoom = $
      {
         % If FindRoomByNum returns nothing - bad RID
         return FALSE;
      }

      if NOT pbLogged_on
      {
         % If they're not logged in, don't teleport 'em
         return FALSE;
      }

      Send(oRoom,@Teleport,#what=self,#foyer=foyer);

      if bAdminPort
      {
         % Log the teleport.
         GodLog("Admin ",Send(self,@GetTrueName)," teleported to ",
               Send(oRoom,@GetName));
      }

      return TRUE;
   }

   AdminGoToObject(what = $)
   "Admin supported\n"
   "Sends the user as near as possible to <what>."
   {
      local oNew_Room,iRow,iCol,iFineRow,iFineCol,ret_val,logged_off;

      if what = $
      {
         Debug("Got what = $");

         return FALSE;
      }

      if not pbLogged_on
      {
         return FALSE;
      }

      logged_off = FALSE;
      
      if IsClass(what,&Player) AND NOT Send(what,@IsLoggedOn)
      {
         % Logged out players may still have a location.
         oNew_room = Send(SYS,@FindRoomByNum,#num=Send(what,@GetSaveRoom));
         if (oNew_room = $)
         {
            return FALSE;
         }

         iRow = Send(what,@GetSaveRow);
         iCol = Send(what,@GetSaveCol);
         iFineRow = Send(what,@GetSaveFineRow);
         iFineCol = Send(what,@GetSaveFineCol);

         logged_off = TRUE;
      }
      else
      {
         % All objects, including players logged in.
         oNew_room = Send(SYS,@UtilGetRoom,#what=what);
         if (oNew_room = $)
         {
            return FALSE;
         }

         iRow = Send(what,@GetRow);
         iCol = Send(what,@GetCol);
         iFineRow = Send(what,@GetFineRow);
         iFineCol = Send(what,@GetFineCol);
      }

      if iRow = $ OR iCol = $
      {
         Debug("Got bad row or column for object",what);

         return FALSE;
      }

      ret_val = Send(SYS,@UtilGoNearSquare,#what=self,#where=oNew_room,
                     #new_row=iRow,#new_col=iCol,
                     #fine_row=iFineRow,#fine_col=iFineCol,
                     #max_distance=2);

      if ret_val
      {
         if logged_off
         {
            logged_off = user_last_known;
         }
         else
         {
            logged_off = Send(what,@GetDef);
         }

         Send(self,@MsgSendUser,#message_rsc=user_goto_object,
               #parm1=logged_off,#parm2=Send(what,@GetName));
      }

      if IsClass(self,&DM)
      {
         GodLog("Admin ",Send(self,@GetTrueName)," teleported to object ",
               Send(what,@GetTrueName)," in room ",Send(oNew_room,@GetName));
      }
      else
      {
         GodLog(Send(self,@GetTrueName)," was teleported to object ",
            Send(what,@GetTrueName)," in room ",Send(oNew_room,@GetName));
      }

      return ret_val;
   }

   GetMoveOnType()
   {
      local iFlags;

      iFlags = MOVEON_NO;

      if Send(self,@IsInCannotInteractMode)
      {
         iFlags = (iFlags & ~MOVEON_NO);
      }

      % Angeled characters cannot block other players.
      if NOT (piFlags & PFLAG_PKILL_ENABLE)
      {
         iFlags = (iFlags & ~MOVEON_NO);
      }

      return iFlags;
   }

   GetDrawingEffects()
   {
      local iFlags;

      iFlags = piDrawFx;

      if (piFlags & PFLAG_INVISIBLE)
      {
         % invisibility overrides any other drawfx
         iFlags = iFlags & (~DRAWFX_MASK);
         iFlags = iFlags | DRAWFX_INVISIBLE;
      }

      if (piFlags & PFLAG_PHASED)
      {
         iFlags = iFlags & ~DRAWFX_MASK;
         iFlags = iFlags | DRAWFX_DITHERINVIS;
      }

      if (piFlags & PFLAG_SPECTATOR)
      {
         iFlags = iFlags & ~DRAWFX_MASK;
         iFlags = iFlags | DRAWFX_DITHERGREY;
      }

      return iFlags;
   }

   GetObjectFlags()
   {
      local iFlags, oIllusion;

      iFlags = OF_ATTACKABLE | OF_PLAYER | OF_OFFERABLE;

      oIllusion = Send(self,@GetIllusionForm);

      % If we're morphed, get rid of any "player" flags
      if (piFlags & PFLAG_MORPHED)
         AND oIllusion <> $
         AND IsClass(oIllusion,&Monster)
      {
         iFlags = (iFlags & ~OF_PLAYER & ~OF_OFFERABLE);
      }
      
      if Send(self,@IsInCannotInteractMode)
      {
         iFlags = iFlags | OF_NOEXAMINE;
         iFlags = (iFlags & ~OF_ATTACKABLE & ~OF_OFFERABLE & ~OF_PLAYER);
      }

      % Get the flashing/flickering/phasing/bouncing flags.
      iFlags = iFlags | piDrawEffectFlag;

      return iFlags;
   }

   GetPlayerNameColor()
   {
      local iDrawFX, iFlags;

      iFlags = 0;

      % Check for any shadow form effects.
      iDrawfX = Send(self,@GetDrawingEffects);
      if (iDrawFX & DRAWFX_BLACK) = DRAWFX_BLACK
      {
         iFlags = iFlags | NC_SHADOW;
      }

      if piNameColor <> 0
      {
         iFlags = iFlags | piNameColor;

         return iFlags;
      }

      % Send the appropriate flag to draw the name.
      if piFlags & PFLAG_MURDERER
      {
         iFlags = iFlags | NC_KILLER;
      }
      else
      {
         if (piFlags & PFLAG_OUTLAW)
         {
            iFlags = iFlags | NC_OUTLAW;
         }
         else
         {
            iFlags = iFlags | NC_PLAYER;
         }
      }

      return iFlags;
   }

   GetClientObjectType()
   {
      local iFlags;

      iFlags = 0;

      % Send the appropriate flag to draw the name.
      if piFlags & PFLAG_MURDERER
      {
         iFlags = iFlags | OT_KILLER;
      }
      else
      {
         if (piFlags & PFLAG_OUTLAW)
         {
            iFlags = iFlags | OT_OUTLAW;
         }
      }

      return iFlags;
   }

   IsEventCharacter()
   "Returns TRUE if this is an event character."
   {
      return FALSE;
   }

   SetLoginTime()
   {
      if piLastLoginTime = 0
      {
         piLastLoginTime = 1;
      }

      return;
   }

   ClearLoginTime()
   {
      piLastLoginTime = 0;

      return;
   }

   SetSafety()
   {
      Send(self,@SetPlayerPreference,#flag=CF_SAFETY_OFF,#value=FALSE);
      
      return;
   }

   IsLoggedOn()
   {
      return pbLogged_On;
   }

   GetSession()
   "Used in situations where you may need to tailor-make a package of "
   "text messages by hand without knowing how many variables there will "
   "be - example, showing all the names in a list - recursive stuff."
   {
      return poSession;
   }

   PlayerIsImmortal()
   {
      return FALSE;
   }

   InitialSetBaseMaxHealth()
   {
      local i;
      
      foreach i in plUsing
      {
         if Send(i,@AdjustsMaxHealth)
         {
           Send(self,@TryUnuseItem,#what=i);
           Send(self,@MsgSendUser,#message_rsc=user_fumble,
                #parm1=Send(i,@GetName));
         }
      }

      piBase_Max_health = piMax_health;

      return;
   }

   FixMoney(amount = 50000)
   {
      local oMoney,num;

      oMoney = Send(self,@GetMoneyObject);
      if oMoney <> $
      {
         num = Send(oMoney,@GetNumber);
         if num < 0
         {
            Send(oMoney,@AddNumber,#number=-num+1);
         }

         if num > amount
         {
            Send(oMoney,@SubtractNumber,#number=num-50000);
         }
      }
      
      return;
   }

   GetDM()
   {
      return 0;
   }

   EraseAllMail()
   {
      plNew_mail = $;
      
      return;
   }

   IsActor()
   {
      return FALSE;
   }

   LeaveNewbieOrGuestRegion()
   {
      % Delete their inventory?
      if Send(SETTINGS_OBJECT, @CleanNewbieInventoryOnEnteringRealWorld)
      {
         Send(self,@StripInventory);
      }

      return;
   }

   EnterNewbieOrGuestRegion()
   {
      % We used to erase inventory here.  Seems dangerous to irrevocably do this.
      return;
   }

   CheckLeavingNewbieOrGuest(leaving=$)
   {
      local oldregion, region;

      % We're potentially changing rooms here. poOwner is already set to new
      %  room.
      if leaving = poOwner OR Send(self,@PlayerIsImmortal)
      {
         return FALSE;
      }

      oldregion = Send(leaving,@GetRegion);
      region = Send(poOwner,@GetRegion);

      if region = oldregion
      {
         if region = RID_NEWB_BASE
            OR region = RID_GUEST_BASE
         {
            Send(self,@SetInitialHomeroom);
         }
         
         return FALSE;
      }

      if oldregion = RID_NEWB_BASE
         OR oldregion = RID_GUEST_BASE
      {
         Send(self,@LeaveNewbieOrGuestRegion);
      }

      if region = RID_NEWB_BASE
         OR region = RID_GUEST_BASE
      {
         Send(self,@EnterNewbieOrGuestRegion);
      }

      return TRUE;
   }

   AddCurrentQuest(node = $, template = $)
   "Adds a quest to the user's plActiveQuests list.  Each element in "
   "this list is a quest template ID followed by the current active "
   "quest node.  Quests are removed from this list by AddQuestHistory "
   "when the quest finishes."
   {
      local i;

      % Only add the quest if we have a valid quest template and quest node.
      if node = $
         OR template = $
      {
         return;
      }

      % See if we need to change the quest node.
      % QuestEngine prevents duplicate quests.
      foreach i in plActiveQuests
      {
         if First(i) = template
         {
            SetNth(i,2,node);

            return;
         }
      }

      % Add to the end, so quests are displayed in the order given.
      plActiveQuests = AppendListElem([template,node],plActiveQuests);

      % Update the user's quest log.
      Send(self,@ToCliStats,#group=5);

      return;
   }

   RemoveCurrentQuest(index=$)
   "Deletes a quest from the user's plActiveQuests."
   {
      local i;

      if index = $
      {
         return;
      }

      foreach i in plActiveQuests
      {
         if First(i) = index
         {
            plActiveQuests = DelListElem(plActiveQuests,i);
         }
      }

      % Post this, so plQuestHistory can update first.
      Post(self,@ToCliStats,#group=5);

      return;
   }

   GetActiveQuestNode(index=$)
   "Uses the quest template index to get the quest node the "
   "user is currently on."
   {
      local i;

      if index = QST_ID_NONE
      {
         return $;
      }

      % Try active quests first.
      foreach i in plActiveQuests
      {
         if First(i) = index
         {
            return Nth(i,2);
         }
      }

      % Check completed list.
      foreach i in plQuestHistory
      {
         if (First(i) & QUEST_HISTORY_MASK) = index
            AND (First(i) & QUEST_HISTORY_SUCCESS)
         {
            return $;
         }
      }

      return $;
   }

   ResignFaction()
   "Cancel any active loyalty or faction quests."
   {
      local i, iQID;

      if plActiveQuests = $
      {
         propagate;
      }

      foreach i in plActiveQuests
      {
         iQID = First(i);
         if iQID = QST_ID_PRINCESS_SERVICE
            OR iQID = QST_ID_DUKE_SERVICE
            OR iQID = QST_ID_REBEL_SERVICE
            OR iQID = QST_ID_PRINCESS_SOLDIER
            OR iQID = QST_ID_DUKE_SOLDIER
            OR iQID = QST_ID_REBEL_SOLDIER
         {
            % Post this, because it will edit the plActiveQuests list.
            Post(Nth(i,2),@DeadlineExpired);
         }
      }

      propagate;
   }

   % plQuestHistory is list of lists of the format
   %  [ compound, last_success_time, last_failure_time ]
   % compound is:
   %  QUEST_HISTORY_SUCCESS bit indicates player has done quest successfully
   %   at least once
   %  QUEST_HISTORY_FAILURE bit indicates player has failed quest at least once
   %  Remaining bits are quest index.
   % Times are TimeLoggedIn values, which count the total time logged in
   %  across sessions

   GetQuestHistory(index = $)
   "Return quest history bits for indicated quest for this player, or nil "
   "if illegal index provided."
   {
      local lQH;
      
      if plQuestHistory = $ 
      {
         return [0,0,0];
      }
      
      if index = $ 
      {
         return $;
      }
      
      if (index & ~QUEST_HISTORY_MASK) <> 0 
      {
         Debug("GetQuestHistory got illegal index.");
         
         return $;
      }
      
      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            return lQH;
         }
      }
      
      return [0,0,0];
   }

   AddQuestHistory( index = $, success = $ )
   "Set quest history success/failure bit for indicated quest for this "
   "player, adding quest index to list if necessary, and update last "
   "successtime, failtime.  "
   "Returns TRUE on success, FALSE if illegal parameters provided."
   {
      local lQH, iLength, iTime, templQH;

      if index = $
      {
         return FALSE;
      }

      if (index & ~QUEST_HISTORY_MASK) <> 0
      {
         return FALSE;
      }

      if success = $
      {
         return FALSE;
      }

      Send(self,@RemoveCurrentQuest,#index=index);

      iTime = Send( self, @GetTimeLoggedIn );
      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            if success
            {
               SetNth(lQH,1,(First(lQH)|QUEST_HISTORY_SUCCESS));
               SetNth(lQH,2,iTime);
            }
            else
            {
               SetNth(lQH,1,(First(lQH)|QUEST_HISTORY_FAILURE));
               SetNth(lQH,3,iTime);
            }
            % Move quest to front of list.
            templQH = lQH;
            plQuestHistory = DelListElem(plQuestHistory, lQH);
            plQuestHistory = Cons(lQH, plQuestHistory);

            return TRUE;
         }
      }

      % new quest for this user
      if success
      {
         lQH = [(index | QUEST_HISTORY_SUCCESS), iTime, 0];
      }
      else
      {
         lQH = [(index | QUEST_HISTORY_FAILURE), 0, iTime];
      }

      plQuestHistory = Cons(lQH, plQuestHistory);

      return TRUE;
   }

   ClearQuestHistory(index=$, allBelow=FALSE, allAbove=FALSE)
   "Admin supported."
   "Clear a particular quest, or all above/below it (inclusive)."
   "Call with no args to clear all quests."
   "Called with no args at suicide."
   {
      local oQuestEngine, step;

      if index = $
         OR (allBelow AND allAbove)
      {
         plQuestHistory = $;
         if pbLogged_on
         {
            Send(self,@ToCliStats,#group=5);
         }

         return;
      }

      oQuestEngine = Send(SYS,@GetQuestEngine);
      step = 0;
      
      if allBelow
      {
         step = -1;
      }
      
      if allAbove
      {
         step = 1;
      }
      
      if step = 0
      {
         Send(self,@ClearOneQuestHistory,#index=index);
      }
      else
      {
         while Send(oQuestEngine,@IsValidQuestTemplate,#index=index)
         {
            Send(self,@ClearOneQuestHistory,#index=index);
            index = index + step;
         }
      }
      
      return;
   }

   ClearOneQuestHistory(index = $)
   "Admin supported."
   "A little safer than ClearQuestHistory,"
   "since a typo won't screw up everything."
   {
      local lQH;

      foreach lQH in plQuestHistory
      {
         if (first(lQH) & QUEST_HISTORY_MASK) = index
         {
            plQuestHistory = DelListElem(plQuestHistory, lQH);
            
            if pbLogged_on
            {
               Send(self,@ToCliStats,#group=5);
            }

            return TRUE;
         }
      }
      
      return FALSE;
   }

   UpdateTimeValues()
   "Sets all time variables to the current time.  Useful for when changing server time."
   {
      % Don't set piTimeNewsPosted to current time.  That'd potentially make
      %  people unable to post for a while.
      piTimeNewsPosted = 0;
      piLastMoveUpdateTime = GetTickCount();

      % Eliminate logoff penalty time.  Just easier this way.
      Send(self,@RefreshPhaseTimeToBase);

      propagate;
   }

   SomeoneOverheard(from=$,to=$,format=$,string=$)
   {
      local rFrom;
      
      if NOT pbLogged_on
      {
         propagate;
      }

      rFrom = Send(from,@GetTrueName);

      AddPacket(1,BP_SAID, 4,from, 4,rFrom, 1,SAY_GROUP_ONE, 4,format,
                4,rFrom, 4,Send(to,@GetTrueName), 0,string);
      SendPacket(poSession);

      propagate;
   }

   ResetCheaterLogs()
   "Resets the number of moves logged so that we can continue logging "
   "suspected speedhack abuse."
   {
      if piCheaterLogs > 0
      {
         piCheaterLogs = 0;
      }

      return;
   }

   HasMovedRecently()
   "Checks if user is mobile and has moved in the last few seconds."
   {
      % We're not moving if it's been more than 2 seconds since we moved
      %   OR if we're flagged as unable to move.
      if (GetTime() - piLastMoveUpdateTime) > 2
         OR (piFlags & PFLAG_NO_MOVE)
      {
         return FALSE;
      }

      return TRUE;
   }

   GetIdleTime()
   {
      return GetInactiveTime(poSession);
   }

   AdminGotoBlink()
   {
      local oRoom;

      if pbLogged_on
      {
         oRoom = poOwner;
         Send(oRoom,@Teleport,#what=self);
      }
      else
      {
         oRoom = Send(SYS,@FindRoomByNum,#num=piSave_room);
         Send(self,@SetSaveLocation,
              #row=Send(oRoom,@GetTeleportRow),
              #col=Send(oRoom,@GetTeleportCol));
      }

      return;
   }

   SetSaveLocation(rid=$,row=$,col=$)
   {
      if rid <> $
      {
         piSave_room = rid;
      }
      
      if row <> $
      {
         piSave_row = row;
         piSave_fine_row = FINENESS/2;
      }
      
      if col <> $
      {
         piSave_col = col;
         piSave_fine_col = FINENESS/2;
      }
      
      return;
   }

   GetSaveRoom()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_room;
   }
   
   GetSaveRow()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_row;
   }
   
   GetSaveCol()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_Col;
   }
   
   GetSaveFineRow()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_Fine_row;
   }
   
   GetSaveFineCol()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_Fine_Col;
   }
   
   GetSaveAngle()
   {
      if pbLogged_on
      {
         return $;
      }
      
      return piSave_Angle;
   }

   RemoveOldMail(iDays=180)
   {
      local iCutoff_time, lRecent_mail, lNew_mail, iTime, iRemoved;

      iCutoff_time =  GetTime() - (iDays * DAY);
      lRecent_mail = $;
      iRemoved = 0;

      foreach lNew_mail in plNew_mail
      {
         % This is a list of [ from, time, list of to, other ]
         iTime = Nth(lNew_mail,2);
         if (iTime > iCutoff_time)
            AND iTime < GetTime()
         {
            lRecent_mail = Cons(lNew_mail,lRecent_mail);
         }
         else
         {
            ++iRemoved;
         }
      }
      if Length(plNew_mail) <> Length(lRecent_mail)
      {
         Debug("User",self,vrName,"had",Length(plNew_mail),"now",
               Length(lRecent_mail));
      }
      plNew_mail = lRecent_mail;

      return iRemoved;
   }

   CleanBadMail()
   {
      local lNew_mail, stuff, i, j;

      i = 1;
      foreach lNew_mail in plNew_mail
      {
         % This is a list of [ from, time, list of to, list of stuff ]
         stuff = Nth(lNew_mail,4);
         if (Length(stuff) > 1)
         {
            j = 1;
            while j <= Length(stuff)
            {
               if (Nth(stuff,j+1) = $)
               {
                  Debug("found bad mail",self);
                  plNew_mail = DelListElem(plNew_mail, lNew_mail);

                  return 1;
               }
               j = j + 2;
            }
         }
         ++i;
      }

      return 0;
   }

   GetIP()
   "Returns the user's ip in a list which contains the 4 octets"
   "use this message for comparisons and the string message sparingly"
   {
      return GetSessionIP(poSession);
   }
   
   GetIPString()
   "returns ip as a string.  Use this sparingly and only if"
   "you need the human readable string, use the list returned by"
   "GetIP() for comparisons"
   {
      local sReturn, lIP;
      
      lIP = GetSessionIP(poSession);
      if (lIP = $)
      {
         return;
      }

      sReturn = CreateString();
      
      ClearTempString();
      
      AppendTempString(Nth(lIP,1));
      AppendTempString(":");
      AppendTempString(Nth(lIP,2));
      AppendTempString(":");
      AppendTempString(Nth(lIP,3));
      AppendTempString(":");
      AppendTempString(Nth(lIP,4));
      AppendTempString(":");
      AppendTempString(Nth(lIP,5));
      AppendTempString(":");
      AppendTempString(Nth(lIP,6));
      AppendTempString(":");
      AppendTempString(Nth(lIP,7));
      AppendTempString(":");
      AppendTempString(Nth(lIP,8));
      AppendTempString(":");
      AppendTempString(Nth(lIP,9));
      AppendTempString(":");
      AppendTempString(Nth(lIP,10));
      AppendTempString(":");      
      AppendTempString(Nth(lIP,11));
      AppendTempString(":");
      AppendTempString(Nth(lIP,12));
      AppendTempString(":");
      AppendTempString(Nth(lIP,13));
      AppendTempString(":");
      AppendTempString(Nth(lIP,14));
      AppendTempString(":");
      AppendTempString(Nth(lIP,15));
      AppendTempString(":");
      AppendTempString(Nth(lIP,16));

      SetString(sReturn,GetTempString());
      
      return sReturn;
   
   }

   SendStatChange()
   "Sends a stat change request to the client"
   {
      local lSpellLevels, lSkillLevels;

      % if stats reset is turned off, ignore the request
      if NOT Send(SETTINGS_OBJECT,@GetStatsResetEnabled)
      {
         return;
      }
      
      % must have a token if over the free stat reset cap
      if Send(self,@FindHolding,#class=&StatsResetToken) = $
         AND (piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap))
      {
         return;
      }
      
      lSpellLevels = Send(self, @GetSpellSchoolLevels);
      lSkillLevels = Send(self, @GetSkillSchoolLevels);
 
      % TODO: don't load module if it is already loaded


      Send(self,@UserLoadModule,#module=user_statchange_module);
      AddPacket(1,BP_STAT_CHANGE);
      AddPacket(1,piMight);
      AddPacket(1,piIntellect);
      AddPacket(1,piStamina);
      AddPacket(1,piAgility);
      AddPacket(1,piMysticism);
      AddPacket(1,piAim);
      AddPacket(1,Nth(lSpellLevels,1));
      AddPacket(1,Nth(lSpellLevels,2));
      AddPacket(1,Nth(lSpellLevels,3));
      AddPacket(1,Nth(lSpellLevels,4));
      AddPacket(1,Nth(lSpellLevels,5));
      AddPacket(1,Nth(lSpellLevels,6));
      AddPacket(1,Nth(lSkillLevels,1));
      SendPacket(poSession);
      return;
   }
   
   UserChangedStats(might=25,intellect=25,stamina=25,agility=25,mysticism=25,
                     aim=25,shallile_lvl=0,qor_lvl=0,kraanan_lvl=0,faren_lvl=0,
                     riija_lvl=0,jala_lvl=0,weaponcraft_lvl=0)
   "Processes a stat change request from the client"
   {
      local i,lSpellLevels,lSkillLevels,lSpellLevels_new,lSkillLevels_new,
            totalLevels,totalSchools,totalLvlOnes,iPrimaryStat,
            oSpell,iSpellAbility,iSpellNum,
            oSkill,iSkillAbility,iSkillNum;

      % if stats reset is turned off, ignore the request
      if NOT Send(SETTINGS_OBJECT,@GetStatsResetEnabled)
      {
         return;
      }
      
      if Send(self,@FindHolding,#class=&StatsResetToken) = $
         AND (piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap))
      {
         return;
      }
      
      i = 1;
      totallevels = 0;
      totalLvlOnes = 0;
      totalSchools = 0;
      lSpellLevels = Send(self, @GetSpellSchoolLevels);
      lSpellLevels_new = [shallile_lvl,qor_lvl,kraanan_lvl,
                           faren_lvl,riija_lvl,jala_lvl];
      lSkillLevels = Send(self, @GetSkillSchoolLevels);
      lSkillLevels_new = [weaponcraft_lvl];
   
      % Range Checks, no client hacking negative stats funny business!
      if (might < 1 OR might > 50)
         OR (intellect < 1 OR intellect > 50)
         OR (stamina < 1 OR stamina > 50)
         OR (agility < 1 OR agility > 50)
         OR (mysticism < 1 OR mysticism > 50)
         OR (aim < 1 OR aim > 50)
      {
         Debug("Stat Range Check: Failed!");
         return FALSE;
      }
      
      % School Range Check
      if (shallile_lvl < 0 OR shallile_lvl > 6)
         OR (qor_lvl < 0 OR qor_lvl > 6)
         OR (kraanan_lvl < 0 OR kraanan_lvl > 6)
         OR (faren_lvl < 0 OR faren_lvl > 6)
         OR (riija_lvl < 0 OR riija_lvl > 6)
         OR (jala_lvl < 0 OR jala_lvl > 6)
         OR (weaponcraft_lvl < 0 OR weaponcraft_lvl > 6)
      {
         Debug("School Range Check: Failed!");
         return FALSE;
      }
         
      % Quick check for too many points in stats
      if ((might + intellect + stamina + agility + mysticism + aim) > 200 )
      {
         Debug("Points Check: FAIL!");
         return FALSE;
      }
      Debug(("points check: PASS"));

      % Check school levels for funny business
      
      % Count schools above level 1
      
      % Spell Levels - skipping DM school (7)
      while (i < NUM_SCHOOLS)
      {
         if (Nth(lSpellLevels_new,i) = 1)
         {
            totalLvlOnes = totalLvlOnes + 1;
         }
         if (Nth(lSpellLevels_new,i) > 1)
         {
            totalSchools = totalSchools + 1;
            totalLevels = totalLevels + Nth(lSpellLevels_new,i);
         }
         if (Nth(lSpellLevels_new,i) > Nth(lSpellLevels,i))
         {
            Debug("School Not Increased Check: FAIL!");
            return FALSE;
         }
         i=i+1;
      }
      
      % skill levels
      i=1;
      while (i <= NUM_SKILL_SCHOOLS)
      {
         if (Nth(lSkillLevels_new,i) = 1)
         {
            totalLvlOnes = totalLvlOnes + 1;
         }
         if (Nth(lSkillLevels,i) > 1)
         {
            totalSchools = totalSchools + 1;
            totalLevels = totalLevels + Nth(lSkillLevels_new,i);
         }
         if (Nth(lSkillLevels_new,i) > Nth(lSkillLevels,1))
         {
            Debug("School Not Increased Check: FAIL!");
            return FALSE;
         }
         i=i+1;
      }
      
      % treat level 1s as level 2s
      totalLevels = totalLevels + totalLvlOnes;
      
      % See if the player has enough int to support their levels
      if ((totalLevels - totalSchools > 8)
               AND (((totalLevels - totalSchools - 8) * 5) > intellect))
      {
         Debug("Int Check: FAIL!");
         %Debug("total levels",totalLevels,"intellect",intellect,"needed",
         %      (totalLevels - totalSchools - 8) * 5);
         return FALSE;
      }
      
      Debug(("School Level Check: PASS"));
      
      % everything looks good, start adjusting stats
      
      % Consume token
      if piBase_Max_Health > Send(SETTINGS_OBJECT,@GetFreeStatsResetCap)
      {
         Send(Send(self,@FindHolding,#class=&StatsResetToken),@Delete);
      }
      
      % Strip Spell Levels
      i = 1;
      while (i < NUM_SCHOOLS)
      {
         if (Nth(lSpellLevels,i) > 0 )
         {
            while (Nth(lSpellLevels,i) > Nth(lSpellLevels_new,i))
            {
               Send(self,@StripSpellsOfSchoolByLevel,#school=i,
                     #level=Nth(lSpellLevels,i));
               SetNth(lSpellLevels,i,Nth(lSpellLevels,i) - 1);
            }
         }
         i=i+1;
      }
      Debug("Spell Schools Stripped");
      % Strip Skills (Skill schools start at 10)
      i=1;
      while (i <= NUM_SKILL_SCHOOLS)
      {
         if (Nth(lSkillLevels,i) > 0)
         {
            while(Nth(lSkillLevels,i) > Nth(lSkillLevels_new,i))
            {
               % have to add 9 to i to get the proper school id
               Send(self,@StripSkillsOfSchoolByLevel,#school=i+9,
                     #level=Nth(lSkillLevels,i));
               SetNth(lSkillLevels,i,Nth(lSkillLevels,i) - 1);
            }
         }
         i=i+1;
      }
      Debug("Skill Schools Stripped");
      
      % Now iterate through the player's spells and strip 2% per stat loss
      foreach i in plSpells
      {
         iSpellNum = Send(self,@DecodeSpellNum,#compound=i);
         oSpell = Send(SYS,@FindSpellByNum,#num=iSpellNum);
         iPrimaryStat = Send(oSpell,@GetPrimaryStat);
         iSpellAbility = Send(self,@DecodeSpellAbility,#compound=i);

         if (iPrimaryStat = STAT_ID_STAMINA)
         {
            if (iSpellAbility > (stamina * 2)) AND (stamina < piStamina)
               OR (iSpellAbility = 99 AND piStamina = 50 AND stamina < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piStamina - stamina)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
         else if (iPrimaryStat = STAT_ID_INTELLECT)
         {
            if (iSpellAbility > (intellect * 2)) AND (intellect < piIntellect)
               OR (iSpellAbility = 99 AND piIntellect = 50 AND intellect < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piIntellect - intellect)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
         else if (iPrimaryStat = STAT_ID_MYSTICISM)
         {
            if (iSpellAbility > (piMysticism * 2)) AND (mysticism < piMysticism)
               OR (iSpellAbility = 99 AND piMysticism = 50 AND mysticism < 50)
            {
               Send(self,@ChangeSpellAbility,#spell_num=iSpellNum,
                     #amount=((piMysticism - mysticism)
                     * Send(SETTINGS_OBJECT,@GetStatsResetPenalty)));
            }
         }
      }
      Debug("Spell % Recalculated");
      
      foreach i in plSkills
      {
         iSkillNum = Send(self,@DecodeSkillNum,#compound=i);
         oSkill = Send(SYS,@FindSkillByNum,#num=iSkillNum);
         iPrimaryStat = Send(oSkill,@GetPrimaryStat);
         iSkillAbility = Send(self,@DecodeSkillAbility,#compound=i);
         
         if (iPrimaryStat = STAT_ID_AGILITY)
         {
            if (iSkillAbility > (agility * 2)) AND (agility < piAgility)
               OR (iSkillAbility = 99 AND piAgility = 50 AND agility < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piAgility - agility) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_AIM)
         {
            if (iSkillAbility > (aim * 2)) AND (aim < piAim)
               OR (iSkillAbility = 99 AND piAim = 50 AND aim < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piAim - aim) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_MIGHT)
         {
            if (iSkillAbility > (might * 2)) AND (might < piMight)
               OR (iSkillAbility = 99 AND piMight = 50 AND might < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piMight - might) * -2));
            }
         }
         else if (iPrimaryStat = STAT_ID_STAMINA)
         {
            if (iSkillAbility > (stamina * 2)) AND (stamina < piStamina)
               OR (iSkillAbility = 99 AND piStamina = 50 AND stamina < 50)
            {
               Send(self,@ChangeSkillAbility,#skill_num=iSkillNum,
                     #amount=((piStamina - stamina) * -2));
            }
         }
      }
      Debug("Skill % Recalculated");

      Debug(Send(self,@GetTrueName), " changed stats from ",
         piMight, piIntellect, piStamina, piAgility, piMysticism, piAim,
         " to ", might, intellect, stamina, agility, mysticism, aim);
      % Now set the stats
      piStamina = stamina;
      piIntellect = intellect;
      piMight = might;
      piAgility = agility;
      piMysticism = mysticism;
      piAim = aim;

      % A change in stamina results in a reduction in hitpoints if the
      % player's hitpoints will be > 100 + new Stamina
      if (piBase_Max_Health > 100 + Send(self,@GetStamina))
      {
         % If called with no amount, will verify current max HP is valid.
         Send(self,@GainBaseMaxHealth);
         Debug("HitPoints Adjusted");
      }

      % recalculate mana pool based on nodes and mysticism
      Send(self,@ComputeMaxMana);
      Debug("Mana Recalculated");
      
      % TODO: Unload stats.dll module.

      % Refresh the client screen so they see the new stats
      Send(self, @InvalidateData);
      Debug("Player Updated!");

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
