% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SafetyDepositBox is Holder

%% these are used by storage.kod to store stuff in.  These items are never to 
%% be placed in the world

constants:

   include blakston.khd
 
resources:

classvars:

   viObject_flags = CONTAINER_YES

   viBulk_hold_max = 2500
   viWeight_hold_max = $

properties:
   
   piVault_num = $
   poPlayer = $

messages:

   Constructor(vid=$, who=$)
   {
      if vid = $ or who = $  { debug("vault not constructed correctly."); return; }

      piVault_num = vid;
      poPlayer = who;
      propagate;
   }

   GetBulkMax()
   {
      local oVault;
      oVault = send(SYS,@FindVaultByNum,#num=piVault_num);
      return send(oVault,@GetCapacity);
   }
   
   GetSafeBoxOwner()
   {
      return poPlayer;
   }

   ReqNewOwner(what = $)
   {
      return False;
   }

   ReqNewHold(what=$)
   {
      return isClass(what,&PassiveItem);      
   }

   NewHold(what=$)
   {
      % debug(send(what,@GetName));
      propagate;
   }

   HolderDoAddNode(node = $, lNodes = $)
   {
      local oCurrentNode, index, inserted;
      index = 1;
      inserted = FALSE;

      for oCurrentNode in lNodes
      {
         if GetClass(oCurrentNode) = GetClass(node)
         {
            InsertListElem(lNodes,index,node);
            inserted = TRUE;
            break;
         }
         index = index + 1;
      }

      if inserted = FALSE
      {
         lNodes = Cons(node, lNodes);
      }

      return lNodes;
   }

   ReplaceContent(owner = $, vaultman = $, item_list = $, number_list = $)
   {
      local i, j, lItemListCopy, lVaultListCopy, iCount;

      lVaultListCopy = Send(SYS,@ListCopy,#source=plPassive);
      lItemListCopy = Send(SYS,@ListCopy,#source=item_list);
      iCount = 0;

      % Make sure all items are in storage.
      % First remove all items that are on both lists.
      for i in lItemListCopy
      {
         % Debug("checking item ", Send(i,@GetName));
         for j in lVaultListCopy
         {  
            % Debug("against item ", Send(j,@GetName));
            if isClass(i,&NumberItem) AND GetClass(i) = GetClass(j)
            {
               iCount = iCount + 1; 
               if nth(number_list,iCount) <> Send(j,@GetNumber)
               {
                  Send(vaultman,@SayToOne,#target=owner,#message_rsc=vaultman_not_enough,#parm1=Send(i,@GetName));
                  return;
               }
               % Debug("Deleting number element ", Send(j,@GetName));
               lItemListCopy = DelListElem(lItemListCopy,i);
               lVaultListCopy = DelListElem(lVaultListCopy,j);
               break;
            }
            if i = j 
            {
               % Debug("Deleting element ", Send(j,@GetName));
               lItemListCopy = DelListElem(lItemListCopy,i);
               lVaultListCopy = DelListElem(lVaultListCopy,j);
               break;
            }
         }
      }
      % If there are items left on any list, the user sent us wrong data.
      if lItemListCopy <> $
      {
         Send(vaultman,@SayToOne,#target=owner,#message_rsc=vaultman_dont_have,#parm1=Send(First(lItemListCopy),@GetIndef),#parm2=Send(First(lItemListCopy),@GetName));
         return;
      }
      if lVaultListCopy <> $
      {
         Send(vaultman,@SayToOne,#target=owner,#message_rsc=vaultman_dont_have,#parm1=Send(First(lVaultListCopy),@GetIndef),#parm2=Send(First(lVaultListCopy),@GetName));
         return;
      }

      plPassive = item_list;

      return;
   }

   Delete()
   {      
      poPlayer = $;

      propagate;
   }
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
