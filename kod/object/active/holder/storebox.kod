% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
StorageBox is Holder

constants:

   include blakston.khd

   CLEAN_DELAY = 21600000   %% if the chests aren't replaced in 6 hours,
                            %% they delete themselves.

resources:

   storagebox_name_rsc = "some storage"
   storagebox_icon_rsc = box1.bgf

   storagebox_desc_rsc = "This is a place to store stuff."

   storagebox_dont_have = "There is no %s%s in the storage."
   storagebox_not_enough = "There aren't that many %s stored."
   storagebox_empty = "%s%s is empty."

classvars:

   vrName = storagebox_name_rsc
   vrIcon = storagebox_icon_rsc
   vrDesc = storagebox_desc_rsc

   viBulk_hold_max = 4000
   viWeight_hold_max = $

properties:

   % Placed here so we can change it when locked.
   viObject_flags = CONTAINER_YES

   pbLocked = FALSE
   ptClean = $

messages:

   Constructor(bLocked=$)
   {
      if bLocked
      {
         pbLocked = TRUE;
         viObject_Flags = viObject_Flags & ~CONTAINER_YES;
      }

      propagate;
   }

   ReqNewOwner(what = $)
   {
      return FALSE;
   }

   SendAnimation()
   {
      if pbLocked
      {
         AddPacket(1,ANIMATE_NONE,2,1);
       
         return;
      }
 
      AddPacket(1,ANIMATE_NONE,2,2);

      return;
   }

   EnterLimbo()
   {
      if poOwner<> $
      {
         send(poOwner,@LeaveHold,#what=self);
         poOwner = $;
      }
      
      ptClean = CreateTimer(self,@CleanTimer,CLEAN_DELAY);
      
      return;
   }

   CleanTimer()
   {
      ptClean = $;
      if poOwner = $
      {
         DEBUG("Self-cleaning excess chests.");
         send(self,@Delete);
      }
      
      return;
   }

   NewOwner(what=$)
   {
      if what <> $ 
      {
         if ptClean <> $
         {
            deletetimer(ptClean);
            ptClean = $;
         }
      }
      
      propagate;
   }

   Delete()
   {
      if ptClean <> $
      {
         deletetimer(ptClean);
         ptClean = $;
      }
      
      send(SYS,@RemoveChestFromList,#oChest=self);
      
      propagate;
   }


   ReqTaker(what=$,taker=$)
   {
      local oTakerOwner;

      oTakerOwner = send(taker,@GetOwner);
      
      if IsClass(taker,&User)
         AND NOT IsClass(taker,&Admin)
         AND IsClass(oTakerOwner,&Room) AND IsClass(poOwner,&Room)
         AND oTakerOwner <> poOwner
      {
         debug("ALERT!  ",send(taker,@GetTrueName),taker," in RID ",send(oTakerOwner,@GetRoomNum)," taking from distant chest in RID ",send(poOwner,@GetRoomNum));
         
         return FALSE;
      }
   
      if isClass(poOwner,&GuildHall)
      {
         return send(poOwner,@ReqTakeFromGuildChest,#what=what,#taker=taker);
      }

      propagate;
   }

   ReqNewHold(what = $, who = $)
   {
      local oWhoOwner;

      % The player's owner.
      oWhoOwner = send(who,@GetOwner);

      if IsClass(who,&User)
         AND NOT IsClass(who,&Admin)
         AND IsClass(oWhoOwner,&Room) AND IsClass(poOwner,&Room) 
         AND oWhoOwner <> poOwner
      {
         debug("ALERT!  ",send(who,@GetTrueName),who," in RID ",send(oWhoOwner,@GetRoomNum)," putting into distant chest in RID ",send(poOwner,@GetRoomNum));
         
         return FALSE;
      }

      if NOT Send(what,@CanBeStoredInVault)
      {
         return FALSE;
      }

      propagate;
   }

   LockChest(bLocked=$)
   {
      pbLocked = bLocked;
 
      if pbLocked
      {
         viObject_Flags = viObject_Flags & ~CONTAINER_YES;
      }

      if NOT pbLocked
      {
         viObject_Flags = viObject_Flags | CONTAINER_YES;
      }
      
      Send(poOwner,@SomethingChanged,#what=self);

      return;
   }

   GetItemsStored(who=$)
   {
      if Send(who,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(who,@GetTrueName),who," tried to get items stored from ",Send(self,@GetTrueName),
               " while in distant RID ",Send(Send(who,@GetOwner),@GetRoomNum));
         return FALSE;
      }
      return Send(self,@GetHolderPassive);
   }

   SortVaultItems(owner = $, item_list = $, number_list = $)
   "Sort the storage box corresponding to the given item list. The number list has an entry for every NumberItem in the item list."
   "All items in the list must be present in the storage with the correct quantity, otherwise the storage will stay unchanged."
   {
      local lDifferences, oFirstDifference;

      if Send(owner,@GetOwner) <> poOwner
      {
         Debug("ALERT! ",Send(owner,@GetTrueName),owner," tried to sort storage box from ",Send(self,@GetTrueName),
               " while in distant RID ",Send(Send(owner,@GetOwner),@GetRoomNum));
         return FALSE;
      }

      lDifferences = $;
      lDifferences = Send(self,@CompareHoldToItemList,#item_list=item_list,#number_list=number_list);

      if lDifferences <> $
      {
         oFirstDifference = First(lDifferences);
         if IsClass(oFirstDifference,&NumberItem)
         {
            Send(owner,@SysMsgSendUser,#message_rsc=storagebox_not_enough,#parm1=Send(oFirstDifference,@GetName));
         }
         else
         {
            Send(owner,@SysMsgSendUser,#message_rsc=storagebox_dont_have,#parm1=Send(oFirstDifference,@GetIndef),#parm2=Send(oFirstDifference,@GetName));
         }
         return;
      }

      plPassive = item_list;

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
