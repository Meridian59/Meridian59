% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Item is Object

constants:

   include blakston.khd
   include protocol.khd

   ARMOR_TAKE_DAMAGE_PCT = 75
   
resources:

   include item.lkod

   item_this = "This "
   item_blank_template = "%q"

   % item_desc_template is vrDesc, item attributes, object attributes,
   % variable item appends, item stats, item condition.
   item_desc_template = "%r%r%r%r%r%r"
   resource_blank = ""

   item_try_use_cursed_rsc = \
      "As you pick the item up, you feel a will greater than your own "
      "overwhelm your mind!  Not of your own volition, you try to put it on!"

   item_broken_battle = "Your %s shatters in the heat of battle!"
   item_broken_battle_plural = "Your %s shatter in the heat of battle!"
   item_broken_battle_clothing = "Your %s falls into useless tatters!"
   item_broken_battle_clothing_plural = "Your %s fall into useless tatters!"

   itematt_generic = \
      "  At first glance, it seems quite ordinary, but there is something odd "
      "about it you can't put your finger on."

   nakedleftarm_male = blg.bgf
   nakedrightarm_male = brg.bgf
   nakedleftarm_female = blh.bgf
   nakedrightarm_female = brh.bgf

   item_condition_exc = " is in immaculate condition."
   item_condition_exc_mended = \
      " is in excellent condition, but has been patched before."
   item_condition_good = " is scuffed and slightly worn."
   item_condition_med = " has a few unsightly rips."
   item_condition_poor = " is in tatters, and barely holding together."
   item_condition_broken = " is covered in filth and ripped beyond use."
   item_cond_master = "\n%s%s%s (%i/%i)"
   special_properties_header = \
      "\n\nThis item has the following properties:\n"
   item_stats_range = "%i range\n"
   item_stats_offense = "%i offense rating bonus\n"
   item_stats_armor = "%i armor\n"
   item_stats_defense = "%i defense rating bonus\n"
   item_stats_melee = "%i melee damage bonus\n"
   item_stats_min_dmg = "%i-"
   item_stats_base_dmg = "%r%i base damage\n"
   item_stats_owner_dmg = "%r%i damage in owner's hands\n"
   item_stats_cond_dmg = "%r%i conditional base damage\n"
   item_stats_cond_owner_dmg = "%r%i conditional damage in owner's hands\n"
   item_stats_dmg_bonus = "%i damage bonus\n"
   item_stats_gen_sp = "%i general spellpower\n"
   item_stats_faren_sp = "%i Faren spellpower\n"
   item_stats_riija_sp = "%i Riija spellpower\n"
   item_stats_kran_sp = "%i Kraanan spellpower\n"
   item_stats_jala_sp = "%i Jala spellpower\n"
   item_stats_shal_sp = "%i Shal'ille spellpower\n"
   item_stats_qor_sp = "%i Qor spellpower\n"
   item_stats_jala_instrument_sp = "%i Jala instrument power\n"
   item_stats_resistance = "%i%% %s\n"
   item_stats_dmg_type = "Deals %s damage\n"
   item_stats_proc_hold = "15%% chance to cast Hold on hit\n"
   item_stats_proc_blind = "15%% chance to cast Blind on hit\n"
   item_stats_proc_bonk = "8%% chance to cast Bonk on hit\n"
   item_stats_proc_purge = "15%% chance to cast Purge on hit\n"
   item_stats_proc_twister = "8%% chance to disorient victim on hit\n"
   item_stats_proc_vamp = "10%% chance to gain up to 8 health on hit\n"

classvars:

   vrItem_broken = item_broken_battle

   vrPoss_article = item_this
   viUse_type = ITEM_CANT_USE
   viItem_type = ITEMTYPE_MISC

   viUse_amount = 1

   viHits_init_min = 1
   viHits_init_max = 1

   viBulk = 10
   viWeight = 10

   viValue_average = 10

   viGround_group = 1
   viInventory_group = 1
   viBroken_group = $    % if set to nil, no group exists

   % How much this item will help or hinder spell usage.
   viSpell_modifier = 0

   vrIcon_male       = $
   vrIcon_female     = $
   vrLeftArm_male    = $
   vrLeftArm_female  = $
   vrRightArm_male   = $
   vrRightArm_female = $
   vrLegs_male       = $
   vrLegs_female     = $

   vbShow_condition =  FALSE
   vrCondition_exc =   item_condition_exc
   vrCondition_exc_mended = item_condition_exc_mended
   vrCondition_good =  item_condition_good
   vrCondition_med =   item_condition_med
   vrCondition_poor =  item_condition_poor
   vrCondition_broken = item_condition_broken
   
   % Items may have a different appearance once revealed. Values are zero if not applicable.
   viUnrevealedColor = 0
   viRevealedColor = 0

properties:

   viObject_flags = OF_GETTABLE
   piHits_init = 0
   piHits = 0
      
   plItem_attributes = $

   piItem_flags = 0

   % List of enchantments applied by radius spells.
   % Each element is [song object, spellpower, caster]
   % Support for players, monsters, and items
   plRadiusEnchantments = $

messages:

   Constructor(corpse=$)
   {
      local iHits_average, oItemAtt;

      piHits_init = Random(viHits_init_min,viHits_init_max);
      piHits = piHits_init;
      if corpse <> $
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_CORPSEPOINTER);
         if Send(oItemAtt,@ReqAddToItem,#oItem=self)
         {
            Send(oItemAtt,@AddToItem,#oItem=self,#state1=corpse);
         }            
      }
      
      if viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = 0
      {
         Send(self,@SetPaletteTranslation,#translation=viUnrevealedColor);
      }
      
      propagate;
   }

   SetItemPlayerFlag(who=$)
   {
      return;
   }

   AppendStatsDesc()
   "This is the statistics for the weapon, such as damage, armor, "
   "resists and spellpower added."
   {
      local i, bFoundProperties, iHigh_level, n, iFarenPower, iRiijaPower,
            iKraananPower, iJalaPower, iShalPower, iQorPower, iInstrumentPower,
            iNum, bID, iMinDamage, iMinDamageOwner, iAttackType;

      % This message 'telescopes' resources into the 5th %r of
      % item_desc_template. There are 16 different stats we can add;
      % when we first add a stat to be displayed we add a template with
      % the correct number of %r formatters to match the number of stats
      % remaining (plus one for the special_properties_header). If a stat
      % is missing after we have already added the headers, add a blank
      % resource ("") in its place. If new stats are added to this message,
      % the system_rsc_template_<number> resources should be updated
      % accordingly.

      % bFoundProperties is TRUE if we've already added a property. Use this
      % to lower the amount of resources we send to only those necessary.
      bFoundProperties = FALSE;

      if Send(self,@GetRange) <> 0
      {
         AddPacket(4,system_rsc_template_16, 4,special_properties_header,
                   4,item_stats_range, 4,Send(self,@GetRange)/FINENESS);
         bFoundProperties = TRUE;
      }

      if Send(self,@GetHitBonus) <> 0
      {
         if bFoundProperties
         {
            % bFoundProperties TRUE, already added headers.
            AddPacket(4,item_stats_offense, 4,Send(self,@GetHitBonus));
         }
         else
         {
            % bFoundProperties FALSE, add headers.
            AddPacket(4,system_rsc_template_15, 4,special_properties_header,
                      4,item_stats_offense, 4,Send(self,@GetHitBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         % bFoundProperties TRUE and didn't add this particular stat,
         % so add a blank resource in its place.
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDamageReduction) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_armor, 4,Send(self,@GetDamageReduction));
         }
         else
         {
            AddPacket(4,system_rsc_template_14, 4,special_properties_header,
                      4,item_stats_armor, 4,Send(self,@GetDamageReduction));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDefenseBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_defense, 4,Send(self,@GetDefenseBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_13,4,special_properties_header,
                      4,item_stats_defense, 4,Send(self,@GetDefenseBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMeleeDamageBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_melee, 4,Send(self,@GetMeleeDamageBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_12, 4,special_properties_header,
                      4,item_stats_melee, 4,Send(self,@GetMeleeDamageBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iMinDamage = Send(self,@GetMinDamage);
      if iMinDamage <> 0
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_11, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxDamage) <> iMinDamage
         {
            AddPacket(4,item_stats_base_dmg,4,item_stats_min_dmg,
                      4,iMinDamage,4,Send(self,@GetMaxDamage));
         }
         else
         {
            AddPacket(4,item_stats_base_dmg,4,system_blank_resource,
                      4,iMinDamage);
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iMinDamageOwner = Send(self,@GetMinDamageWithOwnerStats);
      if iMinDamageOwner <> 0
         AND iMinDamageOwner <> iMinDamage
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_10, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxDamageWithOwnerStats)
            <> iMinDamageOwner
         {
            AddPacket(4,item_stats_owner_dmg, 4,item_stats_min_dmg,
                      4,iMinDamageOwner,4,Send(self,@GetMaxDamageWithOwnerStats));
         }
         else
         {
            AddPacket(4,item_stats_owner_dmg, 4,system_blank_resource,
                      4,iMinDamageOwner);
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMinSpecialDamage) <> 0
         AND Send(self,@GetMinSpecialDamage) <> iMinDamage
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_9, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxSpecialDamage) <> Send(self,@GetMinSpecialDamage)
         {
            AddPacket(4,item_stats_cond_dmg, 4,item_stats_min_dmg,
                      4,Send(self,@GetMinSpecialDamage),
                      4,Send(self,@GetMaxSpecialDamage));
         }
         else
         {
            AddPacket(4,item_stats_cond_dmg, 4,system_blank_resource,
                      4,Send(self,@GetMinSpecialDamage));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetMinSpecialDamageWithOwnerStats) <> 0
         AND Send(self,@GetMinSpecialDamageWithOwnerStats)
            <> Send(self,@GetMinSpecialDamage)
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_8, 4,special_properties_header);
            bFoundProperties = TRUE;
         }
         if Send(self,@GetMaxSpecialDamageWithOwnerStats)
            <> Send(self,@GetMinSpecialDamageWithOwnerStats)
         {
            AddPacket(4,item_stats_cond_owner_dmg, 4,item_stats_min_dmg,
                      4,Send(self,@GetMinSpecialDamageWithOwnerStats),
                      4,Send(self,@GetMaxSpecialDamageWithOwnerStats));
         }
         else
         {
            AddPacket(4,item_stats_cond_owner_dmg,4,system_blank_resource,
                      4,Send(self,@GetMinSpecialDamageWithOwnerStats));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetDamageBonus) <> 0
      {
         if bFoundProperties
         {
            AddPacket(4,item_stats_dmg_bonus, 4,Send(self,@GetDamageBonus));
         }
         else
         {
            AddPacket(4,system_rsc_template_7, 4,special_properties_header,
                      4,item_stats_dmg_bonus, 4,Send(self,@GetDamageBonus));
            bFoundProperties = TRUE;
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iFarenPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_LIGHT));
      iRiijaPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_BLINK));
      iKraananPower = Send(self,@GetSpellModifier,
                           #oSpell=Send(SYS,@FindSpellByNum,#num=SID_BLESS));
      iJalaPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_MIRTH));
      iShalPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_SEANCE));
      iQorPower = Send(self,@GetSpellModifier,
                        #oSpell=Send(SYS,@FindSpellByNum,#num=SID_DARKNESS));

      iInstrumentPower = 0;
      if IsClass(self,&Instrument)
      {
         iInstrumentPower = Send(self,@GetInstrumentLevel);
      }

      if iFarenPower <> 0
         OR iRiijaPower <> 0
         OR iKraananPower <> 0
         OR iJalaPower <> 0
         OR iShalPower <> 0
         OR iQorPower <> 0
         OR iInstrumentPower <> 0
      {
         if iFarenPower = iRiijaPower
            AND iRiijaPower = iKraananPower
            AND iKraananPower = iJalaPower
            AND iJalaPower = iShalPower
            AND iShalPower = iQorPower
            AND iFarenPower <> 0
         {
            if NOT bFoundProperties
            {
               AddPacket(4,system_rsc_template_6, 4,special_properties_header);
               bFoundProperties = TRUE;
            }
            AddPacket(4,item_stats_gen_sp, 4,iFarenPower);
         }
         else
         {
            if NOT bFoundProperties
            {
               AddPacket(4,system_rsc_template_6, 4,special_properties_header);
               bFoundProperties = TRUE;
            }

            AddPacket(4,system_rsc_template_7);

            if iFarenPower <> 0
            {
               AddPacket(4,item_stats_faren_sp, 4,iFarenPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iRiijaPower <> 0
            {
               AddPacket(4,item_stats_riija_sp, 4,iRiijaPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iKraananPower <> 0
            {
               AddPacket(4,item_stats_kran_sp, 4,iKraananPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iJalaPower <> 0
            {
               AddPacket(4,item_stats_jala_sp, 4,iJalaPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iShalPower <> 0
            {
               AddPacket(4,item_stats_shal_sp, 4,iShalPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iQorPower <> 0
            {
               AddPacket(4,item_stats_qor_sp, 4,iQorPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
            if iInstrumentPower <> 0
            {
               AddPacket(4,item_stats_jala_instrument_sp, 4,iInstrumentPower);
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if Send(self,@GetCurrentResistances) <> $
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_5, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         if Length(Send(self,@GetCurrentResistances)) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                           #iNum=Length(Send(self,@GetCurrentResistances))));
         }

         foreach i in Send(self,@GetCurrentResistances)
         {
            AddPacket(4,item_stats_resistance, 4,Nth(i,2),
                      4,Send(SYS,@GetResistanceName,#type=Nth(i,1)));
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iAttackType = Send(self,@GetAttackType);
      if iAttackType <> 0
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_4, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         if Length(Send(SYS,@GetAttackTypeList)) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                           #iNum=Length(Send(SYS,@GetAttackTypeList))));
         }

         foreach i in Send(SYS,@GetAttackTypeList)
         {
            if (iAttackType & i)
            {
               AddPacket(4,item_stats_dmg_type,
                         4,Send(SYS,@GetAttackDamageTypeName,#type=i));
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      iAttackType = Send(self,@GetAttackSpell);
      if iAttackType <> 0
      {
         if NOT bFoundProperties
         {
            AddPacket(4,system_rsc_template_3, 4,special_properties_header);
            bFoundProperties = TRUE;
         }

         if Length(Send(SYS,@GetSpellTypeList)) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                        #iNum=Length(Send(SYS,@GetSpellTypeList))));
         }

         foreach i in Send(SYS,@GetSpellTypeList)
         {
            if (iAttackType & i)
            {
               AddPacket(4,item_stats_dmg_type,
                         4,Send(SYS,@GetSpellDamageTypeName,#type=i));
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else if bFoundProperties
      {
         AddPacket(4,system_blank_resource);
      }

      if plItem_attributes <> $
      {
         if Length(plItem_attributes) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                           #iNum=Length(plItem_attributes)));
         }

         % TODO: Item attributes should handle this.
         foreach i in plItem_attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            bID = Send(self,@GetIDStatusFromCompound,#compound=First(i));
            if bID
            {
               if iNum = WA_PARALYZER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_hold);
               }
               else if iNum = WA_BLINDER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_blind);
               }
               else if iNum = WA_BONKER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_bonk);
               }
               else if iNum = WA_PURGER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_purge);
               }
               else if iNum = WA_TWISTER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_twister);
               }
               else if iNum = WA_VAMPER
               {
                  if NOT bFoundProperties
                  {
                     AddPacket(4,system_rsc_template_2,
                               4,special_properties_header);
                     bFoundProperties = TRUE;
                  }
                  AddPacket(4,item_stats_proc_vamp);
               }
               else
               {
                  AddPacket(4,system_blank_resource);
               }
            }
            else
            {
               AddPacket(4,system_blank_resource);
            }
         }
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   GetMinDamageWithOwnerStats()
   {
      return 0;
   }

   GetMaxDamageWithOwnerStats()
   {
      return 0;
   }

   GetMinSpecialDamageWithOwnerStats()
   {
      return 0;
   }

   GetMaxSpecialDamageWithOwnerStats()
   {
      return 0;
   }

   GetAttackType()
   {
      return 0;
   }

   GetAttackSpell()
   {
      return 0;
   }

   GetMinDamage()
   {
      return 0;
   }

   GetMaxDamage()
   {
      return 0;
   }

   % Some weapons and spells have special conditions, like nerudite arrows that can shatter
   GetMinSpecialDamage()
   {
      return 0;
   }

   GetMaxSpecialDamage()
   {
      return 0;
   }

   GetRange()
   {
      return 0;
   }

   GetHitBonus()
   {
      return 0;
   }

   GetDefenseBonus()
   {
      return 0;
   }

   GetMeleeDamageBonus()
   {
      return 0;
   }

   GetDamageBonus()
   {
      return 0;
   }

   GetDamageReduction()
   {
      return 0;
   }

   GetAttributes()
   {
      return plItem_Attributes;
   }

   GetResistanceModifiers()
   {
      return $;
   }

   DoBaseDesc()
   "Items can override this to provide a more detailed base description."
   {
      AddPacket(4,vrDesc);

      return;
   }

   ShowDesc(bShowAll = FALSE)
   {
      local bAlreadyBlind, bIdentified, oItemAtt, i, iNum;

      bAlreadyBlind = FALSE;

      AddPacket(4,item_desc_template);

      Send(self,@DoBaseDesc);

      if Send(self,@HasAttribute,#ItemAtt=IA_MISDIRECTION)
         AND NOT bShowAll
      {
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=IA_MISDIRECTION);
         Send(oItemAtt,@AppendMisdirectedDesc,#oItem=self,
               #lData=Send(self,@GetAttributeData,#ItemAtt=IA_MISDIRECTION));
      }
      else if plItem_Attributes <> $
      {
         % Support for displaying up to 12 itematts.
         if Length(plItem_Attributes) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                              #iNum=Length(plItem_Attributes)));
         }

         foreach i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            bIdentified = Send(self,@GetIDStatusFromCompound,
                              #compound=First(i));

            if NOT (bIdentified OR bShowAll)
            {
               if bAlreadyBlind
               {
                  AddPacket(4,system_blank_resource);
               }
               else
               {
                  AddPacket(4,itematt_generic);
                  bAlreadyBlind = TRUE;
               }
            }
            else
            {
               Send(oItemAtt,@AppendDesc,#oItem=self,#lData=i);
            }
         }
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      if plObject_attributes = $
      {
         AddPacket(4,system_blank_resource);
      }
      else
      {
         % Support for displaying up to 12 objectatts.
         if Length(plObject_attributes) > 1
         {
            AddPacket(4,Send(SYS,@AddResourceTemplate,
                              #iNum=Length(plObject_attributes)));
         }

         foreach i in plObject_attributes
         {
            Send(i,@AttributeDesc);
         }
      }

      % Special things for number items, etc.
      Send(self,@AppendDesc);
      Send(self,@AppendStatsDesc);
      Send(self,@AppendItemCondition);

      return;
   }

   AppendDesc()
   {
      AddPacket(4,system_blank_resource);

      return;
   }

   AppendItemCondition()
   {
      local iHit_Percent, rItem_condition;

      if vbShow_Condition
         AND piHits_init > 0
      {
         rItem_condition = vrCondition_exc;
         iHit_Percent = (100 * piHits) / piHits_init;
         if iHit_Percent > 90
         {
            % If item is worse than what can be found in the wild, describe it
            %  as being "patched".
            if piHits_init >= viHits_init_min
            {
               rItem_condition = vrCondition_exc;
            }
            else
            {
               rItem_condition = vrCondition_exc_mended;
            }
         }
         else if iHit_Percent > 65
         {
            ritem_condition = vrCondition_good;
         }
         else if iHit_Percent > 30
         {
            ritem_condition = vrCondition_med;
         }
         else if piHits > 0
         {
            ritem_condition = vrCondition_poor;
         }
         else
         {
            ritem_condition = vrCondition_broken;
         }

         AddPacket(4,item_cond_master, 4,vrPoss_Article, 4,Send(self,@GetName),
                   4,rItem_condition,4,piHits,4,piHits_init);
      }
      else
      {
         AddPacket(4,system_blank_resource);
      }

      return;
   }

   ReqRepair()
   {
      return FALSE;
   }

   DestroyDisposable()
   {
      if Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         return;
      }
      
      Send(self,@Delete);
      
      return;
   }

   GetItemUseType()
   {
      if piHits <= 0
      {
         return ITEM_BROKEN;
      }
      
      return viUse_type;
   }

   GetItemUseAmount()
   {
      return viUse_amount;
   }

   GetInitValue()
   {
      return viValue_average;
   }

   GetValue()
   {
      local iPercent, iValue, iFinal, i, oItemAtt, iNum;

      % Okay, new way of figuring value, considering 
      % max_hits, current_max_hits, and hits.
      % The basic formula follows this curve:
      %
      %              Hits
      %             Y   .8Y   .6Y   .4Y   .2Y
      % Max_hits  -----------------------------            
      %    Y        X   .80X  .60X  .40X  .20X
      %   .8Y           .64X  .48X  .32X  .16X
      %   .6Y                 .36X  .24X  .12X
      %   .4Y                       .16X  .08X
      %   .2Y                             .04X
      %
      %    Y = viHits_init_max (max_hits before casting 'mend')
      %    X = viAverage_value
      %
      % Translated:  An item whose piInit_hits is 80% of viHits_init_max
      %              and whose piHits is equal to that amount has a value equal
      %              to 64% of its standard value.

      iPercent = (100*piHits_init*piHits)/(viHits_init_max*viHits_init_max);
      iValue = Send(self,@GetInitValue);
      
      iFinal = (iValue * iPercent)/100;
      iFinal = bound(iFinal,10,iValue);      
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iFinal = Send(oItemAtt,@AdjustPrice,#value=iFinal,
                       #iCompound=First(i));
      }
      
      return iFinal;
   }

   GetMaxHits()
   {
      return piHits_init;
   }

   GetHits()
   {
      return piHits;
   }

   SetMaxHits(number = $)
   {
      if number = $
      {  
         return;
      }

      piHits_init = number;

      return;   
   }

   SetHits(number = $)
   {
      if number = $
      {
         return;
      }

      piHits = number;

      return;
   }

   NewOwner(what = $)
   {
      local lData;

      % If the person who is supposed to pick up an item picks up 
      %  the item, then remove the corpsepointer.
          
      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {  
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }      

      if poOwner <> $ AND Send(self,@HasAttribute,#ItemAtt=IA_BONDED)
      {
         lData = Send(self,@GetAttributeData,#ItemAtt=IA_BONDED);
         Send(Send(SYS,@FindSpellByNum,#num=SID_BOND),@BondedItemReport,
              #BondedItem=self,#BondedPlayer=Nth(lData,2),
              #BondedItemOwner=what);
      }      

      if what <> $ 
         AND (IsClass(what,&User)) 
         AND (Send(self,@IsCursed)) 
         AND (NOT Send(what,@PlayerIsImmortal))
      {
         Send(what,@MsgSendUser,#message_rsc=item_try_use_cursed_rsc);
         Post(what,@TryUseItem,#what=self);
      }

      propagate;
   }

   ReqUseSomething(what = $)
   {
      return TRUE;
   }

   NewUsed()
   {
      Send(self,@DoPlayerArt);
      If IsClass(poOwner,&Player)
      {
         Post(poOwner,@RefreshPlayerVisualGear);
      }

      return;
   }

   UserLogoff()
   "Called when we're used by someone, and they logoff."
   {
      return;
   }

   UserLogon()
   "Called when we're used by someone, and they logon."
   {
      return;
   }

   ReqUse()
   "Called when the player tries to use the item"
   {
      local i, oItemAtt, iNum;
          
      %% check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   ReqUnuse()
   "Called when the player tries to unuse the item"
   {
      local i, oItemAtt, iNum;
          
      % Check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqUnuse,#oItem=self,#oPlayer=poOwner)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }

   NewUnused()
   {
      Send(self,@UndoPlayerArt);

      return;
   }

   ReqNewOwner(what=$)
   {      
      return ((poOwner = $) OR Send(poOwner,@ReqLeaveHold,#what=self));
   }

   ReqLeaveOwner()
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemReqLeaveOwner,#oItem=self)
         {
            return FALSE;
         }
      }
      
      propagate;
   }

   ReqNewOwnerAttributes(who=$,type = 0)
   "This checks to see if there is anything that prevents a player from "
   "picking up an item due to that item's attributes alone.  Note: these "
   "attributes are responsible for providing error code."
   {
      local i, oItemAtt, iNum;

      % Type 0 is get
      % Type 1 is offer

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@CanGetAffectedItem,#who=who,#lData=i,
                     #oItem=self,#type=type)
         {
            return FALSE;
         }         
      }
      
      return TRUE;
   }
   
   SendAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viGround_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendLookAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }

      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryAnimation()
   {
      if (piItem_flags & ITEM_PALETTE_MASK) <> 0
      {
         AddPacket(1,ANIMATE_TRANSLATION, 1,piItem_flags&ITEM_PALETTE_MASK);
      }
      
      if piHits > 0 OR viBroken_group = $
      {
         AddPacket(1,ANIMATE_NONE, 2,viInventory_group);
      }
      else
      {
         AddPacket(1,ANIMATE_NONE, 2,viBroken_group);
      }
      
      return;
   }

   SendInventoryOverlays()
   {
      AddPacket(1, 0);
      
      return;
   }

   SendOverlayInformation()
   {
      AddPacket(4,Send(self,@GetOverlay));
      AddPacket(1,Send(self,@GetOverlayHotspot));
      Send(self,@SendOverlayAnimation);
      
      return;
   }

   GetNumberOverlays()
   {
      % Most overlay items only offer one overlay.
      %  Some items like weapons and bows may offer two.
      return 1;
   }

   IsCursed()
   "This returns TRUE if a RemoveCurse spell should unuse the item."
   "Since an ItemAtt can curse an item, go through those to check."
   {
      local i, oItemAtt, iNum;
                
      % Check to be sure nothing in ItemAtts disallows this
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if Send(oItemAtt,@ItemIsCursed,#oItem=self)
         {
            return TRUE;
         }
      }

      return FALSE;
   }

   ModifyDefensePower(defense_power = 0)
   "Gives the defensive bonus"
   {
      return defense_power;            
   }

   DefendingHit(who = $,what = $)
   {
      % Set to 75% currently
      if random(1,100) < ARMOR_TAKE_DAMAGE_PCT   
      {
         piHits = piHits - 1;
      }
      
      if piHits <= 0
      {
         Send(self,@ItemBrokenInBattle);
      }
      
      return;
   }

   ItemBrokenInBattle()
   {
      local i, oItemAtt, iNum;

      % Remove itematts from us, since we're not gonna use 'em anymore.
      % This also lets cursed items finally remove themselves from us.
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }
   
      Send(poOwner,@SomethingChanged,#what=self);        
      Send(poOwner,@MsgSendUser,#message_rsc=vrItem_broken,
           #parm1=Send(self,@GetName));
      Send(poOwner,@TryUnuseItem,#what=self);
      
      return;
   }

   AdjustsMaxHealth()
   {
      return FALSE;
   }

   AdjustsMaxMana()
   {
      return FALSE;
   }

   IsItemType(type = ITEMTYPE_MISC)
   {
      % Check for misc items (type 0)
      if type = viItem_type            
      {
         return TRUE;
      }               

      return (viItem_type & type);
   }

   DoShatter()
   "Shatters the item.  Include any special functions here."
   {
      Send(self,@Delete);

      return;
   }
   
   Delete()
   {
      Send(self,@ClearAllItemAttributes);
      
      propagate;
   }

   ObjectCorpseFading(corpse=$)
   {
      local lData;
          
      if NOT Send(self,@HasAttribute,#ItemAtt=IA_CORPSEPOINTER)
      {
         return;
      }
          
      lData = Send(self,@GetAttributeData,#ItemAtt=IA_CORPSEPOINTER);

      if lData = $
      {
         return;
      }

      if Nth(lData,3) = corpse
      {
         Send(self,@RemoveAttribute,#ItemAtt=IA_CORPSEPOINTER);
      }
      
      return;
   }

   GetPaletteTranslation()
   {
      return piItem_flags & ITEM_PALETTE_MASK;
   }

   SetPaletteTranslation(translation = $)
   {
      piItem_flags = (piItem_flags & ~ITEM_PALETTE_MASK) | translation;
      
      return;
   }

   CanIdentify()
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanIdentify,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }
   
   CanShatter()
   "Called by the shatter spell.  If this is false, the spell fails."
   { 
      local i, oItemAtt, iNum;
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");

            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanShatter,#oItem=self)
         {
            return FALSE;
         }
      }

      return TRUE;  
   }

   CanSwap()
   "Called by the swap spell.  If this is false, the spell fails."
   {  
      local i, oItemAtt, iNum;
      
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                         
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!"); continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanSwap,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanWeaken()
   "Called by the Brittle spell, among other thing."
   {  
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");
            
            continue;
         }
         
         if NOT Send(oItemAtt,@ItemCanWeaken,#oItem=self)
         {
            return FALSE;
         }
      }
      
      return TRUE; 
   }

   CanMend()
   "Called by the Mend spell.  If this returns false, the spell fails."
   "Most things are not mendable."
   {  
      return FALSE; 
   }

   CanEnchant(oSpell = $)
   "Can a particular spell enchantment target this item.  Note that for "
   "artifice and shroud, this is true, but for curse and the three "
   "enchantments, this is false."
   {
      local i, oItemAtt, iSpell, iNum;

      iSpell = Send(oSpell,@GetSpellNum);
      if iSpell = SID_HOLY_WEAPON
         OR iSpell = SID_UNHOLY_WEAPON
         OR iSpell = SID_ENCHANT_WEAPON
         OR iSpell = SID_CURSE_WEAPON
      {
         return FALSE;
      }

      if iSpell = SID_SHROUD
      AND (IsClass(self,&Weapon)
         OR IsClass(self,&DefenseModifier))
      {
         foreach i in plItem_Attributes
         {
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
                            
            if oItemAtt = $
            {
               Debug("Illegal ItemAtt in list!");
               
               continue;
            }
            
            if NOT Send(oItemAtt,@ItemCanEnchant,#oItem=self)
            {
               return FALSE;
            }
         }

         return TRUE;
      }

      return FALSE;
   }

   DropOnDeath()
   "Most items are dropped on death.  But, assassin's blades and a few other "
   "things are not."
   {
      local i, oItemAtt, iNum;
      
      % Check ItemAtts to be sure nothing funky is there
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if NOT Send(oItemAtt,@ItemDropOnDeath)
         {
            return FALSE;
         }
      }

      return TRUE;
   }

   CanBeGivenToNPC()
   "For most things this is TRUE.  However, objects like black daggers cannot "
   "be given to NPCs for any reason."
   {
      local i;
      
      foreach i in plItem_Attributes
      {
         % KLUDGE: We specifically prevent made items from being given to NPCs.
         %  Should be more general.
         if Send(self,@GetNumFromCompound,#compound=First(i)) = IA_MADE
         {
            return FALSE;
         }
      }
      
      return TRUE;
   }   

   CanBeStoredInVault()
   "Black daggers and tokens, especially, cannot be stored in vaults."
   {
      return TRUE;
   }

   ReqDMDelete()
   "Will this item be deleted by a DM Clear Inventory command?"
   {
      return TRUE;
   }

   % An item can format a text effect for players in the room to see,
   %  whether held by a player or not.  If range is specified,
   %  only players within that range will see the effect.
   % Also, one player can be specified (in except) to treat that player
   %  separately.
   RoomMessage(range = $, except = $, except_rsc = $, message_rsc = $,
               parm1 = $, parm2 = $, parm3 = $, parm4 = $,
               parm5 = $, parm6 = $, parm7 = $, parm8 = $)
   {
      local oRoom, oSource, i, range_squared, oPlayer;

      if range <> $
      {
         range_squared = range * range;
      }

      oSource = self;
      oRoom = poOwner;
      if oRoom = $
      {
         return FALSE;
      }
      
      if isClass(oRoom,&Player)
      {
         oSource = poOwner;
         oRoom = Send(oRoom, @GetOwner);
      }
      
      if oRoom = $ OR NOT isClass(oRoom,&Room)
      {
         return FALSE;
      }

      foreach i in Send(oRoom,@GetHolderActive)
      {
         oPlayer = Send(oRoom,@HolderExtractObject,#data=i);
         if NOT IsClass(oPlayer,&Player)
         {
            continue;
         }

         if range <> $
            AND Send(oPlayer,@SquaredDistanceTo,#what=oSource) >= range_squared
         {
            continue;
         }

         if oPlayer = except
         {
            if except_rsc = $
            {
               continue;
            }

            % message comes from except_rsc, with parm1 missing.
            Send(oPlayer,@MsgSendUser,#message_rsc=except_rsc,
                 #parm1=parm3,#parm2=parm4,#parm3=parm5,#parm4=parm6,
                 #parm5=parm7,#parm6=parm8);
         }
         else
         {
            Send(oPlayer,@MsgSendUser,#message_rsc=message_rsc,
                 #parm1=parm1,#parm2=parm2,#parm3=parm3,#parm4=parm4,
                 #parm5=parm5,#parm6=parm6,#parm7=parm7,#parm8=parm8);
         }
      }

      return;
   }

   %  Item Attributes, added 4 March 97 by Damion Schubert
   % 
   %  ItemAtts are any special attributes that an item might have.  
   %  Examples include training weapons, poisoned weapons and 
   %  enchanted weapons.  These have been generalized so the same 
   %  ItemAtt may be applied to any item.
   %
   %  The ItemAtt Struct (plItem_attributes) is as follows
   %
   %    plItem_attributes = \
   %       [ [WA_const_name, timer, primary_state, secondary_state],
   %         [WA_const_name2, timer, primary_state, secondary_state],
   %         etc.
   %       ]
   %
   %  WA_const_name : a unique constant name as found in blakston.khd
   %  timer : a timer, most often counting down to the enchantment's
   %    extinction.  However, since Item enchantments may last for days, 
   %    the timer may just count down hours, with an additional (usually 
   %    secondary) state value counting days.  If this timer doesn't exist,
   %    the ItemAtt is permanent.
   %  states : any value that the ItemAtt needs to know.  For example, the
   %    strength of attributes such as the strength of poison or the damage
   %    bonus might be stored. Individual ItemAtt code should be examined to
   %    see what this is.
   %
   %  Note, there are thousands of items in a live server.  As a
   %    result, I've taken actions to ensure that as few list nodes are used as
   %    possible for each ItemAtt, so rather than store blank fields which are 
   %    never used, I make it easy for the individual ItemAtts to decide to 
   %    store what information they deem necessary. 
   %    I check to see if those fields exist when using them, allowing me to
   %    collapse the ItemAtt struct as much as possible.  For example, a 
   %    training attribute struct only has one argument, the ItemAtt ID:
   %
   %    plItem_Attributes = [[WA_TRAINING]];
   %
   %  By comparison, you may have a fiery sword, which is only fiery
   %    for a short time (as determined by a timer).  That list looks
   %    like:
   %
   %    plItem_Attributes = [[WA_ATCKTYPE, DurationTimer, ATCK_FIRE]];
   %
   %  This 'telescoping' saves memory.

   %%% Item Attribute Functions
   
   HasAttribute(ItemAtt = $)
   {
      local i;

      foreach i in plItem_attributes
      { 
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt  
         {
            return TRUE;
         }  
      }
      
      return FALSE;
   }

   HasAnyAttribute()
   {
      if plItem_attributes = $
      {
         return FALSE;
      }

      return TRUE;
   }

   GetAttributeData(ItemAtt = $, index = 1)
   {
      local i, n;

      n = 0;
      foreach i in plItem_attributes
      { 
         if Send(self,@GetNumFromCompound,#compound=First(i)) = ItemAtt
         {
            n = n + 1;
            if n = index
            {
               return i;
            }
         }  
      }
      
      return $;
   }   

   GetNumFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      return compound / 100;
   }

   GetIDStatusFromCompound(compound = $)
   {
      if compound = $
      {
         return $;
      }

      % If compound is odd, it is IDed. If even, it is not.

      if (compound mod 2) = 1
      {
         return TRUE;
      }

      return FALSE;
   }

   RevealHiddenAttributes()
   {
      local i, bDone;

      bDone = FALSE;
      foreach i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            setNth(i,1,(First(i)+1));
            bDone = TRUE;
         }
      }
      
      return bDone;
   }

   AddAttributeSpecifics(litemAtt=$)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      if lItemAtt = $ 
      {
         Debug("lItemAtt = $!  Most likely, lItemAtt called directly instead "
               "of from itematt.kod");
      }

      plItem_attributes = Cons(lItemAtt,plItem_attributes);

      return;
   }

   RemoveItemAttIfPresent(iNum=0)
   "Attempts to removes a specific item attribute if present.  Used to "
   "remove an attribute from all items without generating debug messages "
   "if the item does not have that attribute."
   {
      local oItemAtt;

      if iNum = 0
      {
         return;
      }

      oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);

      if oItemAtt = $
      {
         return;
      }

      if Send(self,@HasAttribute,#ItemAtt=iNum)
      {
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }

      return;
   }

   RemoveAttribute(ItemAtt=$)
   "All this does is calls the itematt.kod version of the same thing. "
   "This function is largely unnecessary, and is here only for convenience."
   {
      local oItemAtt;
      
      if ItemAtt = $
      {
         return;
      }
 
      oItemAtt = Send(SYS,@FindItemAttByNum,#num=ItemAtt);
      
      if oItemAtt = $
      {
         Debug("Illegal data sent to RemoveAttribute");

         return;
      }

      Send(oitemAtt,@RemoveFromItem,#oItem=self);
      
      return;
   }

   RemoveAttributeSpecifics(oItemAtt=$, ItemAtt = 0, index = 1)
   "Don't call this directly!  Call this from itematt.kod!"
   {
      local lData;

      if oItemAtt = $ OR ItemAtt = 0
      {
         Debug("Illegal data sent to RemoveAttributeSpecific");
         
         return;
      }

      lData = Send(self,@GetAttributeData,#ItemAtt=ItemAtt,#index=index);
      if lData = $
      {
         Debug("Can't remove a node that isn't there!"); return;
      }

      % First kill the timer if it has one
      if Send(oItemAtt,@HasTimer,#lData=lData)
      {
            if Nth(lData,2) <> $
      	    {
	             DeleteTimer(Nth(lData,2));
		     SetNth(lData,2,$);
	    }
      }
      % now free the nodes
      plItem_Attributes = DelListElem(plItem_Attributes,lData);
      
      return;
   }

   AttributeTimer(timer=$)
   {
      local i, oItemAtt, iNum;

      if timer = $
      {
         Debug("Timer = $!");
         return;
      }

      foreach i in plItem_Attributes
      {
         if Length(i) >= 2 AND Nth(i,2) = timer
         {  
            % This is the timer that just expired.
            SetNth(i,2,$); % clear it in the data structure first
            iNum = Send(self,@GetNumFromCompound,#compound=First(i));
            oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
            Send(oItemAtt,@TimerExpired,#oItem=self,#lData=i);
            
            return;
         }
      }
      
      Debug("AttributeTimer didn't find enchantment to get rid of!");
      
      return;
   }

   ClearAllItemAttributes()
   "Most likely called if the Item is deleted."   
   {
      local i, oItemAtt, iNum;

      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         if oItemAtt = $
         {
            Debug("Illegal ItemAtt in list!");
            
            continue;
         }
         
         Send(oItemAtt,@RemoveFromItem,#oItem=self);
      }
          
      % All items should have cleared fine.  If not, something went wrong.
      if plItem_Attributes <> $
      {
         Debug("Clearing all Item Attributes failed!");
         plItem_Attributes = $;
      }
          
      return;
   }

   BuildDescName()
   {
      local i, iHigh_index, oHigh_obj, oItemAtt, iPriority, iNum;
      
      if plItem_Attributes = $
      {
         propagate;
      }
      
      iHigh_index = 0;  oHigh_obj = $;
      foreach i in plItem_Attributes
      {
         if NOT Send(self,@GetIDStatusFromCompound,#compound=First(i))
         {
            % If not identified, keep on marching.
            continue;
         }   

         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         
         iPriority = Send(oItemAtt,@GetNamePriority);
         if iPriority > iHigh_index
         
         {
            iHigh_index = iPriority;
            oHigh_obj = oItemAtt;
         }
      }

      if oHigh_obj = $
      {
         propagate;
      }

      Send(oHigh_obj,@ItemBuildDescName,#oItem=self);      

      return;
   }

   SetTimer(timer_duration=$)
   {
      local tTimer;
      
      if timer_duration = $
      {
         return $;
      }

      tTimer = CreateTimer(self,@AttributeTimer,timer_duration);

      return tTimer;
   }

   GetBaseSpellModifier(oSpell=$)
   {
      % Doing it this way, we can have different items give different bonuses
      %  in different situations, while still giving itematt bonuses.
      return viSpell_modifier;
   }

   GetSpellModifier(oSpell=$)
   {
      local oItemAtt, iModifier, i, iNum, oObjectAttribute;

      iModifier = Send(self,@GetBaseSpellModifier,#oSpell=oSpell);
      foreach i in plItem_Attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         iModifier = iModifier + Send(oItemAtt,@ItemGetSpellModifier,
                                      #oSpell=oSpell,#oCaster=poOwner);
      }

      foreach oObjectAttribute in plObject_attributes
      {
         iModifier = Send(oObjectAttribute,@ModifySpellPower,
                           #iModifier=iModifier,#oSpell=oSpell,
                           #oCaster=poOwner);
      }

      return iModifier;
   }

   GetHeatDamage()
   "Only things worn at the armor position will be asked this, but "
   "just in case, default is 0."
   {
      return 0;
   }

   GetShirtIcon(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrIcon_male;
      }
      
      return vrIcon_female;
   }

   GetLeftArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         foreach i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideLeftArm,#who=who);
            }
         }
      }
      
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLeftarm_male;
      }
      
      return vrLeftarm_female;
   }

   OverrideArmsForGauntlets()
   {
      return FALSE;
   }
   
   OverrideArms()
   {
      return FALSE;
   }
   
   GetOverrideRightArm()
   {
      return $;
   }
   
   GetOverrideLeftArm()
   {
      return $;
   }

   GetRightArm(who=$)
   {
      local i;

      if Send(self,@OverrideArmsForGauntlets)
      {
         foreach i in Send(who,@GetPlayerUsing)
         {
            if Send(i,@OverRideArms)
            {
               return Send(i,@GetOverrideRightArm,#who=who);
            }
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrRightarm_male;
      }
      
      return vrRightarm_female;
   }   

   GetNakedLeftArm(who=$)
   {
      local i;

      foreach i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideLeftArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return nakedleftarm_male;
      }

      return nakedleftarm_female;
   }

   GetNakedRightArm(who=$)
   {
      local i;

      foreach i in Send(who,@GetPlayerUsing)
      {
         if Send(i,@OverRideArms)
         {
            return Send(i,@GetOverrideRightArm,#who=who);
         }
      }

      if Send(who,@GetGender) = GENDER_MALE
      {
         return NakedRightarm_male;
      }

      return NakedRightarm_female;
   }   

   GetLegs(who=$)
   {
      if Send(who,@GetGender) = GENDER_MALE
      {
         return vrLegs_male;
      }
      
      return vrLegs_female;
   }   

   HasSkinTones()
   {
      return FALSE;
   }

   ShowShirt()
   {
      return FALSE;
   }

   ResetSkinColor()
   {
      local iSkin_color, iColor, iXlat;
      
      if not Send(self,@HasSkinTones)
      {
         return;
      }

      iSkin_Color = Send(SYS,@DecodeSecondaryColor,
                         #xlat=Send(self,@GetPaletteTranslation));
      if iSkin_Color <> Send(poOwner,@GetSkinColor)
      {
         iSkin_Color = Send(poOwner,@GetSkinColor);
         iSkin_color = Send(poOwner,@ConvertSkinColorToXLAT,
                            #skin_color=iSkin_color);
         iColor = Send(SYS,@DecodePrimaryColor,
                       #xlat=Send(self,@GetPaletteTranslation));
      
         iXlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iColor,
                      #Color2=iSkin_color);
         Send(self,@SetPaletteTranslation,#translation=iXlat);
      }

      return;
   }

   ResetXLATsToShirt()
   {
      local iSkin_color, iColor, iXlat, iShirt_XLAT;
      
      if not Send(self,@ShowShirt)  { return; }
      iShirt_XLAT = Send(poOwner,@GetCurrentShirtColor);

      if (iShirt_XLAT <> Send(self,@GetPaletteTranslation))
      {
         Send(self,@SetPaletteTranslation,#translation=iShirt_Xlat);
      }
      
      return;
   }

   UndoPlayerArt()
   {
      local oRoom, oShirt;

      if (poOwner <> $)
      {
         if vrIcon_male <> $
         {
            Send(poOwner,@ResetPlayerIcon,#alldone=FALSE);
         }
         
         if vrLeftArm_male <> $
         {
            Send(poOwner,@ResetPlayerArms,#alldone=FALSE);
         }
         
         if  vrLegs_male <> $
         {
            Send(poOwner,@ResetPlayerLegs,#alldone=FALSE);
         }
         
         Post(poOwner,@RefreshPlayerVisualGear);
         
         oRoom = Send(poOwner,@GetOwner);
         if oRoom <> $
         {         
            Post(oRoom,@SomethingChanged,#what=poOwner);
         }
      }
      
      return;
   }

   DoPlayerArt()
   {
      local oRoom;

      % make the player's hands match his sleeves.            
      Send(self,@ResetSkinColor);   

      if Send(self,@ShowShirt)
      {
         Send(self,@ResetXLATsToShirt);
      }

      if vrLeftArm_male <> $
      {
         Send(self,@SetArms,#alldone=FALSE);
      }

      if vrIcon_male <> $
      {
         Send(self,@SetIcon,#alldone=FALSE);
      }

      if  vrLegs_male <> $
      {
         Send(self,@SetLegs,#alldone=FALSE);
      }
      
      oRoom = Send(poOwner,@GetOwner);
      if oRoom <> $
      {         
         Send(oRoom,@SomethingChanged,#what=poOwner);
      }
      
      return;
   }
   
   ItemChangesArms()
   {
      if vrLeftArm_male <> $
      {
         return TRUE;
      }
       
      return FALSE;
   }

   SetNakedArms()
   {
      local iSkin_xlat;
      
      iSkin_Xlat = Send(poOwner,@GetSkinColor);      
      iSkin_Xlat = Send(poOwner,@ConvertSkinColorToXLAT,
                        #skin_color=iSkin_Xlat);
      iSkin_Xlat = Send(SYS,@EncodeTwoColorXLAT,#color1=iSkin_XLAT,
                        #color2=iSkin_XLAT);      
      Send(poOwner,@SetPlayerArms,#what=self,
           #new_left_arm=Send(self,@GetNakedLeftArm,#who=poOwner),
           #new_right_arm=Send(self,@GetNakedRightArm,#who=poOwner),
           #translation=iSkin_Xlat,#alldone=FALSE);
           
      return;
   }

   SetArms()
   {
      Send(poOwner,@SetPlayerArms,#what=self,
           #new_left_arm=Send(self,@GetLeftArm,#who=poOwner),
           #new_right_arm=Send(self,@GetRightArm,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   SetIcon()
   {
      Send(poOwner,@SetPlayerIcon,#what=self,
           #new_icon=Send(self,@GetShirtIcon,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   SetLegs()
   {
      Send(poOwner,@SetPlayerLegs,#what=self,
           #new_legs=Send(self,@GetLegs,#who=poOwner),
           #translation=Send(self,@GetPaletteTranslation),#alldone=FALSE);
           
      return;
   }

   IsPlural()
   {
      return FALSE;
   }

   GetUnrevealedColor()
   "Returns the item's color before being revealed."
   {
      return viUnrevealedColor;
   }
   
   GetRevealedColor()
   "Returns the item's mystery revealed color."
   {
      return viRevealedColor;
   }
   
   RevealHiddenColor()
   "Shows the item's true color."
   {
      if viRevealedColor <> 0
         AND viUnrevealedColor <> 0
         AND Send(self,@GetPaletteTranslation) = (viUnrevealedColor & ITEM_PALETTE_MASK)
      {
         Send(self,@SetPaletteTranslation,#translation=viRevealedColor);
         return TRUE;
      }
      return FALSE;
   }
  
   GetCurrentResistances()
   {
      local lCurrentResistances, oObjectAttribute;
      
      lCurrentResistances = Send(self,@GetResistanceModifiers);
      
      foreach oObjectAttribute in plObject_attributes
      {
         lCurrentResistances = Send(oObjectAttribute,@ModifyResistance,#resistance_list=lCurrentResistances);
      }
      
      return lCurrentResistances;
   }

   ModifyResistance(resistance_list=$)
   {
      local oResist, lCurrentResistances;
      
      lCurrentResistances = Send(self,@GetCurrentResistances);
      
      foreach oResist in lCurrentResistances
      {
         resistance_list = Send(SYS,@AddResistance,#what=Nth(oResist,1),#value=Nth(oResist,2),#resistance_list=resistance_list);
      }
      
      return resistance_list;
   }

   AddRadiusEnchantment(what=$,iPower=0,source=$)
   {
      local i;
      
      foreach i in plRadiusEnchantments
      {
         if Nth(i,1) = what
            AND Nth(i,2) = iPower
            AND Nth(i,3) = source
         {
            return;
         }
      }

      plRadiusEnchantments = Cons([what,iPower,source],plRadiusEnchantments);
      
      If IsClass(self,&User)
      {
         Send(self,@ShowAddEnchantment,#what=what,#type=2);
         
         If source = self
         {
            Send(self,@ShowAddEnchantment,#what=what,#type=1);
         }
      }
      
      return;
   }

   RemoveRadiusEnchantment(what=$,iPower=0,source=$)
   {
      local i, bFound;

      bFound = FALSE ;
      foreach i in plRadiusEnchantments
      {
         if Nth(i,1) = what
            AND Nth(i,2) = iPower
            AND Nth(i,3) = source
         {
            If IsClass(self,&User)
            {
               Send(self,@ShowRemoveEnchantment,#what=Nth(i,1),#type=2);

               If source = self
               {
                  Send(self,@ShowRemoveEnchantment,#what=Nth(i,1),#type=1);
               }
            }
         
            plRadiusEnchantments = DelListElem(plRadiusEnchantments,i);
            bFound = TRUE;
         }
      }

      if NOT bFound
      {
         Debug(self,"Tried to remove radius enchantment ",what," but not in list",
               plRadiusEnchantments);
      }

      return;
   }
   
   IsAffectedByRadiusEnchantment(what=$,caster=$,byClass=&RadiusEnchantment)
   "Returns whether or not currently enchanted by <what> radius enchantment."
   {
      local i;
      
      if plRadiusEnchantments = $
      {
         return FALSE;
      }

      if what = $
      {
         foreach i in plRadiusEnchantments
         {
            if IsClass(Nth(i,1),byClass)
            {
               if caster = $
               {
                  return TRUE;
               }
               else
               {
                  if Nth(i,3) = caster
                  {
                     return TRUE;
                  }
               }
            }
         }
      }
      else
      {
         foreach i in plRadiusEnchantments
         {
            if Nth(i,1) = what
            {
               if caster = $
               {
                  return TRUE;
               }
               else
               {
                  if Nth(i,3) = caster
                  {
                     return TRUE;
                  }
               }
            }
         }      
      }
      
      return FALSE;
   }
   
   GetMostPowerfulRadiusEnchantmentState(byClass=&RadiusEnchantment)
   {
      local i, oHighest;
   
      oHighest = $;
   
      foreach i in plRadiusEnchantments
      {
         if IsClass(Nth(i,1), byClass)
         {
            if oHighest = $
            {
               oHighest = i;
            }
            else
            {
               if Nth(i,2) > Nth(oHighest,2)
               {
                  oHighest = i;
               }
            }
         }
      }
      return oHighest;
   }
   
   GetRadiusEnchantments()
   {
      return plRadiusEnchantments;
   }
   
   IsInSameRoom(what = $)
   {
      if Send(self,@GetOwner) <> $
         AND IsClass(Send(self,@GetOwner),&Room)
         AND Send(what,@GetOwner) <> $
         AND IsClass(Send(what,@GetOwner),&Room)
         AND Send(self,@GetOwner) = Send(what,@GetOwner)
      {
         return 1;
      }
         
      return 0;
   }

   SquaredDistanceTo(what = $)
   "Computes squared distance to <what>. Returns $ for any object that is not within a room."
   {
      local iRow, iCol;
      
      If NOT Send(self,@IsInSameRoom,#what=what)
      {
         return $;
      }

      iRow = Send(what,@GetRow);
      iCol = Send(what,@GetCol);

      % Sanity checking
      if iRow = $ OR iCol = $ OR Send(self,@GetRow) = $ OR Send(self,@GetCol) = $
      {
         return $;
      }

      return send(self,@SquaredDistanceToLocation,#row=iRow,#col=iCol);
   }

   SquaredDistanceToLocation(row = $, col = $)
   "Computes squared distance to (row,col)"
   {
      local iRow_diff, iCol_diff;

      iRow_diff = Send(self,@GetRow) - row;
      iCol_diff = Send(self,@GetCol) - col;

      return  (iRow_diff * iRow_diff + iCol_diff * iCol_diff);
   }

   AddMagicFlag()
   {
      if viObject_flags <> (OF_GETTABLE | OF_ITEM_MAGIC)
      {
         viObject_flags = viObject_flags | OF_ITEM_MAGIC;
      }

      if poOwner <> $
         AND IsClass(poOwner,&Player)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   RemoveMagicFlag()
   {
      local i, iNum, oItemAtt;
      
      foreach i in plItem_attributes
      {
         iNum = Send(self,@GetNumFromCompound,#compound=First(i));
         oItemAtt = Send(SYS,@FindItemAttByNum,#num=iNum);
         
         if Send(oItemAtt,@IsMagicalEffect)
         {
            viObject_flags = viObject_flags | OF_ITEM_MAGIC;
            
            if poOwner <> $
               AND IsClass(poOwner,&Player)
            {
               Send(poOwner,@SomethingChanged,#what=self);
            }

            return;
         }
      }

      viObject_flags = viObject_flags & ~OF_ITEM_MAGIC;

      if poOwner <> $
         AND IsClass(poOwner,&Player)
      {
         Send(poOwner,@SomethingChanged,#what=self);
      }

      return;
   }

   CanSweep()
   {
      return TRUE;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
