% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Elusion is Spell

constants:

   include blakston.khd

   TRANCE_TIME = 30000
   
   NODE_RANGE = 5

resources:

   Elusion_name_rsc = "elusion"
   Elusion_icon_rsc = ielusion.bgf
   Elusion_desc_rsc = \
      "Allows the caster to elude trouble and escape off to another location.  "
      "Using the magical bond between you and your mana nodes, this allows the user to transport to the exact spot to which the mana node was found. "
	  "The caster must call out the name of the location he wishes to travel to. "
      "Requires the claws of the fearsome kriipa to cast."

   Elusion_No_Location_Given = "With no location specified your elusion attempt fails."
   Elusion_Success = "The world folds in on itself."
   Elusion_Location_list = "The world shimmers and secret paths are revealed, leading to %q."
   Elusion_fail = "That is not a valid destination."
   Elusion_cant_cast_here = \
       "You may only elude from a place you can elude to."

   Elusion_and = "and "

   % Yeah, it's Illusionary wounds sound, but it fits.  Plus, Ill. Wounds wasn't using it anymore.
   Elusion_sound = riluswnd.wav
   
   Elusion_no_node = "You may only elude using the power of a nearby mana node."
   
   Elusion_no_bonds = "You don't have any bonded nodes to travel to."

classvars:

   vrName = Elusion_name_rsc
   vrIcon = Elusion_icon_rsc
   vrDesc = Elusion_desc_rsc

   viSpell_num = SID_ELUSION
   viSchool = SS_RIIJA
   viSpell_level = 6
   viMana = 20
   viSpellExertion = 50

   viChance_To_Increase = 10

   vrSucceed_wav = Elusion_sound
   viFlash = FLASH_GOOD

properties:


messages:

   ResetReagents()
   {
      plReagents = $;
      plReagents = Cons([&KriipaClaw,2],plReagents);

      return;
   }

   CanPayCosts(who = $, lTargets = $, bItemCast = FALSE)
   {
      local oRoom, oNode, iNodeList, iRoomNum;

      % Can't cast just after attacking someone
      if Send(who, @GetLastPlayerAttackTime) + 
         Send(Send(SYS, @GetSettings), @TeleportAttackDelaySec) >
         GetTime()
      {
         Send(who, @MsgSendUser, #message_rsc = spell_too_soon_since_attacking);
         return FALSE;
      }

	  % look for a nearby mana node
	  oRoom = send(who,@GetOwner);
	  oNode = Send(oRoom,@FindHolding,#class=&ManaNode);
	  
	  if oNode = $ OR
		 Send(who,@SquaredDistanceTo,#what=oNode) > (NODE_RANGE * NODE_RANGE)
	  {
         Send(who, @MsgSendUser, #message_rsc = Elusion_no_node);
         return FALSE;
	  }
	  
	  if Send(who,@GetNodeList) = 0
	  {
         Send(who, @MsgSendUser, #message_rsc = Elusion_no_bonds);
         return FALSE;
	  }
      
      propagate;
   }

   GetTranceTime(iSpellpower=0,who=$)
   {
      % Since this spell uses the trance, don't scale it down depending on iSpellpower
      return viCast_time;
   }

   BeginCastingTrance(who=$,lTargets=$,iSpellpower=$)
   {
      local oTrance, lLocations, sLocations;

      %%Get rid of the regular casting trance, we need a special one put on below.
      send(who,@BreakTrance,#event=EVENT_STEER);  

      oTrance = send(SYS,@FindSpellByNum,#num=SID_TRANCE);

      lLocations = send(self,@GetLocations,#iSpellpower=iSpellpower,#target=who);
      
      sLocations = send(self,@GetLocationsString,#lLocations=lLocations);
      send(who,@MsgSendUser,#message_rsc=Elusion_location_list,#parm1=sLocations);

      % lTargets is of the form = [location1, location2,...]
      send(oTrance,@BeginCastingTrance,#what=self,#who=who,#lTargets=lLocations,#time=TRANCE_TIME);

      propagate;
   }

   SomethingSaidDuringTrance(who=$,string=$,lTargets = $)
   {
      local lAllTargets, oGuildHall, sRoomName, bFound, oRoom;

      % Check if string is a location.  If it is, and the caster has sufficent spellpower make 
      %   it the target.  Get percent in the target spell.  If not there or fail check bail and print failure.

      send(who,@BreakTrance,#event=EVENT_STEER);  %% don't print fizzle message

      bFound = FALSE;

      lAllTargets = lTargets;

      % Special bonus!  Warp to guild hall with high enough spellpower.
      %  Spellpower has to be high enough that you were already going to 6
      %  or more places.
      if length(lTargets) >= 6
      {
         oGuildHall = Send(who, @GetGuildHall);

         if oGuildHall <> $
         {
            lAllTargets = cons(oGuildHall,lAllTargets);
         }
      }

      for oRoom in lAllTargets
      {
         sRoomName = send(oRoom,@GetName);
         if StringContain(string,sRoomName)
         {
            bFound = TRUE;
            post(oRoom,@Teleport,#what=who);
            
            break;
         }
      }

      if bFound
      { 
         send(who,@MsgSendUser,#message_rsc=Elusion_success); 
      }
      else
      {
         send(who,@MsgSendUser,#message_rsc=Elusion_fail);
      }

      return;
   } 

   GetLocations(iSpellpower=$,target=$)
   {
      local i, iNodeList, oNode, oNodeRoom, lLocations;
	  
	  lLocations = $;
	  
	  iNodeList = send(target,@GetNodeList);
	  
      i = 1;

      while i <= NODE_MAX_VALUE
      {
         if iNodeList & i
         {
            oNode = Send(SYS,@FindNodeByNum,#num=i);
			
			% Following are nodes we do not want users to teleport to
			if i = NODE_Q OR
			   i = NODE_CORPSENODE OR
			   i = NODE_GUEST
			{
			   break;
			}
			
			oNodeRoom = Send(oNode,@GetOwner);
			
			if oNodeRoom <> $ 
			{
			   lLocations = cons(Send(SYS,@FindRoomByNum,#num=Send(oNodeRoom,@GetRoomNum)),lLocations);
			}
         }
         
         i = 2 * i;
      }

      return lLocations;
   }

   GetLocationsString(lLocations=$)
   {
      local i, iNumRooms, sString, iCounter;

      ClearTempString();
      iCounter = 0;

      iNumRooms = length(lLocations);

      for i in lLocations
      {
         iCounter = iCounter + 1;

         if iNumRooms > 1
         {
            if iCounter = iNumRooms
            {
               AppendTempString(Elusion_and);
               AppendTempString(send(i,@GetName));
            }
            else
            {
               AppendTempString(send(i,@GetName));
               AppendTempString("; ");
            }
         }
         else
         {
            AppendTempString(send(i,@GetName));
         }

      }    

      sString = CreateString();
      sString = GetTempString();
      
      return sString;
   }

   DoubleCheckAfterTrance(who=$,lTargets=$)
   {
      send(who,@MsgSendUser,#message_rsc=Elusion_No_Location_Given);        
             
      return;
   }

   SpellBannedInArena()
   {
      return TRUE;
   }


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
