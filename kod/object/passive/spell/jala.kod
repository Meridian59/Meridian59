% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Jala is Spell

% Jala Spells are radius spells that last as long as the player remains in a trance.
%
% Mechanically, there is a state here of the form [time elapsed, players enchanted, volume, range].
% This should not be altered. It is used to track the radius and who should be affected.
% Volume and Range have their own Calculate functions if they need to be modified.
%
% EnterSong and LeaveSong add or remove from a player's plJala_modifiers list.
% Jala modifiers are states of the form [song object, volume, singer].
% These states should be used when effects are actually being performed.
%
% Useful Jala functions to call (these are in Player.kod):
% IsAffectedByJalaModifier(what=$,byClass=&Jala) -- returns TRUE or FALSE
% GetLoudestJalaModifierState(byClass=&Jala)     -- returns [song object, volume, singer] with highest volume
% GetJalaModifiers()                             -- returns player's list of [song object, volume, singer]

constants:

   include blakston.khd
   
   SONG_CHECK_TIME = 500   %Time between checks for who is affected, no worse than an active object lag-wise

resources:

   jala_default_ends = "The song sung by a nearby bard of Jala ends."
   jala_default_starts = "A nearby bard of Jala starts to sing a song."
   jala_default_enter = "The bard's song begins to affect you."
   jala_default_leave = "The song's notes fade from your ears."
   jala_song_failed = \
      "A nearby bard of Jala begins to sing a song, but quits when they "
      "realize they can't be heard over the song sung by another."
   jala_song_playing = "A nearby bard of Jala is singing a song."
   jala_need_instrument = "You need an instrument!"
   jala_no_newbie = \
      "Your guardian angel tells you, \"You are not ready to cast spells "
      "which may hinder other players.\""
      
   jala_already_being_sung = "You are already singing a song."

   jala_default = jala1.mid

classvars:

   jala_song_already_singing = jala_already_being_sung
   
   jala_song_ends = jala_default_ends
   jala_song_starts = jala_default_starts
   jala_song_enter = jala_default_enter
   jala_song_leave = jala_default_leave

   viSchool = SS_JALA
   % viMana is amount used upon inititiation
   viMana = 5
   % viManaDrain is amount used every viDrainTime milliseconds
   viManaDrain = 3       
   viDrainTime = 5000

   prMusic = jala_default
   viChance_To_Increase = 8
   % viPostCast_time is in seconds, since it works off GetTime()
   viPostCast_time = 1

   % If harmful, don't affect people we can't hit
   viHarmful = FALSE

   % Ranges goes up to double base, based on spellpower
   viBaseRange = 5
   
   % If FALSE, affects caster only
   viAffectsOthers = TRUE
   
   % If TRUE, a harmful spell will still affect guildmates
   % Important for balance in guild war situations
   viAffectsGuildmates = FALSE

properties:

   ptDrainTimer = $
   ptDrainNow = FALSE

messages:

   ResetReagents()
   {
      return;
   }

   GetNumSpellTargets()
   {
      return 0;
   }

   CanPayCosts(who=$, lTargets=$)  
   {
      if Send(who,@GetInstrumentLevel) = 0
      { 
         Send(who,@MsgSendUser,#message_rsc=jala_need_instrument);
         return FALSE; 
      }

      propagate;
   }

   CastSpell(who=$, iSpellPower=0)
   "Initiation point for the spell."
   {
      local i, iSinging, iSongState, oObj, oUser, oCasterGuild, oRoom, iElapsed, lEnchanted, iVolume, iRange;

      iElapsed = 0;
      lEnchanted = $;
      iVolume = Send(self,@CalculateVolume,#iSpellPower=iSpellPower);
      iRange = Send(self,@CalculateRange,#iSpellPower=iSpellPower);
      
      if Send(who,@IsEnchanted,#byClass=&Jala)
      {
         iSinging = Send(who,@GetEnchantmentsByClass,#enchClass=&Jala);
         for i in iSinging
         {
            iSongState = Send(who,@GetEnchantedState,#what=Nth(i,2));
            Send(Nth(i,2),@BreakTrance,#who=who,#state=iSongState,#event=EVENT_STEER);
         }
      }

      oRoom = Send(who,@GetOwner);
      Send(oRoom,@SomeoneSaid,#type=SAY_MESSAGE,#string=jala_song_starts);
      
      oCasterGuild = Send(who,@GetGuild);

      for oObj in send(oRoom,@GetplActive)
      {
         oUser = Send(oRoom,@HolderExtractObject,#data=oObj);

         % Important note: FindListElem returns nil on a passed nil value, not zero.
         if IsClass(oUser,&User)
            AND (lEnchanted = $ OR FindListElem(lEnchanted,oUser) = 0)
            AND Send(who,@SquaredDistanceTo,#what=oUser) <= (iRange * iRange)
         {
            if NOT viHarmful
               OR oUser=who
               OR (Send(who,@CheckStatusAndSafety,#victim=oUser,#report=FALSE)
                  AND Send(Send(who,@GetOwner),@AllowGuildAttack,#what=who,#victim=oUser)
                  AND Send(who,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE))
               OR (viAffectsGuildmates
                  AND oCasterGuild <> $
                  AND oCasterGuild = Send(oUser,@GetGuild))
            {
               if viAffectsOthers
                  OR (NOT viAffectsOthers AND oUser=who)
               {
                  send(self,@EnterSong,#who=oUser,#iVolume=iVolume,#singer=who);
                  lEnchanted = cons(oUser,lEnchanted);
               }
            }
         }
      }

      % Put spell maintenance info in casters enchantment list.
      Send(who,@StartEnchantment,#what=self,#time=SONG_CHECK_TIME,
           #state=[iElapsed,lEnchanted,iVolume,iRange]);      

      % Set up mana drain
      ptDrainTimer = CreateTimer(self,@DrainTimer,viDrainTime);

      propagate;
   }

   EnterSong(who=$,iVolume=0,singer=$)
   {      
      local i,each_obj;
      
      Send(who,@AddJalaModifier,#what=self,#iVolume=iVolume,#singer=who);
      Send(who,@MsgSendUser,#message_rsc=jala_song_enter);

      return;
   }
   
   LeaveSong(who=$,iVolume=0,singer=$)
   {      
      Send(who,@RemoveJalaModifier,#what=self,#iVolume=iVolume,#singer=who);
      Send(who,@MsgSendUser,#message_rsc=jala_song_leave);
      
      return;
   }

   EndEnchantment( who = $, state = $ )
   "Called only for caster. Refreshes itself to recalculate affected players."
   {
      local iElapsed, lEnchanted, iVolume, iRange, oUser, oCasterGuild, oRoom, lActive;

      iElapsed = Nth(state,1);
      lEnchanted = Nth(state,2);
      iVolume = Nth(state,3);
      iRange = Nth(state,4);

      oRoom = Send(who,@GetOwner);
      oCasterGuild = Send(who,@GetGuild);

      % Do test.
      for oUser in lEnchanted
      {
         if Send(who,@SquaredDistanceTo,#what=oUser) > (iRange * iRange)
            OR Send(who,@GetOwner) <> Send(oUser,@GetOwner)
         {
            Send(self,@LeaveSong,#who=oUser,#iVolume=iVolume,#singer=who);
            lEnchanted = DelListElem(lEnchanted,oUser);
         }
      }
      
      for lActive in send(oRoom,@GetplActive)
      {
         oUser = Send(oRoom,@HolderExtractObject,#data=lActive);

         if IsClass(oUser,&User)
            AND (lEnchanted = $ OR FindListElem(lEnchanted,oUser) = 0)
            AND Send(who,@SquaredDistanceTo,#what=oUser) <= (iRange * iRange)
         {
            if NOT viHarmful
               OR oUser=who
               OR (Send(who,@CheckStatusAndSafety,#victim=oUser,#report=FALSE)
                  AND Send(Send(who,@GetOwner),@AllowGuildAttack,#what=who,#victim=oUser)
                  AND Send(who,@CheckPlayerFlag,#flag=PFLAG_PKILL_ENABLE))
               OR (viAffectsGuildmates
                  AND oCasterGuild <> $
                  AND oCasterGuild = Send(oUser,@GetGuild))
            {
               if viAffectsOthers
                  OR (NOT viAffectsOthers AND oUser=who)
               {
                  send(self,@EnterSong,#who=oUser,#iVolume=iVolume,#singer=who);
                  lEnchanted = cons(oUser,lEnchanted);
               }
            }
         }
      }

      Send(who,@StartEnchantment,#what=self,#time=SONG_CHECK_TIME,
          #state=[iElapsed,lEnchanted,iVolume,iRange],#Report=FALSE);
              
      if ptDrainNow = TRUE
      {
         if Send(who,@GetMana) >= viManaDrain
         {
            Send(who,@LoseMana,#amount=viManaDrain);
            ptDrainNow = FALSE;
         }
         else
         {
            Send(self,@BreakTrance,#who=who,#state=state,#event=EVENT_STEER);
         }
      }

      return;
   }

   RemoveEnchantment(who = $, state=$)
   "Remove enchantment effects on this occupant"
   {
      return;
   }
   
   BreakTrance(who=$, event=$, state=$, location=$, iVolume=$)
   "If caster runs out of mana or loses trance, spell ends."
   {
      local oUser, lEnchanted;
            
      % Check for Necklace of Jala first
      if Send(who,@IsUsingA,#class=&JalaNecklace)
      {
         % The song keeps going if you get damaged, move, cast, or make an attack.
         if event = EVENT_DAMAGE
            OR event = EVENT_ATTACK
            OR event = EVENT_RUN
            OR event = EVENT_DISRUPT
            OR (event = EVENT_CAST AND Send(Send(SYS, @GetSettings), @CanRecastJalaWithNecklace))
         {
            return FALSE;
         }
      }
   
      iVolume = Nth(state,3);

      % Clean up Trance.
      Send(who,@ClearTranceFlag);
      Send(who,@RemoveEnchantment,#what=self);
      Send(Send(who,@GetOwner),@SomeoneSaid,#type=SAY_MESSAGE,#string=jala_song_ends);
      lEnchanted = Nth(state,2);
      for oUser in lEnchanted
      {
         Send(self,@LeaveSong,#who=oUser,#iVolume=iVolume);
      }
      DeleteTimer(ptDrainTimer);
      ptDrainTimer=$;

      propagate;
   }
   
   DrainTimer(who=$)
   {
      ptDrainNow = TRUE;
      ptDrainTimer = CreateTimer(self,@DrainTimer,viDrainTime);
      return;
   }

   CheckDisruptWithNecklace()
   "Checks the chance to disrupt the spell with a Necklace of Jala on.  "
   "Normally 25% chance."
   {
      if random(1,100) < 25
      {
         return TRUE;
      }

      return FALSE;
   }

   SetSpellPlayerFlag(who=$)
   {
      Send(who,@SetTranceFlag);
      
      return;
   }

   PlaySpellSound(room_obj = $,what = $)
   {
      % Jala plays midis for songs, not wavs.  Just return.
      return;
   }
   
   RemoveEnchantmentEffects()
   "Need to override spell.kod's thing, since we do this ourselves specially."
   {
      return;
   }

   % Replace this to modify volume by spellpower calculations - currently on 0 to 99 scale
   CalculateVolume(who=$, iSpellPower=25)
   {
      return iSpellPower;
   }

   % Replace this to modify range by spellpower calculations
   CalculateRange(who=$, iSpellPower=25)
   {
      local iRange;

      % Default is up to twice base range      
      iRange = viBaseRange + ((viBaseRange*iSpellPower)/99);
      
      return iRange;
   }
      
   CanBeRemovedByPlayer()
   "Returns if a spell can be removed by normal Purge/Purify"
   {
      return FALSE;
   }

   %%% Modifier functions.
   %%% All songs do their effect. Use bounds to avoid song-stacking problems.

   ModifyHitRoll(who = $,what = $,state = $,hit_roll = $,stroke_obj = $,originalValue = 0)
   {
      return hit_roll;
   }

   ModifyDamage(who = $,what = $,state = $,damage = $,stroke_obj = $,originalValue = 0)
   {
      return damage;
   }

   ModifyDefense(who = $,what = $,state = $,defense = $,stroke_obj = $,originalValue = 0)
   {
      return defense;
   }

   ModifyDefenseDamage(who = $,what = $,state = $,damage = $,atype = $,aspell = $,stroke_obj = $,originalValue = 0)
   {
      return damage;
   }
   
   % Add or replace elements in a weapon attack
   ModifyAttackType(who = $,what = $,state = $,attack_type = $)
   {
      return attack_type;
   }

   % Power of outgoing spell attacks
   ModifySpellPower(who=$,what=$,state=$,iSpellPower=0)
   {
      return iSpellPower;
   }

   % Damage of outgoing spell attacks
   ModifySpellDamage(who = $,what = $,state=$,iSpellPower=0,damage=$,originalValue=$)
   {
      return damage;
   }
   
   % Element type of outgoing spell attacks
   ModifySpellType(who = $,what = $,state=$,iSpellPower=0,spell_type=$,originalValue=$)
   {
      return spell_type;
   }
      
   % The absolute flag causes an attack spell to ignore resists and vulnerabilities
   ModifySpellAbsolute(who = $,what = $,state=$,iSpellPower=0,absolute=$,originalValue=$)
   {
      return absolute;
   }
   
   ModifyVigorTime(state = $,time = 1000)
   {
      return time;
   }
      
   ModifyHealthTime(state = $,time = 1000)
   {
      return time;
   }

   ModifyManaTime(state = $,time = 1000)
   {
      return time;
   }
   
   % Usual post-attack delay is 1
   ModifyAttackTime(state=$,time=1,originalValue=1)
   {
      return time;
   }
   
   % Replace this to modify postcast times
   ModifyPostCastTime(state=$,time=1,originalValue=1)
   {
      return time;
   }
   
   % Modifies focus times. Passed percent may be 51% - 149% already based on initial spellpower
   ModifyTranceTime(who=$,state=$,percent=100,iSpellPower=0,originalValue=100)
   {
      return percent;
   }
   
   % This is a Spellbane type effect
   TryPreventSpell(who=$,state=$,iSpellPower=0)
   {
      % False = spell not blocked
      return FALSE;
   }
   
   % This is a Winds type effect
   TryPreventAttack(who=$,state=$,iSpellPower=0)
   {
      % False = attack not blocked
      return FALSE;
   }

   % Use in EnterSong to add resists to a player
   % Must also remove same resists in LeaveSong
   AddResistances(who=$,state=$,value=$)
   {
      Send(who,@AddResistance,#what=-ATCK_SPELL_ALL,#value=value);

      return;
   }

   RemoveResistances(who=$,state=$,value=$)
   {
      Send(who,@RemoveResistance,#what=-ATCK_SPELL_ALL,#value=value);

      return;
   }

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
