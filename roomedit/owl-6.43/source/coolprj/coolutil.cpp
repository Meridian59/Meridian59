//----------------------------------------------------------------------------
// ObjectWindow - OWL NExt
// Copyright 1999-2000. Yura Bidus. All Rights reserved.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Library General Public License for more details.
//
// You should have received a copy of the GNU Library General Public
// License along with this library; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.
//
//  OVERVIEW
//  ~~~~~~~~
//  Source file for implementation of utils.
//  (Generated by OWL 6.x Class Expert for MS VC++, Version 1.5)
//----------------------------------------------------------------------------
#include <coolprj/pch.h>
#pragma hdrstop

using namespace owl;
using namespace std;

#include <coolprj/defs.h>

//-----------------------------------------------------------------------------
// Extract parts from string in for "firts|second|third|"
//
void ExtractStrings(TStringArray& array, const TResId& resId,
                    _TCHAR separator, TModule* module)
{
  if(!module)
    module = & (owl::GetGlobalModule());
  owl::tstring strings = module->LoadString(resId.GetInt());
  _TCHAR* buffer = (_TCHAR*)strings.c_str();
  _TCHAR* p = _tcschr(buffer,separator);
  do{
    if(p){
      _TCHAR c = *p;
      *p = 0;
      array.Add(buffer);
      *p = c;
      buffer = p+1;
      p = _tcschr(buffer,separator);
    }
    else
      array.Add(buffer);
  }while(p);
}
//-----------------------------------------------------------------------------
_COOLFUNC(TColor) GetDefColor16(int index)
{
  TColor rgb[] = {
              RGB (0x00, 0x00, 0x00),
              RGB (0x80, 0x00, 0x00),
              RGB (0x00, 0x80, 0x00),
              RGB (0x80, 0x80, 0x00),
              RGB (0x00, 0x00, 0x80),
              RGB (0x80, 0x00, 0x80),
              RGB (0x00, 0x80, 0x80),
              RGB (0x80, 0x80, 0x80),
              RGB (0xC0, 0xC0, 0xC0),
              RGB (0xFF, 0x00, 0x00),
              RGB (0x00, 0xFF, 0x00),
              RGB (0xFF, 0xFF, 0x00),
              RGB (0x00, 0x00, 0xFF),
              RGB (0xFF, 0x00, 0xFF),
              RGB (0x00, 0xFF, 0xFF),
              RGB (0xFF, 0xFF, 0xFF),
  };
  return rgb[index];
}
//-----------------------------------------------------------------------------
_COOLFUNC(int) FindColorIndex16(const TColor& color)
{
  for(int i = 0; i < 16; i++){
    if(color == GetDefColor16(i))
      return i+1;
  }
  return 0;
}
//-----------------------------------------------------------------------------
// DrawMaskedBitmap
// draws a bitmap given containing a mask
bool DrawMaskedBitmap (HDC hDC, int x, int y, HBITMAP hbm, int XOrigin, int nWidth)
{
  HDC   hdcShadow;
  HDC   hdcSource;
  HBITMAP hbmpOld;
  HBITMAP hbmpOld2;
  HBITMAP hbmDraw;
  BITMAP  bm;
  int    nHeight;
  bool  bReturn;

  if (hbm == NULL)
     return false;

  GetObject (hbm, sizeof (bm), &bm);

  if (nWidth == 0)
    nWidth = bm.bmWidth - XOrigin;

  nHeight = bm.bmHeight >> 1;

  hbmDraw = CreateCompatibleBitmap (hDC, nWidth, nHeight);

  if (hbmDraw == NULL)
    return false;

  hdcShadow = CreateCompatibleDC (hDC);
  hdcSource = CreateCompatibleDC (hDC);

  hbmpOld   = (HBITMAP) SelectObject (hdcShadow, hbmDraw);
  hbmpOld2  = (HBITMAP) SelectObject (hdcSource, hbm);

  bReturn    = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hDC, x, y, SRCCOPY);

  if (bReturn)
    bReturn  = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hdcSource, XOrigin, nHeight, SRCAND);

  if (bReturn)
    bReturn  = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hdcSource, XOrigin, 0, SRCPAINT);

  if (bReturn)
    bReturn  = BitBlt (hDC, x, y, nWidth, nHeight, hdcShadow, 0, 0, SRCCOPY);

  SelectObject (hdcShadow, hbmpOld);
  SelectObject (hdcSource, hbmpOld2);

  DeleteDC (hdcShadow);
  DeleteDC (hdcSource);

  DeleteObject (hbmDraw);

  return bReturn;
}
//-----------------------------------------------------------------------------
//
