//----------------------------------------------------------------------------
// ObjectWindow - OWL NExt
// Copyright 1999-2000. Yura Bidus. All Rights reserved.
//
// For more information, including license details, see
// http://owlnext.sourceforge.net
//
//  OVERVIEW
//  ~~~~~~~~
//  Source file for implementation of utils.
//  (Generated by OWL 6.x Class Expert for MS VC++, Version 1.5)
//----------------------------------------------------------------------------
#include <coolprj/pch.h>
#pragma hdrstop

#include <coolprj/defs.h>
#include <owl/module.h>

using namespace owl;
using namespace std;

//-----------------------------------------------------------------------------
// Extract parts from string in for "firts|second|third|"
//
void ExtractStrings(TStringArray& array, const TResId& resId,
                    _TCHAR separator, TModule* module)
{
  if(!module)
    module = & (owl::GetGlobalModule());
  owl::tstring strings = module->LoadString(resId.GetInt());
  _TCHAR* buffer = (_TCHAR*)strings.c_str();
  _TCHAR* p = _tcschr(buffer,separator);
  do{
    if(p){
      _TCHAR c = *p;
      *p = 0;
      array.Add(buffer);
      *p = c;
      buffer = p+1;
      p = _tcschr(buffer,separator);
    }
    else
      array.Add(buffer);
  }while(p);
}
//-----------------------------------------------------------------------------
_COOLFUNC(TColor) GetDefColor16(int index)
{
  TColor rgb[] = {
              RGB (0x00, 0x00, 0x00),
              RGB (0x80, 0x00, 0x00),
              RGB (0x00, 0x80, 0x00),
              RGB (0x80, 0x80, 0x00),
              RGB (0x00, 0x00, 0x80),
              RGB (0x80, 0x00, 0x80),
              RGB (0x00, 0x80, 0x80),
              RGB (0x80, 0x80, 0x80),
              RGB (0xC0, 0xC0, 0xC0),
              RGB (0xFF, 0x00, 0x00),
              RGB (0x00, 0xFF, 0x00),
              RGB (0xFF, 0xFF, 0x00),
              RGB (0x00, 0x00, 0xFF),
              RGB (0xFF, 0x00, 0xFF),
              RGB (0x00, 0xFF, 0xFF),
              RGB (0xFF, 0xFF, 0xFF),
  };
  return rgb[index];
}
//-----------------------------------------------------------------------------
_COOLFUNC(int) FindColorIndex16(const TColor& color)
{
  for(int i = 0; i < 16; i++){
    if(color == GetDefColor16(i))
      return i+1;
  }
  return 0;
}
//-----------------------------------------------------------------------------
// DrawMaskedBitmap
// draws a bitmap given containing a mask
bool DrawMaskedBitmap (HDC hDC, int x, int y, HBITMAP hbm, int XOrigin, int nWidth)
{
  HDC   hdcShadow;
  HDC   hdcSource;
  HBITMAP hbmpOld;
  HBITMAP hbmpOld2;
  HBITMAP hbmDraw;
  BITMAP  bm;
  int    nHeight;
  bool  bReturn;

  if (hbm == NULL)
     return false;

  GetObject (hbm, sizeof (bm), &bm);

  if (nWidth == 0)
    nWidth = bm.bmWidth - XOrigin;

  nHeight = bm.bmHeight >> 1;

  hbmDraw = CreateCompatibleBitmap (hDC, nWidth, nHeight);

  if (hbmDraw == NULL)
    return false;

  hdcShadow = CreateCompatibleDC (hDC);
  hdcSource = CreateCompatibleDC (hDC);

  hbmpOld   = (HBITMAP) SelectObject (hdcShadow, hbmDraw);
  hbmpOld2  = (HBITMAP) SelectObject (hdcSource, hbm);

  bReturn    = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hDC, x, y, SRCCOPY);

  if (bReturn)
    bReturn  = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hdcSource, XOrigin, nHeight, SRCAND);

  if (bReturn)
    bReturn  = BitBlt (hdcShadow, 0, 0, nWidth, nHeight, hdcSource, XOrigin, 0, SRCPAINT);

  if (bReturn)
    bReturn  = BitBlt (hDC, x, y, nWidth, nHeight, hdcShadow, 0, 0, SRCCOPY);

  SelectObject (hdcShadow, hbmpOld);
  SelectObject (hdcSource, hbmpOld2);

  DeleteDC (hdcShadow);
  DeleteDC (hdcSource);

  DeleteObject (hbmDraw);

  return bReturn;
}
//-----------------------------------------------------------------------------
//
